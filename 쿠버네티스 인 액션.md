# 서평
- 이 책은 크게 3부분으로 구성되어 있습니다. 도커와 쿠버네티스를 간략하게 소개하고 쿠버네티스 클러스터를 설치하는 방법과 간단한 애플리케이션을 실행하는 방법, 쿠버네티스에서 애플리케이션을 실행하기 위해 반드시 이해해야 하는 핵심 개념, 쿠버네티스 클러스터의 내부를 깊이 들여다보며 몇 가지 추가적인 개념을 소개로 구성되어 있습니다. 

# 쿠버네티스 소개
- 쿠버네티스는 조종사, 조타수(선박의 핸들을 잡고 있는 사람)를 뜻하는 그리스어 
- 쿠버네티스 등장 이유 : 구성 요소의 서버 배포를 자동으로 스케줄링하고 구성,관리,장애 처리를 포함하는 자동화가 필요하여 
- 개발자가 운영 팀의 도움 없이도 자신의 애플리케이션을 원하는 만큼 자주 배포할 수 있음. 하드웨어 장애 발생 시 해당 애플리케이션을 자동으로 모니터링하고 스케줄링을 조정해 운영 팀을 도와줌 
- 하드웨어 인프라를 추상화하고 데이터 센터 전체를 하나의 거대한 컴퓨팅 리소스를 제공함. 여러 애플리케이션 구성 요소를 배포할 때 각 구성 요소 서버를 선택하고 배포하며 애플리케이션의 다른 구성 요소를 쉽게 찾고 통신할 수 있게 함 
- 개발자가 모든 유형의 애플리케이션을 배포하고 실행할 수 있는 간단한 플랫폼을 제공할 수 있을 뿐만 아니라 클라우드 공급자의 시스템 관리자가 자신들의 하드웨어에서 실행되는 수만 개의 애플리케이션을 일일이 알 필요가 없게 함 
- 쿠버네티스와 같은 시스템이 필요한 이유
  - 모놀리스 애플리케이션에서 마이크로서비스로 전환
    - 시스템의 증가하는 부하를 처리하려고 CPU, 메모리, 그 밖의 서버 구성 요소를 추가해 서버를 수직 확장(scale up)하거나 서버를 추가하고 애플리케이션의 복사본(또는 복제본)을 실행해 전체 시스템을 수평 확장(scale out)해야 함 
      - 수직 확장은 일반적으로 애플리케이션을 변경할 필요가 없지만 비교적 비용이 많이 들고 실제로는 확장에 한계(상한)가 있음. 
      - 수평 확장은 상대적으로 저렴하지만 애플리케이션 코드의 큰 변경이 필요할 수 있으며 항상 가능한 것도 아님(관계형 데이터 베이스) 
    - 마이크로서비스로 애플리케이션 분할 
      - 마이크로서비스는 일반적으로 RESTful(Repressentaional State Transfer) API를 제공하는 HTTP와 같은 동기 프로토콜과 AMQP(Advanced Message Queuing Protocl)와 같은 비동기 프로토콜로 통신함 
  - 애플리케이션에 일관된 환경 제공 
  - 지속적인 배포로 전환: 데브옵스와 노옵스
    - 데브옵스 : 개발자, 품질 보증(QA), 운영 팀이 전체 프로세스에서 협업해야 함
    - 노옵스 : 자동화로 운영 팀의 손이 거의 필요 없는 환경
      - 하드웨어 인프라를 전혀 알지 못하더라도 운영 팀을 거치지 않고 개발자가 애플리케이션을 직접 배포하는 방식이 가장 이상적 
    - 쿠버네티스를 사용하면 하드웨어를 추상화하고 이를 애플리케이션에 배포, 실행을 위한 플랫폼으로 제공함으로써 개발자는 시스템 관리자의 도움없이도 애플리케이션을 구성, 배포할 수 있으며 시스템 관리자는 실제 실행되는 애플리케이션을 알 필요 없이 인프라를 유지하고 운영하는 데 집중할 수 있음 
- 컨테이너 기술 소개 
  - 베어메탈 머신 : 어떤 소프트웨어도 설치돼 있지 않은 하드웨어 자체를 의미하지만, 클라우드가 보편화되면서 가상화되지 않은 머신을 의미함 
  - 컨테이너 격리를 가능하게 하는 메커니즘
    - 리눅스 네임스페이스로 각 프로세스가 시스템(파일, 프로세스, 네트워크 인터페이스, 호스트 이름 등)에 대한 독립된 뷰만 볼 수 있도록 함.
    - 리눅스 컨트롤 그룹(cgroups)으로, 프로세스가 사용할 수 있는 리소스(CPU, 메모리, 네트워크 대역폭 등)의 양을 제한함 
  - 리눅스 네임스페이스로 프로세스 격리
    - 네임스페이스의 종류
      - 마운트(mnt)
      - 프로세스 ID(pid)
      - 네트워크(net)
      - 프로세스 간 통신(ipc) 
      - 호스트와 도메인 이름(uts)
      - 사용자 ID(user)
  - 도커 컨테이너 플랫폼
    - 도커 기반 컨테이너 이미지와 가상머신 이미지의 큰 차이점은 컨테이너 이미지가 여러 이미지에서 공유되고 재사용될 수 있는 레이어로 구성돼 있다는 것 
    - 동일한 레이어를 포함하는 다른 컨테이너 이미지를 실행할 때 다른 레이어가 이미 다운로드 된 경우 이미지의 특정 레이어만 다운로드 하면 됨 
    - 도커 개념 
      - 도커는 애플리케이션을 패키징, 배포, 실행하기 위한 플랫폼 
      - 애플리케이션을 전체 환경과 함께 패키지화할 수 있음. 애플리케이션에서 필요한 몇 가지 라이브러리나 운영체제의 파일시스템에 설치되는 모든 파일을 포함시킬 수 있음 
      - 이미지 : 애플리케이션과 해당 환경을 패키지화한 것 
      - 레지스트리 : 도커 이미지를 저장하고 다른 사람이나 컴퓨터 간에 해당 이미지를 쉽게 공유할 수 있는 저장소 
      - 컨테이너 : 도커 기반 컨테이너 이미지에서 생성된 일반적인 리눅스 컨테이너 
  - 쿠버네티스 
    - 쿠버네티스 클러스터 아키텍처
      - 마스터 노드는 전체 쿠버네티스 시스템을 제어하고 관리하는 쿠버네티스 컨트롤 플레인을 실행함 
      - 워커 노드는 실제 배포되는 컨테이너 애플리케이션을 실행함 
      - 컨트롤 플레인(Control Plane)
        - 클러스터를 제어하고 작동시킴
        - 구성 요소 
          - 쿠버네티스 API 서버는 사용자, 컨트롤 플레인 구성 요소와 통신함. 
          - 스케줄러는 애플리케이션의 배포를 담당함(애플리케이션의 배포 가능한 각 구성 요소를 워크 노드에 할당) 
          - 컨트롤러 매니저는 구성 요소 복제본, 워커 노드 추적, 노드 장애 처리 등과 같은 클러스터단의 기능을 수행함 
          - Etcd는 클러스터 구성을 지속적으로 저장하는 신뢰할 수 있는 분산 데이터 저장소 
      - 노드 
        - 워커 노드는 컨테이너화된 애플리케이션을 실행하는 시스템 
        - 구성 요소 
          - 컨테이너를 실행하는 도커, rkt 또는 다른 컨테이너 런타임
          - API 서버와 통신하고 노드의 컨테이너를 관리하는 Kubelet 
          - 애플리케이션 구성 요소 간에 네트워크 트래픽을 로드밸런싱하는 쿠버네티스 서비스  프록시(kube-proxy) 
    - 쿠버네티스 사용의 장점
      - 애플리케이션 배포의 단순화
      - 하드웨어 활용도 높이기 
      - 상태 확인과 자가 치유 
      - 오토스케일링
      - 애플리케이션 개발 단순화 

# 도커와 쿠버네티스 첫걸음 
- Minikube는 로컬에서 쿠버네티스를 테스트하고 애플리케이션을 개발하는 목적으로 단일 노드 클러스터를 설치하는 도구 
- 구글 쿠버네티스 엔진을 활용한 관리형 쿠버네티스 클러스터 사용하기 
  - > kubectl describe node gke-kubia-85f6-node-0rrx
    - 오브젝트 세부 정보 가져오기, 출력 결과는 CPU와 메모리, 시스템 정보, 노드에 실행 중인 컨테이너 등을 포함한 노드 상태를 보여줌 
  - kubectl의 alias와 명령줄 자동완성 설정하기
    - ~/.bashrc나 이에 준하는 파일에 추가함. 
    - > alias k=kubectl
- 쿠버네티스 첫 번째 애플리케이션 실행하기 
  - 파드 소개 
    - 파드는 하나 이상의 밀접하게 연관된 컨테이너의 그룹으로 같은 워커 노드에서 같은 리눅스 네임스페이스로 함께 실행됨 
    - 각 파드는 자체 IP, 호스트 이름, 프로세스 등이 있는 논리적으로 분리된 머신 
    - > kubectl get pods : 파드 조회하기 
    - 스케줄링(Scheduling)이라는 용어는 파드가 특정 노드에 할당됨을 의미함. 파드는 즉시 실행됨. 스케줄링이라는 용어의 의미처럼 미래의 특정 시간에 실행됨을 의미하는 것이 아님 
  - 서비스 오브젝트 생성하기 
    - 쿠버네티스에게 앞서 생성한 레플리케이션컨트롤러를 노출하도록 명령함 
    - > kubectl expose rc kubia --type=LoadBalancer --name kubia-http 
- 시스템의 논리적인 부분
  - 레플리케이션컨트롤러의 역할 이해 
    - kubia 레플리케이션 컨트롤러는 항상 정확히 하나의 파드 인스턴스를 실행하도록 지정함 
    - 레플리케이션컨트롤러는 파드를 복제(즉, 여러 개의 파드 복제본을 생성)하고 항상 실행 상태로 만듬 
  - 서비스가 필요한 이유 
    - 파드는 일시적(ephemeral)임. 파드는 언제든 사라질 수 있음. 파드가 실행 중인 노드가 실패할 수도 있고 누군가 파드를 삭제할 수도 있고, 비정상 노드에서 파드가 제거될 수도 있음 
    - 사라진 파드는 레플리케이션컨트롤러에 의해 생성된 파드로 대체됨. 새로운 파드는 다른 IP 주소를 할당받음. 이것이 서비스가 필요한 이유 
- 애플리케이션 수평 확장
  - > kubectl scale rc kubia --replicas=3 
  - 파드의 레플리카 수를 늘리려면 레플리카 컨트롤러에서 의도하는 Desired 레프리카 수를 변경해야 함 
- 애플리케이션이 실행 중인 노드 검사하기 
  - -o wide 옵션을 사용하면 추가 열을 요청할 수 있음. 파드를 조회할 때 이 옵션은 파드 IP와 파드가 실행중인 노드를 표시함 
  - > kubectl get pods -o wide 
- 쿠버네티스 대시보드 소개 
  - 대시보드에서 파드, 레플리케이션컨트롤러, 서비스 같은 클러스터의 많은 오브젝트를 생성할 수 있고 생성, 수정, 삭제 또한 가능함 
  - > kubectl cluster-info | grep dashboard : 대시보드 URL을 찾을 수 있음 
  - > gcloud container clusters describe kubia | grep -E "(username|password):" : 사용자 이름과 암호를 알 수 있음 
  - > minikube dashboard : Minikube를 사용할 때 대시보드 접근하기 

# 파드: 쿠버네티스에서 컨테이너 실행 
- 파드
  - 파드는 함께 배치된 컨테이너 그룹이며 쿠버네티스의 기본 빌딩 블록임 
  - 파드 안에 있는 모든 컨테이너는 같은 노드에서 실행됨 
  - 파드 이해하기
    - 여러 프로세스를 단일 컨테이너로 묶지 않기 때문에, 컨테이너를 함께 묶고 하나의 단위로 관리할 수 있는 또 다른 상위 구조가 필요함 
    - 컨테이너 모음을 사용해 밀접하게 연관된 프로세스를 함께 실행하고 단일 컨테이너 안에서 모두 함께 실행되는 것처럼(거의) 동일한 환경을 제공할 수 있으면서도 이들을 격리된 상태로 유지할 수 있음 
    - 파드 안의 컨테이너가 동일한 네트워크 네임스페이스에서 실행되기 때문에, 동일한 IP주소와 포트 공간을 공유한다는 것 
  - 파드 간 플랫 네트워크 
    - 쿠버네티스 클러스터의 모든 파드는 하나의 플랫(flat)한 공유 네트워크 주소 공간에 상주하므로 모든 파드는 다른 파드의 IP 주소를 사용해 접근하는 것이 가능함 
  - 파드에서 컨테이너의 적절한 구성
    - 다계층 애플리케이션을 여러 파드로 분할
    - 개별 확장이 가능하도록 여러 파드로 분할 
    - 파드에서 여러 컨테이너를 사용하는 경우 
- YAML 또는 JSON 디스크크립터로 파드 생성 
  - 파드를 포함한 다른 쿠버네티스 리소스는 일반적으로 쿠버네티스 REST API 엔드포인트에 JSON 혹은 YAML 매니페스트를 전송해 생성함 
  - 배포된 파드의 전체 YAML
    - YAML이 디스크립터에서 사용한 쿠버네티스 API버전
    - 쿠버네티스 오브젝트/리소스 유형 
    - 파드 메타데이터(이름, 레이블, 어노테이션 등) 
    - 파드 정의/내용(파드 컨테이너 목록, 볼륨 등) 
    - 파드와 그 안의 여러 컨테이너의 상세한 상태 
  - 파드를 정의하는 주요 부분 소개 
    - Metadata: 이름, 네임스페이스, 레이블 및 파드에 관한 기타 정보를 포함함 
    - Spec : 파드 컨테이너, 볼륨, 기타 데이터 등 파드 자체에 관한 실제 명세를 가짐 
    - Status: 파드 상태, 각 컨테이너 설명과 상태, 파드 내부 IP, 기타 기본 정보 등 현재 실행 중인 파드에 관한 현재 정보를 포함함 
  - status 부분에는 특정 시간의 리소스 상태를 보여주는 읽기 전용의 런타임 데이터가 포함돼 있음. 새 파드를 만들 때 status 부분은 작성할 필요가 없음 
  - > kubectl create -f : YAML 또는 JSON 파일로 (파드뿐만 아니라) 리소스를 만드는데 사용함 
  - > kubectl got pod {} -o yaml : 파드의 전체 정의를 볼 수 있음 
  - > kubectl get pods : 파드를 조회해 상태를 확인함 
  - > kubectl logs {} : 애플리케이션 로그 보기(마지막으로 순환된 로그 항목만 보여줌) 
  - 컨테이너 이름을 지정해 다중 컨테이너 파드에서 로그 가져오기 
    - 여러 컨테이너를 포함한 파드인 경우에는, 컨테이너 이름을 kubectl logs 명령에 -c <컨테이너 이름> 옵션과 함께 명시적으로 포함함 
    - > kubectl logs kubia-manual -c kubia 
- 레이블을 이용한 파드 구성 
  - 마이크로서비스 아키텍처의 경우 배포된 마이크로서비스의 수는 매우 쉽게 20개를 초과함. 이러한 구성 요소는 복제돼(동일한 구성 요소의 여러 복사본이 배포됨) 여러 버전 혹은 릴리스(안정,베타,카나리 등)가 동시에 실행됨 
  - 레이블을 통해 파드와 기타 다른 쿠버네티스 오브젝트의 조직화가 이뤄짐 
  - 레이블 소개 
    - 레이블은 파드와 모든 다른 쿠버네티스 리소스를 조직화할 수 있는 단순하면서 강력한 쿠버네티스 기능
    - 레이블은 리소스에 첨부하는 키-값 쌍으로, 이 쌍은 레이블 셀럭터를 사용해 리소스를 선택할 때 활용됨
      - app : 파드가 속한 애플리케이션, 구성 요소 혹은 마이크로서비스를 지정함 
      - rel : 파드에서 실행 중인 애플리케이션이 안정, 베타 혹은 카나리 릴리스인지 보여줌(카나리 릴리스는 안정 버전 옆에 새 버전을 배포하고, 모든 사용자에게 배포하기 전에 소수의 사용자만이 새로운 버전을 사용할 수 있도록 해서 어떻게 동작하는지 볼 수 있게 하는 것)
- 파드에 어노테이션 달기 
  - 파드 및 다른 오브젝트는 레이블 외에 어노테이션(annotations)을 가질 수 있음. 어노테이션은 키-값 쌍으로 레이블과 거의 비슷하지만 식별 정보를 갖지 않음 
  - 어노테이션이 유용하게 사용되는 경우는 파드나 다른 API 오브젝트에 설명을 추가해 두는 것. 클러스터를 사용하는 모든 사람이 개별 오브젝트에 관한 정보를 신속하게 찾아볼 수 있음 
- 네임스페이스를 사용한 리소스 그룹화 
  - 오브젝트를 겹치지 않는 그룹으로 분할하고자 할 때 한 번에 하나의 그룹 안에서만 작업하고 싶을 것. 쿠버네티스는 오브젝트를 네임스페이스로 그룹화함 
  - 쿠버네티스 네임스페이스는 오브젝트 이름의 범위를 제공함. 모든 리소스를 하나의 단일 네임스페이스에 두는 대신에 여러 네임스페이스로 분할할 수 있으며, 분리된 네임스페이스는 같은 리소스 이름을 다른 네임스페이스에 걸쳐 여러 번 사용할 수 있게 해줌 
  - 네임스페이스의 필요성 
    - 여러 네임스페이스를 사용하면 많은 구성 요소를 가진 복잡한 시스템을 좀 더 작은 개별 그룹으로 분리할 수 있음 
    - 멀티테넌트(multi-tenant)환경처럼 리소스를 분리하는 데 사용됨
  - 네임스페이스가 제공하는 격리 
    - 네임스페이스를 사용하면 오브젝트를 별도 그룹으로 분리해 특정한 네임스페이스 안에 속한 리소스를 대상으로 작업할 수 있게 해주지만, 실행 중인 오브젝트에 대한 격리는 제공하지 않음 

# 레플리케이션과 그 밖의 컨트롤러: 관리되는 파드 배포 
- 레플리케이션컨트롤러 또는 디플로이먼트와 같은 유형의 리소스를 생성해 실제 파드를 생성하고 관리함 
- 파드를 안정적으로 유지하기 
  - 쿠버네티스에 컨테이너 목록을 제공하면 해당 컨테이너를 클러스터 어딘가에서 계속 실행되도록 할 수 있다는 것 
  - 파드 리소스를 생성하고 쿠버네티스가 이 파드를 실행할 워커 노드를 지정하며 해당 노드에서 파드의 컨테이너가 실행되도록 함으로써 이 작업을 수행함 
  - 컨테이너의 주 프로세스에 크래시(Crash)가 발생하면 Kubelet이 컨테이너를 다시 시작함 
  - 라이브니스 프로브 소개 
    - 라이브니스 프로브(liveness probe)를 통해 컨테이너가 살아 있는지 확인할 수 있음. 파드의 스펙(specification)에 각 컨테이너의 라이브니스 프로브를 지정할 수 있음. 쿠버네티스는 주기적으로 프로브를 실행하고 프로브가 실패할 경우 컨테이너를 다시 시작함 
      - HTTP GET 프로브는 지정한 IP 주소, 포트, 경로에 HTTP GET 요청을 수행함 
      - TCP 소켓 프로브는 컨테이너의 지정된 포트에 TCP 연결을 시도함 
      - Exec 프로브는 컨테이너 내의 임의의 명령을 실행하고 명령의 종료 상태 코드를 확인함 
    - > kubectl logs mypod --previous : 이전 컨테이너가 종료된 이유를 파악하려는 경우 이전 컨테이너의 로그를 확인
    - 컨테이너가 종료되면 완전히 새로운 컨테이너가 생성됨. 동일한 컨테이너가 다시 시작되는 것이 아님 
  - 라이브니스 프로브의 추가 속성 설정 
    - kubectl describe 
      - Liveness: http-get gttp://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3 
      - 명시적으로 지정한 라이브니스 프로브 옵션 외에도 지연(delay), 제한 시간(timeout), 기간(period) 등과 같은 추가 속성을 볼 수도 있음 
      - delay=0s 부분은 컨테이너가 시작된 후 바로 프로브가 시작된다는 것을 나타남. 제한 시간이 1초로 설정돼 있으므로(timeout=1s) 컨테이너가 1초 안에 응답해야 함 
      - 10초마다 프로브를 수행하며(period=10s) 프로브가 3번 연속 실패하면(#failure=3) 컨테이너가 다시 시작됨 
    - initialDelaySeconds 속성
      - initialDelaySeconds: 15 - 쿠버네티스는 첫 번째 프로브 실행까지 15초를 대기함 
      - 초기 지연을 설정하지 않으면 프로브는 컨테이너가 시작되마자 프로브를 시작함. 이 경우 대부분 애프리케이션이 요청을 받을 준비가 돼 있지 않기 때문에 프로브가 실패함 
  - 효과적인 라이브니스 프로브 생성 
    - 운영 환경에서 실행 중인 파드는 반드시 라이브니스 프로브를 정의해야 함. 정의하지 않으면 쿠버네티스가 애플리케이션이 살아 있는지를 알 수 있는 방법이 없음 
    - 라이브니스 프로브는 애플리케이션의 내부만 체크하고, 외부 요인의 영향을 받지 않도록 해야 함 
- 레플리케이션 컨트롤러 소개 
  - 레플리케이션 컨트롤러는 쿠버네티스 리소스로서 파드가 항상 실행되도록 보장함. 클러스터에서 노드가 사라지거나 노드에서 파드가 제거된 경우, 레플리케이션 컨트롤는 사라진 파드를 감지해 교체 파드를 생성함 
  - 동작 
    - 레플리케이션컨트롤러는 실행 중인 파드 목록을 지속적으로 모니터링하고, 특정 유형의 실제 파드 수가 의도하는 수와 일치하는지 항상 확인함. 이런 파드가 너무 적게 실행 중인 경우 파드 템플릿에서 새 복제본을 만듬. 너무 많은 파드가 실행 중이면 초과 복제본이 제거됨 
    - 레플리케이션컨트롤러의 세 가지 요소 이해 
      - 레이블 셀렉터(label selector) : 레플리케이션컨트롤러의 범위에 있는 파드를 결정함 
      - 레플리카 수(replica count) : 실행할 파드의 의도하는(desired) 수를 지정함 
      - 파드 템플릿(pod template) : 새로운 파드 레플리카를 만들 때 사용됨 
    - 레플리케이션컨트롤러 사용 시 이점 
      - 기존 파드가 사라지면 새 파드를 시작해 파드(또는 여러 파드의 복제본)가 항상 실행되도록 함 
      - 클러스터 노드에 장애가 발생하면 장애가 발생한 노드에서 실행 중인 모든 파드(레플리케이션컨트롤러의 제어하에 있는 파드)에 관한 교체 복제본이 생성됨 
      - 수동 또는 자동으로 파드를 쉽게 수평으로 확장할 수 있게 함 
    - > kubectl get rc - terminating(종료 중) 
      - 의도하는(desired) 파드 수, 실제 파드(current) 수, 준비된(ready) 파드 수를 표시하는 세 개의 열이 표시됨 
  - 쿠버네티스를 사용하지 않는 환경에서 노드에 장애가 발생하면 운영 팀은 해당 노드에서 실행 중인 애플리케이션을 수동으로 다른 시스템에 마이그레이션해야 할 것. 쿠버네티스는 이를 자동으로 수행함 
  - 레플리케이션컨트롤러가 생성한 파드는 어떤 식으로든 이 레플리케이션컨트롤러와 묶이지 않음. 레플리케이션컨트롤러는 레이블 셀렉터와 일치하는 파드만을 관리함 
  - 수평 파드 스케일링 
    - 레플리케이션컨트롤러 스케일 업(확장)하기 
      - > kubectl scale rc kubia --replicas=10 
  - 레플리케이션 컨트롤러 삭제 
    - kubectl delete를 사용해 레플리케이션컨트롤러를 삭제할 때, 명령에 --cascade=false 옵션을 추가해 해당 파드를 계속 실행시킬 수 있음 
    - > kubectl delete rc kubia --cascade=false 
    - 레플리케이션컨트롤러를 삭제해서 파드가 어디에도 속해 있지 않음. 더 이상 관리되지 않음. 그러나 언제든 적절한 레이블 셀렉터를 사용하는 새 레플리케이션컨트롤러를 작성해 다시 관리할 수 있음 
- 레플리케이션컨트롤러 대신 레플리카세 사용하기 
  - 초기에는 레플리케이션컨트롤러가 파드를 복제하고 노드 장애가 발생했을 때 재스케줄링하는 유일한 쿠버네티스 구성 요소였음. 후에 레플리카셋이라는 유사한 리소스가 도입되어 차세대 레플리케이션컨트롤러이며, 레플리케이션컨트롤러를 완전히 대체할 것(레플리케이션컨트롤러는 결국 사용되지 않게 될 것) 
  - 레플리카셋과 레플리케이션컨트롤러 비교 
    - 레플리카셋은 레플리케이션컨트롤러와 똑같이 동작하지만 좀 더 풍부한 표현식을 사용하는 파드 셀렉터를 갖고 있음. 
    - 레플리케이션컨트롤러의 레이블 셀렉터는 특정 레이블이 있는 파드만을 매칭시킬 수 있는 반면, 레플리카셋의 셀렉터는 특정 레이블이 없는 파드나 레이블의 값과 상관없이 특정 레이블의 키를 갖는 파드를 매칭시킬 수 있음 
    - 레플리케이션컨트롤러는 값에 상관없이 레이블 키의 존재만으로 파드를 매칭시킬 수 없지만, 레플리카셋은 가능함 
  - 레플리카셋 정의하기 
    - 파드가 가져야 하는 레이블은 selector 속성 바로 아래 나열하는 대신 SElector.matchLables 아래에 지정함 
  - 레플리카 생성 및 검사 
    - > kubectl get rs 
  - 레플리카셋의 더욱 표현적인 레이블 셀렉터 사용하기 
    - 셀렉터에 표현식을 추가할 수 있음 
    - In은 레이블의 값이 지정된 값 중 하나와 일치해야 함 
    - NotIn은 레이블의 값이 지정된 값과 일치하지 않아야 함 
    - Exists 파드는 지정된 키를 가진 레이블이 포함돼야 함(값은 중요하지 않음). 이 연산자를 사용할 때는 값 필드를 지정하지 않아야 함 
    - DoesNotExist는 파드에 지정된 키를 가진 레이블이 포함돼 있지 않아야 함. 값 필드를 지정하지 않아야 함 
- 데몬셋을 사용해 각 노드에 정확히 한 개의 파드 실행하기 
  - 클러스터의 모든 노드에, 노드당 하나의 파드만 실행되길 원하는 경우
  - 모든 노드에서 로그 수집기와 리소스 모니터를 실행하려는 경우. 좋은 예는 쿠버네티스의 kube-proxy 프로세스이며, 서비스를 작동시키기 위해 모든 노드에서 실행돼야 함 
  - 데몬셋(각 노드에 정확히 하나의 복제본만 실행)은 각 노드에서 하나의 파드 복제본만 실행하지만 레플리카셋은 클러스터 전체에서 무작위로 파드를 분산시킴 
  - 데몬셋으로 모든 노드에 파드 실행하기 
    - 모든 클러스터 노드마다 파드를 하나만 실행하려면 데몬셋(DaemonSet) 오브젝트를 생성해야 함. 데몬셋에 의해 생성되는 파드는 타깃 노드가 이미 지정돼 있고 쿠버네티스 스케줄러를 건너뛰는 것을 제외하면 이 오브젝트는 레플리케이션컨트롤러 또는 레플리카셋과 매우 유사함. 파드가 클러스터 내에 무작위로 흩어져 배포되지 않음 
    - 레플리카셋(또는 레플리케이션컨트롤러)이 클러스터에 원하는 수의 파드 복제본이 존재하는지 확인하는 반면, 데몬셋에는 원하는 복제본 수라는 개념이 없음. 파드 셀렉터와 일치하는 파드 하나가 각 노드에서 실행 중인지 확인하는 것이 데몬셋이 수행해야 하는 역할이기 때문에 복제본 개념이 필요하지 않음 
    - 노드가 다운되면 데몬셋은 다른 곳에서 파드를 생성하지 않음. 그러나 새 노드가 클러스터에 추가되면 데몬셋은 즉시 새 파드 인스턴스를 새 노드에 배포함. 실수로 파드 중 하나를 삭제해 노드에 데몬셋의 파드가 없는 경우에도 마찬가지 
- 완료 가능한 단일 태스크를 수행하는 파드 실행 
  - 잡 리소스 
    - 잡은 파드의 컨테이너 내부에서 실행 중인 프로세스가 성공적으로 완료되면 컨테이너를 다시 시작하지 않는 파드를 실행할 수 있음 
    - 노드에 장애가 발생한 경우 해당 노드에 있던 잡이 관리하는 파드는 레플리카셋 파드와 같은 방식으로 다른 노드로 다시 스케줄링됨. 프로세스 자체에 장애가 발생한 경우(프로세스가 에러 종료 코드를 리턴할 때), 잡에서 컨테이너를 다시 시작할 것인지 설정할 수 있음 

# 서비스: 클라이언트가 파드를 검색하고 통신을 가능하게 함 
- 서비스 
  - 쿠버네티스의 서비스는 동일한 서비스를 제공하는 파드 그룹에 지속적인 단일 접점을 만들려고 할 때 생성하는 리소스. 각 서비스는 서비스가 존재하는 동안 절대 바뀌지 않는 IP 주소와 포트가 있음 
  - 클라이언트는 해당 IP와 포트로 접속한 다음 해당 서비스를 지원하는 파드 중 하나로 연결됨 
  - 서비스 생성
    - kubectl expose로 서비스 생성 
      - expose 명령어는 레플리케이션컨트롤러에서 사용된 것과 동일한 파드 셀렉터를 사용해 서비스 리소스를 생성하고 모든 파드를 단일 IP 주소와 포트로 노출함 
    - 실행 중인 컨테이너에 원격으로 명령어 실행 
      - kubectl exec 명령어를 사용하면 기존 파드의 컨테이너 내에서 원격으로 임의의 명령어를 실행할 수 있음. 컨테이너의 내용, 상태, 환경을 검사할 때 유용함 
      - kubectl exec {k get pods의 파드} -- curl -s {http://10.111.249.153 - k get svc의 클러스터 IP}
        - 명령어의 더블 대시(--)는 kubectl 명령줄 옵션의 끝을 의미함. 더블 대시 뒤의 모든 것은 파드 내에서 실행돼야 하는 명령 
- 클러스터 외부에 있는 서비스 연결 
  - 서비스 엔드포인트 
    - 서비스는 파드에 직접 연결(link)되지 않음. 대신 엔드포인트 리소스가 그 사이에 있음
    - 엔드포인트 리소스는 서비스로 노출되는 파드의 IP 주소와 포트 목록 
  - 외부 서비스를 위한 별칭 생성  
    - ExternalName 서비스 생성 
      - 외부 서비스의 별칭으로 사용되는 서비스를 만들려면 유형(type) 필드를 ExternalName으로 설정해 서비스 리소스를 만듬 
- 외부 클라이언트에 서비스 노출 
  - 외부에서 서비스를 액세스할 수 있는 방법
    - 노드포트로 서비스 유형 설정 : 노드포트 서비스의 경우 각 클러스터 노드는 노드 자체에서 포트를 결고 해당 포트로 수신된 트래픽을 서비스로 전달함. 이 서비스는 내부 클러스터 IP와 포트로 액세스할 수 있을 뿐만 아니라 모든 노드의 전용 포트로도 액세스할 수 있음 
    - 서비스 유형을 노드포트 유형의 확장인 로드밸런서로 설정 : 쿠버네티스가 실행 중인 클라우드 인프라에서 프로비저닝된 전용 로드밸런서로 서비스에 액세스할 수 있음. 로드밸런서는 트래픽을 모든 노도의 노드포트로 전달함. 클라이언트는 로드밸런서의 IP로 서비스에 액세스함 
    - 단일 IP 주소로 여러 서비스를 노출하는 인그레스 리소스 만들기 : HTTP 레벨에서 작동하므로 4계층 서비스보다 더 많은 기능을 제공할 수 있음 
  - 노드포트 서비스 사용 
    - 노드포트 서비스를 만들면 쿠버네티스는 모든 노드에 특정 포트를 할당하고(모든 노드에서 동일한 포트 번호가 사용됨) 서비스를 구성하는 파드로 들어오는 연결을 전달함 
    - 일반 서비스(실제 유형은 ClusterIP)와 유사하지만 서비스의 내부 클러스터 IP뿐만 아니라 모든 노드의 IP와 할당된 노드포트로 서비스에 액세스할 수 있음 
    - 노드포트 서비스 확인 
      - > kubectl get svc kubia-nodeport 
      - EXTERNAL-IP에 <nodes>라고 표시돼 있고 클러스터 노드의 IP 주소로 서비스에 액세스할 수 있음을 나타냄 
  - 외부 로드밸런서로 서비스 노출
    - 클라우드 공급자에서 실행되는 쿠버네티스 크러스터는 일반적으로 클라우드 인프라에서 로드밸런서를 자동으로 프로비저닝하는 기능을 제공함 
    - 로드밸런서는 공개적으로 액세스 가능한 고유한 IP주소를 가지며 모든 연결을 서비스로 전달함. 로드밸런서의 IP 주소로 서비스에 액세스할 수 있음 
- 인그레스 리소스로 서비스 외부 노출 
