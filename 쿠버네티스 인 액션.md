# 서평
- 이 책은 크게 3부분으로 구성되어 있습니다. 도커와 쿠버네티스를 간략하게 소개하고 쿠버네티스 클러스터를 설치하는 방법과 간단한 애플리케이션을 실행하는 방법, 쿠버네티스에서 애플리케이션을 실행하기 위해 반드시 이해해야 하는 핵심 개념, 쿠버네티스 클러스터의 내부를 깊이 들여다보며 몇 가지 추가적인 개념을 소개로 구성되어 있습니다. 

# 쿠버네티스 소개
- 쿠버네티스는 조종사, 조타수(선박의 핸들을 잡고 있는 사람)를 뜻하는 그리스어 
- 쿠버네티스 등장 이유 : 구성 요소의 서버 배포를 자동으로 스케줄링하고 구성,관리,장애 처리를 포함하는 자동화가 필요하여 
- 개발자가 운영 팀의 도움 없이도 자신의 애플리케이션을 원하는 만큼 자주 배포할 수 있음. 하드웨어 장애 발생 시 해당 애플리케이션을 자동으로 모니터링하고 스케줄링을 조정해 운영 팀을 도와줌 
- 하드웨어 인프라를 추상화하고 데이터 센터 전체를 하나의 거대한 컴퓨팅 리소스를 제공함. 여러 애플리케이션 구성 요소를 배포할 때 각 구성 요소 서버를 선택하고 배포하며 애플리케이션의 다른 구성 요소를 쉽게 찾고 통신할 수 있게 함 
- 개발자가 모든 유형의 애플리케이션을 배포하고 실행할 수 있는 간단한 플랫폼을 제공할 수 있을 뿐만 아니라 클라우드 공급자의 시스템 관리자가 자신들의 하드웨어에서 실행되는 수만 개의 애플리케이션을 일일이 알 필요가 없게 함 
- 쿠버네티스와 같은 시스템이 필요한 이유
  - 모놀리스 애플리케이션에서 마이크로서비스로 전환
    - 시스템의 증가하는 부하를 처리하려고 CPU, 메모리, 그 밖의 서버 구성 요소를 추가해 서버를 수직 확장(scale up)하거나 서버를 추가하고 애플리케이션의 복사본(또는 복제본)을 실행해 전체 시스템을 수평 확장(scale out)해야 함 
      - 수직 확장은 일반적으로 애플리케이션을 변경할 필요가 없지만 비교적 비용이 많이 들고 실제로는 확장에 한계(상한)가 있음. 
      - 수평 확장은 상대적으로 저렴하지만 애플리케이션 코드의 큰 변경이 필요할 수 있으며 항상 가능한 것도 아님(관계형 데이터 베이스) 
    - 마이크로서비스로 애플리케이션 분할 
      - 마이크로서비스는 일반적으로 RESTful(Repressentaional State Transfer) API를 제공하는 HTTP와 같은 동기 프로토콜과 AMQP(Advanced Message Queuing Protocl)와 같은 비동기 프로토콜로 통신함 
  - 애플리케이션에 일관된 환경 제공 
  - 지속적인 배포로 전환: 데브옵스와 노옵스
    - 데브옵스 : 개발자, 품질 보증(QA), 운영 팀이 전체 프로세스에서 협업해야 함
    - 노옵스 : 자동화로 운영 팀의 손이 거의 필요 없는 환경
      - 하드웨어 인프라를 전혀 알지 못하더라도 운영 팀을 거치지 않고 개발자가 애플리케이션을 직접 배포하는 방식이 가장 이상적 
    - 쿠버네티스를 사용하면 하드웨어를 추상화하고 이를 애플리케이션에 배포, 실행을 위한 플랫폼으로 제공함으로써 개발자는 시스템 관리자의 도움없이도 애플리케이션을 구성, 배포할 수 있으며 시스템 관리자는 실제 실행되는 애플리케이션을 알 필요 없이 인프라를 유지하고 운영하는 데 집중할 수 있음 
- 컨테이너 기술 소개 
  - 베어메탈 머신 : 어떤 소프트웨어도 설치돼 있지 않은 하드웨어 자체를 의미하지만, 클라우드가 보편화되면서 가상화되지 않은 머신을 의미함 
  - 컨테이너 격리를 가능하게 하는 메커니즘
    - 리눅스 네임스페이스로 각 프로세스가 시스템(파일, 프로세스, 네트워크 인터페이스, 호스트 이름 등)에 대한 독립된 뷰만 볼 수 있도록 함.
    - 리눅스 컨트롤 그룹(cgroups)으로, 프로세스가 사용할 수 있는 리소스(CPU, 메모리, 네트워크 대역폭 등)의 양을 제한함 
  - 리눅스 네임스페이스로 프로세스 격리
    - 네임스페이스의 종류
      - 마운트(mnt)
      - 프로세스 ID(pid)
      - 네트워크(net)
      - 프로세스 간 통신(ipc) 
      - 호스트와 도메인 이름(uts)
      - 사용자 ID(user)
  - 도커 컨테이너 플랫폼
    - 도커 기반 컨테이너 이미지와 가상머신 이미지의 큰 차이점은 컨테이너 이미지가 여러 이미지에서 공유되고 재사용될 수 있는 레이어로 구성돼 있다는 것 
    - 동일한 레이어를 포함하는 다른 컨테이너 이미지를 실행할 때 다른 레이어가 이미 다운로드 된 경우 이미지의 특정 레이어만 다운로드 하면 됨 
    - 도커 개념 
      - 도커는 애플리케이션을 패키징, 배포, 실행하기 위한 플랫폼 
      - 애플리케이션을 전체 환경과 함께 패키지화할 수 있음. 애플리케이션에서 필요한 몇 가지 라이브러리나 운영체제의 파일시스템에 설치되는 모든 파일을 포함시킬 수 있음 
      - 이미지 : 애플리케이션과 해당 환경을 패키지화한 것 
      - 레지스트리 : 도커 이미지를 저장하고 다른 사람이나 컴퓨터 간에 해당 이미지를 쉽게 공유할 수 있는 저장소 
      - 컨테이너 : 도커 기반 컨테이너 이미지에서 생성된 일반적인 리눅스 컨테이너 
  - 쿠버네티스 
    - 쿠버네티스 클러스터 아키텍처
      - 마스터 노드는 전체 쿠버네티스 시스템을 제어하고 관리하는 쿠버네티스 컨트롤 플레인을 실행함 
      - 워커 노드는 실제 배포되는 컨테이너 애플리케이션을 실행함 
      - 컨트롤 플레인(Control Plane)
        - 클러스터를 제어하고 작동시킴
        - 구성 요소 
          - 쿠버네티스 API 서버는 사용자, 컨트롤 플레인 구성 요소와 통신함. 
          - 스케줄러는 애플리케이션의 배포를 담당함(애플리케이션의 배포 가능한 각 구성 요소를 워크 노드에 할당) 
          - 컨트롤러 매니저는 구성 요소 복제본, 워커 노드 추적, 노드 장애 처리 등과 같은 클러스터단의 기능을 수행함 
          - Etcd는 클러스터 구성을 지속적으로 저장하는 신뢰할 수 있는 분산 데이터 저장소 
      - 노드 
        - 워커 노드는 컨테이너화된 애플리케이션을 실행하는 시스템 
        - 구성 요소 
          - 컨테이너를 실행하는 도커, rkt 또는 다른 컨테이너 런타임
          - API 서버와 통신하고 노드의 컨테이너를 관리하는 Kubelet 
          - 애플리케이션 구성 요소 간에 네트워크 트래픽을 로드밸런싱하는 쿠버네티스 서비스  프록시(kube-proxy) 
    - 쿠버네티스 사용의 장점
      - 애플리케이션 배포의 단순화
      - 하드웨어 활용도 높이기 
      - 상태 확인과 자가 치유 
      - 오토스케일링
      - 애플리케이션 개발 단순화 

# 도커와 쿠버네티스 첫걸음 
- Minikube는 로컬에서 쿠버네티스를 테스트하고 애플리케이션을 개발하는 목적으로 단일 노드 클러스터를 설치하는 도구 
- 구글 쿠버네티스 엔진을 활용한 관리형 쿠버네티스 클러스터 사용하기 
  - > kubectl describe node gke-kubia-85f6-node-0rrx
    - 오브젝트 세부 정보 가져오기, 출력 결과는 CPU와 메모리, 시스템 정보, 노드에 실행 중인 컨테이너 등을 포함한 노드 상태를 보여줌 
  - kubectl의 alias와 명령줄 자동완성 설정하기
    - ~/.bashrc나 이에 준하는 파일에 추가함. 
    - > alias k=kubectl
- 쿠버네티스 첫 번째 애플리케이션 실행하기 
  - 파드 소개 
    - 파드는 하나 이상의 밀접하게 연관된 컨테이너의 그룹으로 같은 워커 노드에서 같은 리눅스 네임스페이스로 함께 실행됨 
    - 각 파드는 자체 IP, 호스트 이름, 프로세스 등이 있는 논리적으로 분리된 머신 
    - > kubectl get pods : 파드 조회하기 
    - 스케줄링(Scheduling)이라는 용어는 파드가 특정 노드에 할당됨을 의미함. 파드는 즉시 실행됨. 스케줄링이라는 용어의 의미처럼 미래의 특정 시간에 실행됨을 의미하는 것이 아님 
  - 서비스 오브젝트 생성하기 
    - 쿠버네티스에게 앞서 생성한 레플리케이션컨트롤러를 노출하도록 명령함 
    - > kubectl expose rc kubia --type=LoadBalancer --name kubia-http 
- 시스템의 논리적인 부분
  - 레플리케이션컨트롤러의 역할 이해 
    - kubia 레플리케이션 컨트롤러는 항상 정확히 하나의 파드 인스턴스를 실행하도록 지정함 
    - 레플리케이션컨트롤러는 파드를 복제(즉, 여러 개의 파드 복제본을 생성)하고 항상 실행 상태로 만듬 
  - 서비스가 필요한 이유 
    - 파드는 일시적(ephemeral)임. 파드는 언제든 사라질 수 있음. 파드가 실행 중인 노드가 실패할 수도 있고 누군가 파드를 삭제할 수도 있고, 비정상 노드에서 파드가 제거될 수도 있음 
    - 사라진 파드는 레플리케이션컨트롤러에 의해 생성된 파드로 대체됨. 새로운 파드는 다른 IP 주소를 할당받음. 이것이 서비스가 필요한 이유 
- 애플리케이션 수평 확장
  - > kubectl scale rc kubia --replicas=3 
  - 파드의 레플리카 수를 늘리려면 레플리카 컨트롤러에서 의도하는 Desired 레프리카 수를 변경해야 함 
- 애플리케이션이 실행 중인 노드 검사하기 
  - -o wide 옵션을 사용하면 추가 열을 요청할 수 있음. 파드를 조회할 때 이 옵션은 파드 IP와 파드가 실행중인 노드를 표시함 
  - > kubectl get pods -o wide 
- 쿠버네티스 대시보드 소개 
  - 대시보드에서 파드, 레플리케이션컨트롤러, 서비스 같은 클러스터의 많은 오브젝트를 생성할 수 있고 생성, 수정, 삭제 또한 가능함 
  - > kubectl cluster-info | grep dashboard : 대시보드 URL을 찾을 수 있음 
  - > gcloud container clusters describe kubia | grep -E "(username|password):" : 사용자 이름과 암호를 알 수 있음 
  - > minikube dashboard : Minikube를 사용할 때 대시보드 접근하기 
