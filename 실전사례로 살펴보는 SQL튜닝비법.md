# 실전사례로 살펴보는 SQL 튜닝비법
# 실행계획
- 실행계획 : 사용자가 SQL을 실행하여 데이터를 추출하려고 할 때, 옵티마이저가 수립하는 작업 절차 
- SQL이 실행되어 데이터를 처리하고자 할 때, 수립되는 데이터 처리 방법임
- 실행계획이 목적했던 대로 수립되지 않으면, SQL의 퍼포먼스에 문제가 발생함
- EXPLAIN PLAN : 실행계획만을 확인할 수 있음 
  - SQL에 대한 실행계획만을 확인할 수 있음
  - 명령을 사용할 때 데이터를 처리하지 않음
  - ![image](https://user-images.githubusercontent.com/47103479/172156005-be75897a-c425-4197-a445-4f0648c56ce3.png)
  - 데이터 처리를 직접하지 않기 때문에 데이터베이스에 부하x
- SET AUTOTRACE : 실행계획과 I/O 관련 정보를 확인할 수 있음 
  - EXPLAIN PLAN 명령과는 달리 한 번의 명령으로, 여러 개의 SQL에 대한 실행계획을 바로 볼 수 있음
  - 다양하게 옵션을 사용할 수 있어서 여러 가지의 정보를 선택적으로 확인할 수 있음
  - ![image](https://user-images.githubusercontent.com/47103479/172156542-f197b902-fac7-444a-8fea-29332ba1e7dd.png)
  - 명령의 옵션
  - ![image](https://user-images.githubusercontent.com/47103479/172156752-4aad49df-74ea-4938-abd7-21f3adb1d76a.png)

# 옵티마이저
- 사용자가 실행한 SQL을 해석하고, 데이터를 추출을 위한 실행계획을 수립하는 프로세스
- 옵티마이저 종류
  - 오라클
    - RBO(Rule Based Optimizer) : 초창기 버전부터 제공함
      - 규칙기준 옵티마이저는 인덱스 구조나 사용하는 연산자에 따라 부여되는 순위가 정해져 있음(Rank Rule)
      - 기본적으로 15개의 순위가 매겨진 규칙이 있음
      - SQL에 대한 실행계획이 하나 이상일 경우엔, 순위가 높은 규칙을 이용하게 됨
    - CBO(Cost Based Optimizer) : v10g부터 기본적인 설정으로 적용되고 있음
      - 대상 row들을 처리하는데 필요한 자원 사용을 최소화해서, 궁극적으로 데이터를 빨리 처리하는 데 목적이 있음
      - CBO에 영향을 미치는 비용 산정 요소
        - 각종 통계 정보, Hint, 연산자, Index, Cluster, DBMS 버전, CPU/Memory 용량, Disk I/O 등과 같이 매우 다양함
      - CBO의 성능을 최적의 상태로 유지시키기 위해서 테이블, 인덱스, 클러스터 등을 대상으로 통계 정보를 생성함

# 인덱스
- 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위해 인덱스를 생성하여 사용함 
- 인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에 효율적이며, 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 나음
- B*Tree 구조
  - 가장 많이 사용되는 인덱스의 구조라 할 수 있으며, 인덱스의 데이터 저장 방식이기도 함 
  - Root(기준) / Branch(중간) / Leaf(말단) Node로 구성됨 
  - Leaf 노드 = 인덱스 칼럼의 값(오름(내림) 차순으로 Sort되어 저장됨) + ROWID(테이블에 있는 해당 row를 찾기 위해 사용되는 논리적인(저장위치) 정보)
  - ![image](https://user-images.githubusercontent.com/47103479/172624212-ba4920a1-310e-429f-a7a9-274f4a2974ef.png)
  - ORDER BY에 의하 SOrt를 피할 수 있음
  - MAX/MIN의 효율적인 처리가 가능함 
  - 인덱스 선정 절차
    - 프로그램 개발에 이용된 모든 테이블에 대하여 Access Path 조사
    - 인덱스 칼럼 선정 및 분포도 조사
    - Critical Access Path 결정 및 우선 순위 선정
    - 인덱스 칼럼의 조합 및 순서 결정
    - 시험 생성 및 테스트
    - 결정된 인덱스를 기준으로 프로그램 반영
    - 실제 적용
  - 인덱스 생성 및 변경 시 고려할 사항
    - 기존 프로그램의 동작에 영향성 검토
    - 필요할 때마다 인덱스 생성으로 인한 인덱스 개수의 증가와 이로 인한 DML 작업의 속도
    - 비록 개별 칼럼의 분포도가 좋지 않을지라도 다른 칼럼과 결합하여 자주 사용되고, 결합할 경우에 분포도가 양호하다면 결합 인덱스 생성에 긍정적으로 검토 
  - 인덱스 스캔의 원리
    - 옵티마이저가 인덱스 사용을 위한 실행계획을 수립함
      - 조건을 만족하는 최초의 인덱스 row를 찾음
      - Access된 인덱스 row의 ROWID를 이용해서 테이블에 있는 row를 찾음(Random Access)
      - 처리 범위가 끝날 때까지 차례대로 다음 인덱스 row를 찾으면서 (Scan) 위를 반복함
    - 인덱스 스캔 시에는 한 번의 I/O가 발생할 때 마다 한 개의 Block 씩을 처리함
  - 인덱스의 필요성
    - 고유 인덱스의 Equal(=)과 범위(Range) 검색
    - 중복(Non-Unique) 인덱스의 범위(Range) 검색
    - OR & IN 조건 - 결과의 결합
    - NOT BETWEEN 검색 

# 결합인덱스
- 인덱스 머지 : 개별 칼럼에 인덱스가 생성되어 있으면서 모두 where 절에 Equal(=) 조건으로 사용되어, 각각의 인덱스 조합으로 자료에 접근하는 것을 의미함
- 일반적으로 결합인덱스를 사용할 경우, 좋은 엑세스 경로를 제공함
- 결합인덱스 칼럼 선택
  - WHERE 절에서 AND 조건으로 자주 결합되어 사용되면서 각각의 분포도 보다 두 개 이상의 칼럼이 결합될 때 분포도가 좋아지는 칼럼들
  - 다른 테이블과 조인의 연결고리로 자주 사용되는 칼럼들
  - 하나 이상의 키 칼럼 조건으로 같은 테이블의 칼럼들이 자주 조회될 때, 이러한 칼럼을 모두 포함(결합)
- 결합인덱스의 칼럼 순서 결정
  - Where 절 조건에 많이 사용되는 컬럼 우선
  - Equal('=')로 사용되는 칼럼 우선
  - 분포도가 좋은 칼럼 우선
  - 자주 이용되는 Sort의 순서로 결정
- INDEX SKIP SCANNING
  - 결합인덱스의 첫 번째 칼럼이 WHERE절에서 제외되어 있고, 두 번째 칼럼부터 WHERE절에 조건으로 기술되어 있는 경우에도, 그 인덱스가 사용되는 경우 
- 인덱스 매칭률
  - 인덱스 매칭률 = WHERE절에서 1st칼럼 부터 연속된 칼럼에 대해 상수(값)를 '='로 비교하는 칼럼의 개수 / 인덱스를 구성하는 칼럼의 총 개수
  - 범위 제한 조건
    -  결합 인덱스의 선행하는 칼럼(첫 번째 칼럼 포함) 순서로 WHERE 절에 '='로 연속된 경우, 해당하는 조건을 범위제한 조건이라 함
  -  체크 조건
    -  WHERE 절 조건에서 선행 칼럼이'=' 조건에 없다면 후행 조건은 체크조건이 됨 

# 인덱스 활용이 불가능한 경우 
- 6블록 이상의 데이터를 가진 테이블에 대해서, 쿼리로 처리할 데이터가 전체 데이터 중 15% 이상을 초과할 경우엔 인덱스를 사용하지 않는 것이 매우 좋은 성능을 냄 
- 조건에 의한 처리범위가 넓어짐으로 인해 분포도가 나빠지는 경우가 있는데, 이 경우 인덱스 스캔을 하는 것보다는 FULL TABLE SCAN을 하는 것이 바람직함
- NOT 연산자 사용
- IS NULL, IS NOT NULL 사용
- 옵티마이저의 취사 선택
  - 옵티마이저의 자의적인 판단에 의해서 인덱스를 사용할 수도 있고 사용하지 않을 수도 있는데, 이러한 것을 취사 선택이라고 함 
  - Rule Base Optimizer : 정해진 규칙 기준
  - Cost Base Optimizer : 비용 기준 
- External suppressing
  - 불필요한 함수를 사용한 경우
  - 문자열 결합 
  - DATE 변수의 가공 
  - 산술식의 적용
- Internal suppressing
  - 간단한 연산식
  - 논리비교 연산식
  - 함수호출 
- 옵티마이저에 의한 선택 절차
  - 특정 테이블에 대해서 SQL의 주어진 조건으로 인해 사용될 수 있는 인덱스가 두 개 이상인 경우 
  - 주어진 조건에 대한 각 인덱스 별로 매칭률을 계산해서 매칭률이 높은 것을 우선적으로 선택함
  - 인덱스 별 매칭률이 같을 경우에는 인덱스를 구성하는 칼럼의 개수가 많은 것을 우선적으로 선택함
  - 인덱스 별 매칭률과 인덱스를 구성하는 칼럼의 개수가 같을 경우에는 가장 최근에 생성된 것을 우선적으로 선택함

# NESTED LOOPS 조인
- 옵티마이저가 Driving Table을 결정함(Outer Table)
  - Driven Table : Driving Table이 아닌 테이블(Inner Table)
- Driving Table의 각 row에 대해 이들이 추출될 때마다 Driven Table의 연관된 모든 row를 조인에 의해 액세스
- 튜닝 포인트
  - 테이블 간 조인 횟수를 최소화 할 수 있도록 Driving Table(조인 순서 제어)
  - Driven Table의 연결고리 칼럼에 대한 인덱스 구성 
- 장단점
  - 인덱스에 의한 랜덤 액세스에 기반하고 있기 때문에(좋은 성능을 보임) 대량의 데이터 처리 시 적합하지 않음(인덱스가 없는 상태에서 속도가 저하됨)
  - 대용량 데이터를 처리할 경우 성능이 저하됨 
  - Driving Table로는 테이블의 데이터가 적은 마스터 테이블이거나, where 절 조건으로 적절하게 row를 제어할 수 있는 것이어야 함
  - Driven Table에는 조인을 위한 적절한 인덱스가 생성되어 있어야 함
- 조인 순서 제어 방법
  - 조인 순서 제어를 위한 힌트 사용
    - /*+ ORDERED */ : From 절에 기술한 테이블 순서대로 제어
    - /*+ LEADING(table명)*/ : 힌트 내에 제시한 테이블이 드라이빙으로 채택됨
    - ORDERED 힌트와 같이 사용할 경우 LEADING 힌트는 무시됨 
  - 뷰(View) 활용
  - 서프레싱(suppressing) 활용
  - FROM 절의 테이블 순서 변경
    - RBO 하에서 각 테이블에 대한 규칙이 동일할 때, FROM 절로부터 멀리 있는 테이블부터 처리함 
- dirven 테이블에 대한 FULL table scan  회수는 driving 테이블로부터 읽어 들이는 row수 만큼이 됨 
  - 이러한 상황에서 할 수 있는 조인이 Sort Merge와 Hash 조인
- 연결고리 칼럼에 대한 인덱스의 중요성
  - 양쪽 모두 인덱스가 있는 경우 - 두 테이블 중 조회되는 결과가 적은 테이블을 선택하여 드라이빙 테이블로 선택함
  - 한쪽만 인덱스가 있는 경우 - 인덱스가 없는 쪽 테이블을 드라이빙 테이블로 사용함
  - 양쪽 모두 인덱스가 없는 경우 - Nested Loops 조인 방식으로 조인이 이뤄지지 않음 
