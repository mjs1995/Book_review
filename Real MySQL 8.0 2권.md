# 서평
# 쿼리 작성및 최적화
- MySQL 예약어
  - 테이블을 생성할 때는 항상 역따옴표(`)로 테이블이나 칼럼의 이름을 둘러싸지 않은 상태로 생성하길 권장함, 예약어인지 아닌지 MySQL 서버가 에러로 알려주기 때문
- 리터럴 표기법 문자열
  - SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해서 표시함 
  - REGEXP 연산자
    - ^ : 문자열의 시작을 표시. 정규 표현식은 그 표현식에 일치하는 부분이 문자열의 시작이나 중간 또는 끝부분 어디에 나타나든 상관없지만 "^"심범을 표현식의 앞쪽에 넣어주면 일치하는 부분이 반드시 문자열의 제일 앞쪽에 있어야 함을 의미
    - $ : 문자열의 끝을 표시. "^"와는 반대로 표현식의 끝부분에 "$"를 넣어주면 일치하는 부분이 반드시 문자열의 제일 끝에 있어야 함을 의미함 
    - [] : 문자 그룹을 표시. [xyz] 또는 [x-z]라고 표현하면 'x','y','z' 문자 중 하나인지 확인한느 것, 대괄호는 문자열이 아니라 문자 하나와 일치하는지 확인하는 것 
    - () : 문자열 그룹을 표시, (xyz)라고 표현하면 세 문자 중 한 문자가 있는지 체크하는 것이 아니라 반드시 xyz가 모두 있는지 확인하는 것 
    - |: "|"로 연결된 문자열 중 하나인지 확인함. "abc|xyz"라고 표현하면 "abc"이거나 "xyz"인지 확인하는 것
    - .: 어떠한 문자든지 1개의 문자를 표시하며, 정규 표현식으로 "..."이라고 표현했다면 3개의 문자(실제 문자의 값과 관계없이)로 구성된 문자열을 찾는 것 
    - *: 이 기호 앞에 표시된 정규 표현식이 0 또는 1번 이상 반복될 수 있다는 표시
    - +: 이 기호 앞에 표시된 정규 표현식이 1번 이상 반복될 수 있다는 표시
    - ?: 이 기호 앞에 표시된 정규 표현식이 0 또는 1번만 올 수 있다는 표시 
- MySQL 내장 함수
  - 현재 시간 조회(NOW, SYSDATE)
    - 하나의 SQL에서 모든 NOW() 함수는 같은 값을 가지지만 SYSDATE() 함수는 하나의 SQL 내에서도 호출되는 시점에 따라 결괏값이 달라짐
    - SYSDATE() 함수는 두 가지 큰 잠재적인 문제 존재
      - 첫 번째로는 SYSDATE() 함수가 사용된 SQL 레플리카 서버에서 안정적으로 복제되지 못함
      - 두 번째로는 SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못함
  - 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
    - UNIX_TIMESTAMP() 함수는 '1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수 
  - 문자열 처리
    - RPAD(), LAPD() 함수는 문자열의 좌측 또는 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수
    - RTRIM() 함수와 LTRIM() 함수는 문자열의 우측 또는 좌측에 연속된 공백 문자(Space, NewLine, Tab문자)를 제거하는 함수 
  - GROUP BY 문자열 결합
    - GROUP_CONCAT() 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하므로 상당히 유용하게 사용됨
  - 암호화 및 해시 함수(MD5, SHA, SHA2)
    - MD5와 SHA 모두 비대칭형 암호화 알고리즘인데, 인자로 전달된 문자열을 각각 지정된 비트 수의 해시 값을 만들어내는 함수
    - SHA() 함수는 SHA-1 암호화 알고리즘을 사용하며, 결과로 160비트(20바이트) 해시 값을 반환함 
    - SHA2() 함수는 SHA 암호화 알고리즘보다 더 강력한 224비트부터 512비트 암호화 알고리즘을 사용해 생성된 해시 값을 반환함
    - MD5() 함수는 메시지 다이제스트(Message Digest) 알고리즘을 사용해 128비트(16바이트) 해시 값을 반환함
  - 벤치마크(BENCHMARK)
    - BENCHMARK() 함수는 SLEEP() 함수와 같이 디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수
    - 지정한 횟수만큼 반복 실행하는데 얼마나 시간이 소요됐는지가 중요할뿐
    - SELECT BENCHMARK(10, expr)로 실행하는 경우에는 벤치마크 횟수에 관계없이 단 1번의 네트워크, 쿼리 파싱 및 최적화 비용이 소요된다는 점을 고려해야함
  - IP 주소 변환(INET_ATON, INET_NTOA)
     - INET_ATON() 함수와 INET_NTOA() 함수를 이용해 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공함
     - INET_ATON() 함수는 문자열로 구성된 IPv4 주소를 정수형으로 반환하는 함수, INET_NTOA() 함수는 정수형의 IPv4 주소를 사람이 읽을 수 있는 형태의 '.'으로 구분된 문자열로 반환하는 함수 
  - JSON 필드 크기(JSON_STORAGE_SIZE)
    - JSON 데이터는 텍스트 기반이지만 MySQL 서버는 디스크의 저장 공간을 절약하기 위해 JSON 데이터를 실제 디스크에 저장할 때 BSON(Binary JSON) 포맷을 사용함
    - JSON_STORAGE_SIZE() 함수를 제공
  - JSON 필드 추출(JSON_EXTRACT)
  - JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
    - JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지를 확인하는 함수 
  - JSON 오브젝트 생성(JSON_OBJECT)
    - RDBMS 칼럼의 값을 이용해 JSON 오브젝트를 생성하는 함수
  - JSON 칼럼으로 집계
    - JSON_OBJECTAGG()와 JSON_ARRAYAGG() 함수는 GROUP BY 절과 함께 사용되는 집계 함수로서, RDBMS 칼럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수 
  - JSON 데이터를 테이블로 변환
    - JSON_TABLE() 함수는 JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어 반환함
- SELECT
  - Short-Circuit Evaluation
    - 여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화
    - MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 Short-circuit Evaluation 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정함
    - WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 Short-circuit Evaluation과는 무관하게 MySQL 서버는 그 조건을 가장 최우선으로 사용함 
    - MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것 
    - WHERE 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 평가되기 때문에 고려하지 않아도 됨
- DISTINCT
  - LIMIT
    - ORDER BY나 GROUP BY 또는 DISTINCT가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어주기 때문에 쿼리의 작업량을 상당히 줄여줌
- JOIN
  - JOIN 순서와 인덱스
    - 조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면됨, 하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복함 
    - 드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지함 
    - 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립함 
    - 드리븐 테이블을 풀 테이블 스캔하는 실행 계획으로 조인이 실행됐기 때문에 옵티마이저가 조인 버퍼를 사용함
  - OUTER JOIN의 성능과 주의사항
    - ```sql
      SELECT *
      FROM employees e
        LEFT(->INNER) JOIN dept_manger mgr ON mgr.emp_no = e.emp_no
      WHERE mgr.dept_no = 'd001';
      ```
    - ON 절에 조인 조건을 명시했지만 아우터로 조인되는 테이블인 dept_manager의 dept_no='d001' 조건을 WHERE 절에 명시한 것은 잘못된 조인 방법, LEFT JOIN이 사용된 쿼리는 WHERE 절의 조건 때문에 MySQL 옵티마이저가 LEFT JOIN을 다음 쿼리와 같이 INNER JOIN으로 변환해서 실행시킴
    - ```sql
      SELECT *
      FROM employee e 
        LEFT JOIN dept_manger mgr on mgr.emp_no = e.emp_no AND mgr.dept_no='d001';
      ``` 
  - 지연된 조인(Delayed join)
    - 조인의 결과를 GROUP BY하거나 ORDER BY하면 조인을 실행하기 전의 레코드에 GROUP BY나 ORDER BY를 수행하는 것보다 많은 레코드를 처리해야 함 
    - 지연된 조인이란 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미함, 지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있음
    - 지연된 조인은 조인의 개수를 줄이는 것뿐만 아니라 GROUP BY나 ORDER BY 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 함 
  - 
