# 서평
# 쿼리 작성및 최적화
- MySQL 예약어
  - 테이블을 생성할 때는 항상 역따옴표(`)로 테이블이나 칼럼의 이름을 둘러싸지 않은 상태로 생성하길 권장함, 예약어인지 아닌지 MySQL 서버가 에러로 알려주기 때문
- 리터럴 표기법 문자열
  - SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해서 표시함 
  - REGEXP 연산자
    - ^ : 문자열의 시작을 표시. 정규 표현식은 그 표현식에 일치하는 부분이 문자열의 시작이나 중간 또는 끝부분 어디에 나타나든 상관없지만 "^"심범을 표현식의 앞쪽에 넣어주면 일치하는 부분이 반드시 문자열의 제일 앞쪽에 있어야 함을 의미
    - $ : 문자열의 끝을 표시. "^"와는 반대로 표현식의 끝부분에 "$"를 넣어주면 일치하는 부분이 반드시 문자열의 제일 끝에 있어야 함을 의미함 
    - [] : 문자 그룹을 표시. [xyz] 또는 [x-z]라고 표현하면 'x','y','z' 문자 중 하나인지 확인한느 것, 대괄호는 문자열이 아니라 문자 하나와 일치하는지 확인하는 것 
    - () : 문자열 그룹을 표시, (xyz)라고 표현하면 세 문자 중 한 문자가 있는지 체크하는 것이 아니라 반드시 xyz가 모두 있는지 확인하는 것 
    - |: "|"로 연결된 문자열 중 하나인지 확인함. "abc|xyz"라고 표현하면 "abc"이거나 "xyz"인지 확인하는 것
    - .: 어떠한 문자든지 1개의 문자를 표시하며, 정규 표현식으로 "..."이라고 표현했다면 3개의 문자(실제 문자의 값과 관계없이)로 구성된 문자열을 찾는 것 
    - *: 이 기호 앞에 표시된 정규 표현식이 0 또는 1번 이상 반복될 수 있다는 표시
    - +: 이 기호 앞에 표시된 정규 표현식이 1번 이상 반복될 수 있다는 표시
    - ?: 이 기호 앞에 표시된 정규 표현식이 0 또는 1번만 올 수 있다는 표시 
- MySQL 내장 함수
  - 현재 시간 조회(NOW, SYSDATE)
    - 하나의 SQL에서 모든 NOW() 함수는 같은 값을 가지지만 SYSDATE() 함수는 하나의 SQL 내에서도 호출되는 시점에 따라 결괏값이 달라짐
    - SYSDATE() 함수는 두 가지 큰 잠재적인 문제 존재
      - 첫 번째로는 SYSDATE() 함수가 사용된 SQL 레플리카 서버에서 안정적으로 복제되지 못함
      - 두 번째로는 SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못함
  - 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
    - UNIX_TIMESTAMP() 함수는 '1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수 
  - 문자열 처리
    - RPAD(), LAPD() 함수는 문자열의 좌측 또는 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수
    - RTRIM() 함수와 LTRIM() 함수는 문자열의 우측 또는 좌측에 연속된 공백 문자(Space, NewLine, Tab문자)를 제거하는 함수 
  - GROUP BY 문자열 결합
    - GROUP_CONCAT() 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하므로 상당히 유용하게 사용됨
  - 암호화 및 해시 함수(MD5, SHA, SHA2)
    - MD5와 SHA 모두 비대칭형 암호화 알고리즘인데, 인자로 전달된 문자열을 각각 지정된 비트 수의 해시 값을 만들어내는 함수
    - SHA() 함수는 SHA-1 암호화 알고리즘을 사용하며, 결과로 160비트(20바이트) 해시 값을 반환함 
    - SHA2() 함수는 SHA 암호화 알고리즘보다 더 강력한 224비트부터 512비트 암호화 알고리즘을 사용해 생성된 해시 값을 반환함
    - MD5() 함수는 메시지 다이제스트(Message Digest) 알고리즘을 사용해 128비트(16바이트) 해시 값을 반환함
  - 벤치마크(BENCHMARK)
    - BENCHMARK() 함수는 SLEEP() 함수와 같이 디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수
    - 지정한 횟수만큼 반복 실행하는데 얼마나 시간이 소요됐는지가 중요할뿐
    - SELECT BENCHMARK(10, expr)로 실행하는 경우에는 벤치마크 횟수에 관계없이 단 1번의 네트워크, 쿼리 파싱 및 최적화 비용이 소요된다는 점을 고려해야함
  - IP 주소 변환(INET_ATON, INET_NTOA)
     - INET_ATON() 함수와 INET_NTOA() 함수를 이용해 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공함
     - INET_ATON() 함수는 문자열로 구성된 IPv4 주소를 정수형으로 반환하는 함수, INET_NTOA() 함수는 정수형의 IPv4 주소를 사람이 읽을 수 있는 형태의 '.'으로 구분된 문자열로 반환하는 함수 
  - JSON 필드 크기(JSON_STORAGE_SIZE)
    - JSON 데이터는 텍스트 기반이지만 MySQL 서버는 디스크의 저장 공간을 절약하기 위해 JSON 데이터를 실제 디스크에 저장할 때 BSON(Binary JSON) 포맷을 사용함
    - JSON_STORAGE_SIZE() 함수를 제공
  - JSON 필드 추출(JSON_EXTRACT)
  - JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
    - JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지를 확인하는 함수 
  - JSON 오브젝트 생성(JSON_OBJECT)
    - RDBMS 칼럼의 값을 이용해 JSON 오브젝트를 생성하는 함수
  - JSON 칼럼으로 집계
    - JSON_OBJECTAGG()와 JSON_ARRAYAGG() 함수는 GROUP BY 절과 함께 사용되는 집계 함수로서, RDBMS 칼럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수 
  - JSON 데이터를 테이블로 변환
    - JSON_TABLE() 함수는 JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어 반환함
- SELECT
  - Short-Circuit Evaluation
    - 여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화
    - MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 Short-circuit Evaluation 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정함
    - WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 Short-circuit Evaluation과는 무관하게 MySQL 서버는 그 조건을 가장 최우선으로 사용함 
    - MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것 
    - WHERE 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 평가되기 때문에 고려하지 않아도 됨
- DISTINCT
  - LIMIT
    - ORDER BY나 GROUP BY 또는 DISTINCT가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어주기 때문에 쿼리의 작업량을 상당히 줄여줌
- JOIN
  - JOIN 순서와 인덱스
    - 조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면됨, 하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복함 
    - 드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지함 
    - 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립함 
    - 드리븐 테이블을 풀 테이블 스캔하는 실행 계획으로 조인이 실행됐기 때문에 옵티마이저가 조인 버퍼를 사용함
  - OUTER JOIN의 성능과 주의사항
    - ```sql
      SELECT *
      FROM employees e
        LEFT(->INNER) JOIN dept_manger mgr ON mgr.emp_no = e.emp_no
      WHERE mgr.dept_no = 'd001';
      ```
    - ON 절에 조인 조건을 명시했지만 아우터로 조인되는 테이블인 dept_manager의 dept_no='d001' 조건을 WHERE 절에 명시한 것은 잘못된 조인 방법, LEFT JOIN이 사용된 쿼리는 WHERE 절의 조건 때문에 MySQL 옵티마이저가 LEFT JOIN을 다음 쿼리와 같이 INNER JOIN으로 변환해서 실행시킴
    - ```sql
      SELECT *
      FROM employee e 
        LEFT JOIN dept_manger mgr on mgr.emp_no = e.emp_no AND mgr.dept_no='d001';
      ``` 
  - 지연된 조인(Delayed join)
    - 조인의 결과를 GROUP BY하거나 ORDER BY하면 조인을 실행하기 전의 레코드에 GROUP BY나 ORDER BY를 수행하는 것보다 많은 레코드를 처리해야 함 
    - 지연된 조인이란 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미함, 지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있음
    - 지연된 조인은 조인의 개수를 줄이는 것뿐만 아니라 GROUP BY나 ORDER BY 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 함 
  - 레터럴 조인(Lateral Join)
    - 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인하는 것이 가능해짐
    - ```sql
      SELECT *
      FROM employees e
        LEFT JOIN LATERAL (SELECT *
                           FROM salaries s 
                           WHERE s.emp_no = e.emp_no
                           ORDER BY s.from_date DESC LIMIT 2) s2 ON s2.emp_no = e.emp_no
      WHERE e.first_name = 'Matt';
      ```
    - employees 테이블에서 이름이 matt인 사원에 대해 사원별로 가장 최근 급여 변경 내역을 최대 2건씩만 반환함. 래터럴 조인에서 가장 중요한 부분은 FROM 절에 사용된 서브쿼리(Derived Table)에서 외부 쿼리의 FROM 절에 정의된 테이블의 칼럼을 참조할 수 있다는 것 
    - LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성되기 때문에 꼭 필요한 경우에만 사용해야함
  - ORDER BY
    - 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행하는 SELECT를 가정. MyISAM 테이블은 테이블에 저장된 순서대로 가져오는데, 이 순서가 정확히 ISNERT된 순서는 아닐 수도 있음. 일반적으로 테이블의 레코드가 삭제되면서 빈 공간이 생기고, INSERT되는 레코드는 항상 테이블의 마지막이 아니라 빈 공간이 있으면 그 빈 공간에 저장되기 때문. InnoDB의 경우에는 항상 프라이머리 키로 클러스터링돼 있기 때문에 풀 테이블 스캔의 경우에는 기본적으로 프라이머리 키 순서대로 레코드를 가져옴 
  - 서브쿼리
    - SELECT 절에 사용된 서브쿼리
      - SELECT 절에 사용된 서브쿼리는 내부적으로 임시 테이블을 만들거나 쿼리를 비효올적으로 실행하게 만들지는 않기 때문에 서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의할 사항은 없음 
      - SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고, 오로지 스칼라 서브쿼리만 사용할 수 있음 
      - 스칼라 서브쿼리 : 레코드의 칼럼이 각각 하나인 결과를 만들어내는 서브쿼리
      - 로우 서브쿼리, 레코드 서브쿼리 : 스칼라 서브쿼리보다 레코드 건수가 많거나 칼럼 수가 많은 결과를 만들어 내는 서브쿼리
      - 서브쿼리로 실행될 때보다 조인으로 처리할 때가 조금 더 빠르기 때문에 가능하다면 조인으로 쿼리를 작성하는 것이 좋음 
  - CTE(Common Table Expression)
    - CTE(Common Table Expression)는 이름을 가지는 임시 테이블로서, SQL 문장 내에서 한 번 이상 사용될 수 있으며 SQL 문장이 종료되면 자동으로 CTE 임시 테이블은 삭제됨 
    - CTE는 재귀적 반복 실행 여부를 기준으로 Non-recursive와 Recursive CTE로 구분됨 
    - 비 재귀적 CTE(Non-Recursive CTE)
      - CTE를 재귀적으로 사용하지 않더라도 기존 FROM 절에 사용되던 서브쿼리에 비해 3가지 장점이 존재
        - CTE는 임시 테이블은 재사용 가능하므로 FROM 절의 서브쿼리보다 효율적
        - CTE로 선언된 임시 테이블은 다른 CTE 쿼리에서 참조할 수 있음 
        - CTE는 임시 테이블의 생성 부분과 사용 부분의 코드를 분리할 수 있으므로 가독성이 높음 
    - 재귀적 CTE(Recursive CTE)
      - 윈백(Win Back)이라는 단어는 처음 프로젝트를 시작할 때는 MySQL 서버를 검토했다가 MySQL 서버의 기능이나 처리 성능이 부족해서 다른 DBMS를 선택했지만 시간이 지나서 다시 MySQL 서버로 되돌아가는 것을 의미함 
      - 윈백 프로젝트 : 특정 DBMS에서 다른 DBMS로 일괄 마이그레이션하는 작업
  - 윈도우 함수(Window Function)
    - 윈도우 함수를 GROUP BY 칼럼으로 사용하거나 WHERE 절에 사용할 수 없다는 것 
    - 윈도우 함수 기본 사용법
      - 프레임 : 윈도우 함수의 각 파티션 안에서도 연산 대상 레코드별로 연산을 수행할 소그룹이 사용되는데 이를 뜻함
      - 윈도우 함수에서 프레임을 명시적으로 지정하지 않아도 MySQL 서버는 상황에 맞게 프레임을 묵시적으로 선택함
      - 프레임은 레코드의 순서대로 현재 레코드 기준 앞뒤 몇 건을 연산 범위로 제한하는 역할을 함 
  - 잠금을 사용하는 SELECT
    - 잠금 없는 읽기(Non Lokcing Consistent Read) : InnoDB 테이블에 대해서는 레코드를 SELECT할 때 레코드에 아무런 잠금도 걸지 않는데 이를 뜻함
    - FOR SHARE는 SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 걸고, FOR UPDATE는 SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금을 검 
    - NOWAIT & SKIP LOCKED
      - NOWAIT 옵션을 사용하면 SELECT 쿼리가 해당 레코드에 대해 즉시 잠금을 획득했다면 NOWAIT 옵션이 없을때와 동일하게 실행됨
      - SKIP LOCKED 옵션은 SELECT하려는 레코드가 다른 트랝개션에 의해 이미 잠겨진 상태라면 에러를 반환하지 않는 잠긴 레코드는 무시하고 잠금이 걸리지 않은 레코드만 가져옴 
      - SKIP LOCKED 절을 가진 SELECT 구문은 확정적이지 않은 (NOT-DETERMINISTIC) 쿼리가 됨 
        - 확정적(DETERMINISTIC)이란 말의 의미는 입력이 동일하면 시점에 관계없이 동일한 결과를 반환하는 것을 의미함, SKIP LOCKED 절을 가진 SELECT 쿼리는 실행하는 시점에 따라(아무런 데이터 변경이 없는 상태에서도) 각 트랜잭션의 간섭에 의해 다른 결과를 반환할 수도 있는데, 이를 비확정적(NOT-DETERMINISTIC)
- INSERT 
  - INSERT IGNORE
    - INSERT 문장의 IGNORE 옵션은 저장하는 레코드의 프라이머리 키나 유니크 인덱스 칼럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우, 그리고 저장하는 레코드의 칼럼이 테이블의 칼럼과 호환되지 않는 경우 모두 무시하고 다음 레코드를 처리할 수 있게 해줌
  - INSERT ... ON DUPLICATE KEY UPDATE
    - 프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATE 문장의 역할을 수행하게 해줌 
  - LOAD DATA 명령 주의 사항
    - MySQL 서버의 LOAD DATA 명령의 단점
      - 단일 스레드로 실행
      - 단일 트랜잭션으로 실행
  - Auto-Increment 칼럼
    - AUTO_INC 잠금 : MySQL 서버에서는 자동 증가 값의 채번을 위해서는 잠금이 필요함 
- UPDATE와 DELETE
  - JOIN UPDATE
    - 두 개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭젷는 쿼리를 JOIN UPDATE라고 함
    - 조인된 테이블 중에서 특정 테이블의 칼럼값을 다른 테이블의 칼럼에 업데이트해야 할 때 주로 조인 업데이트를 사용함
    - 일반적으로 JOIN UPDATE는 조인되는 모든 테이블에 대해 읽기 참조만 되는 테이블은 읽기 잠금이 걸리고, 칼럼이 변경되는 테이블은 쓰기 잠금이 걸림 
    - JOIN UPDATE 문장이 웹 서비스 같은 OLTP 환경에서는 데드락을 유발할 가능성이 높으므로 너무 빈번하게 사용하는 것은 피하는 것이 좋음. 배치 프로그램이나 통계용 UPDATE 문장에서는 유용하게 사용할 수 있음
- 데이터베이스 변경
  - 다른 DBMS에서는 스키마와 데이터베이스를 구분해서 관리하지만 MySQL 서버에서는 스키마와 데이터베이스는 동격의 개념 
- 테이블 스페이스 변경
  - 제너럴 테이블스페이스 : 여러 테이블의 데이터를 한꺼번에 저장하는 테이블스페이스
- 테이블 변경
  - SHOW CREATE TABLE 명령은 칼럼의 목록과 인덱스, 외래키 정보를 동시에 보여주기 때문에 SQL을 튜닝하거나 테이블의 구조를 확인할 때 주로 이 명령을 사용함 
  - 테이블 리빌드 작업은 주로 레코드의 삭제가 자주 발생하는 테이블에서 데이터가 저장되지 않은 빈 공간(프래그멘테이션, Fragmentation)을 제거해 디스크 사용 공간을 줄이는 역할을 함 
  - 테이블 명 변경
    - 일정 주기로 테이블을 교체(Swap)해야 하는 경우 존재
    - 여러 테이블의 RENAME 명령을 하나의 문장으로 묶어서 실행할 수 있음
      - > RENAME TABLE batch TO batch_old, batch_new TO batch;
      - MySQL 서버는 RENAME TABLE 명령에 명시된 모든 테이블에 대해 잠금을 걸고 테이블의 이름 변경 작업을 실행하게 됨, 응용 프로그램의 입장에서 보면 batch 테이블을 조회하려고 할 때 이미 잠금이 걸려있기 때문에 대기함 
  - 테이블 상태 조회
    - MySQL의 모든 테이블은 만들어진 시간, 대략의 레코드 건수, 데이터 파일의 크기 등의 정보를 가지고 있음. 또한 데이터 파일의 버전이나 레코드 포맷 등과 같이 자주 사용되지는 않지만 중요한 정도보 가지고 있는데 이러한 정보를 조회할 수 있는 명령어는 SHOW TABLE STATUS ...
    - > SHOW TABLE STATUS LIKE 'employees' \G
      - Like 패턴관 같은 조건을 사용해 특정 테이블의 상태만 조회하는 것도 가능
      - \G는 레코드의 칼럼을 라인당 하나씩만 표현하게 하는 옵션, \G는 SQL 문장의 끝을 의미하기도 하기 때문에 \G가 있으면 별도로 ","를 붙이지 않아도 쿼리 입력이 종료된 것으로 간주함 
    - ```sql
      SELECT * FROM information_schema.TABLES
      WHERE TABLE_SCHEMA = 'employees' AND TABLE_NAME ='employees' \G
      ```
      - information_schema 데이터베이스에는 MySQL 서버가 가진 스키마들에 대한 메타 정보를 가진 딕셔너리 테이블이 관리됨 
      - information_schema 데이터베이스에 존재하는 테이블들은 실제로 존재하는 테이블이 아니라 MySQL 서버가 시작되면서 데이터베이스와 테이블 등에 대한 다양한 메타 정보를 모아서 메모리에 모아두고 사용자가 참조할 수 있는 테이블 
    - ```sql
      SELECT TABLE_SCHEMA,
             SUM(DATA_LENGTH)/1024/1024 as data_size_mb
             SUM(INDEX_LENGTH)/1024/1024 as index_size_mb
      FROM information_schema.TABLES
      GROUP BY TABLE_SCHEMA;
      ```
    - information_schema 데이터베이스의 테이블
      - 데이터베이스 객체에 대한 메타 정보
      - 테이블과 칼럼에 대한 간략한 통계 정보
      - 전문 검색 디버깅을 위한 뷰(view)
      - 압축 실행과 실패 횟수에 대한 집계 
  - 테이블 구조 복사
    - 데이터는 복사하지 않고 테이블의 구조만 동일하게 복사하는 명령으로 CREATE TABLE ... LIKE를 사용하면 구조가 같은 테이블들을 손쉽게 생성할 수 있음
- 칼럼 변경
  - 칼럼 추가
  - ```sql
    --// 테이블의 제일 마지막에 새로운 칼럼을 추가
    ALTER TABLE employees ADD COLUMN emp_telno VARCHAR(20),
    ALGORITHM = INSTANT;
    --// 테이블의 중간에 새로운 칼럼을 추가 
    ALTER TABLE employees ADD COLUMN emp_telno VARCHAR(20) AFTER emp_no,
    ALGORITHM=INPLACE, LOCK=NONE;
    ```
- 인덱스 변경
  - ```sql
    --// 1.index_new라는 이름으로 새로운 인덱스 생성
    ALTER TABLE employees
    ADD INDEX index_new (first_name, last_name),
    ALGORITHM = INPLACE, LOCK=NONE;
    
    --// 2.기존 인덱스(ix_firstname)를 삭제하고, 동시에 새로운 인덱스(index_new)의 이름을 ix_firstname으로 변경
    ALTER TABLE employees
    DROP INDEX ix_firstname,
    RENAME INDEX index_new TO ix_firstname,
    ALGORITHM = INPLACE, LOCK=NONE;
    ```
- 프로세스 조회 및 강제 종료
  - MySQL 서버에 접속된 사용자의 목록이나 각 클라이언트 사용자가 현재 어떤 쿼리를 실행하고 있는지는 SHOW PROCESSLIST 명령으로 확인할 수 있음 
- 활성 트랜잭션 조회
  - ```sql
    --// 트랜잭션이 5초 이상 활성 상태로 남아있는 프로세스만 조사하는 쿼리 
    SELECT trx_id,
    (SELECT CONCAT(user,'@',host)
    FROM information_schema.processlist
    WHERE id=trx_mysql_thread_id) AS source_info,
    trx_state,
    trx_started,
    now(),
    (unix_timestamp(now()) - unix_timestamp(trx_started)) AS lasting_sec,
    trx_requested_lock_id,
    trx_wait_started,
    trx_mysql_thread_id,
    trx_tables_in_use,
    trx_tables_locked
    FROM information_schema.innodb_trx
    WHERE (unix_timestamp(now()) - unix_timestamp(trx_started)) > 5 \G
    ```
  - 평상시보다 오랜 시간 트랜잭션이 활성 상태를 유지하고 있다면 information_schema.innodb_trx 테이블에서 모든 정보를 조회해서 살펴보면 이 트랜잭션이 얼마나 많은 레코드를 변경했고 얼마나 많은 레코드를 잠그고 있는지 확인할 수 있음
  - > SELECT * FROM information_schema.innodb_trx WHERE trx_id=2300 \G
  - 어떤 레코드를 잠그고 있는지는 performance_schema.data_locks 테이블을 참조하면 됨
  - > SELECT * FROM data_locks \G
  - 장시간에 걸쳐 트랜잭션이 쿼리를 실행 중인 상태에서 그 쿼리만 강제 종료시키면 커넥션이나 트랜젹션은 여전히 활성 상태로 남아있게 됨, 응용 프로그램에서 쿼리의 에러를 감지해서 트랜잭션을 롤백하게 돼 있다면 다음과 같이 쿼리만 종료하면 됨 
  - > KILL QUERY 14;
  - 응용 프로그램에서 쿼리 에러에 대한 핸들링이 확실하지 않다면 쿼리를 종료시키는 것보다 커넥션 자체를 강제 종료시키는 방법이 더 안정적일 수 있음
  - > KILL 14;
- 쿼리 성능 테스트
  - 쿼리의 성능에 영향을 미치는 요소
    - 어떤 종류의 버퍼나 캐시가 영향을 미치는지 살펴보고, 이런 영향을 최소화하는 방법도 알아봄
    - 운영체제의 캐시
      - MySQL 서버는 운영체제의 파일 시스템 관련 기능(시스템 콜)을 이용해 데이터 파일을 읽어옴
      - 일반적으로 대부분의 운영체제는 한 번 읽은 데이터는 운영체제가 관리하는 별도의 캐시 영역에 보관해 뒀다가 다시 해당 데이터가 요청되면 디스크를 읽지 않고 캐시의 내용을 바로 MySQL 서버로 반환함
    - MySQL 서버의 버퍼 풀(InnoDB 버퍼 풀과 MyISAM의 키 캐시)
      - MySQL 서버에서도 데이터 파일의 내용을 페이지(또는 블록) 단위로 캐시하는 기능을 제공함
      - InnoDB 스토로지 엔진이 관리하는 캐시를 버퍼 풀 
      - MyISAM 스토리지 엔진이 관리하는 캐시는 키 캐시 

# 확장 검색 
- 전문 검색
  - 전문 검색(Full-text Search) : MySQL 서버는 예전부터 용량이 큰 문서를 단어 수준으로 잘게 쪼개어 문서 검색을 하게 해주는 기능이 있음 
  - 전문 검색 인덱스의 생성과 검색
    - MySQL 서버에서는 2가지 알고리즘을 이용해 인덱싱할 토큰을 분리해냄
      - 형태소 분석(서구권 언어의 경우 어근 분석)
      - n-gram 파서
    - 형태소 분석: 먼저 문장의 공백과 같은 띄어쓰기 단위로 단어를 분리하고, 각 단어의 조사를 제거해서 명사 또는 어근을 찾아서 인덱싱하는 알고리즘 
    - MySQL 서버에서는 단순히 공백과 같은 띄어쓰기 기준으로 토큰을 분리해서 인덱싱함 
    - n-gram: 문장 자체에 대한 이해 없이 공백과 같은 띄어쓰기 단위로 단어를 분리하고, 그 단어를 단순히 주어진 길이(n-gram의 n은 1~10 사이의 숫자 값)로 쪼개서 인덱싱하는 알고리즘 
- 전문 검색 쿼리 모드
  - 불리언 검색(BOOLEAN MODE)
    - 자연어 검색은 단순히 검색어에 포함된 단어들이 존재하는 결과만 가져오는 반면, 불리언 검색은 쿼리에 사용되는 검색어의 존재 여부에 대해 논리적 연산이 가능함 
    - 불리언 검색에서는 + 표시를 가진 검색 단어는 전문 검색 인덱스 칼럼에 존재해야 하며 - 표시를 가진 검색 단어는 전문 검색 인덱스 칼럼에 포함돼 있지 않아야 함 
    - 불리언 검색에서는 쌍따옴표로 묶인 구는 마치 하나의 단어인 것처럼 취급됨 
    - 불리언 검색에서 불리언 연산자나 +나 -를 전혀 사용하지 않으면 검색어에 포함된 단어 중 아무거나 하나라도 있으면 일치하는 것으로 판단함 
  - 검색어 확장(QUERY EXPANSION)
    - 검색어 확장은 사용자가 쿼리에 사용한 검색어로 검색된 결과에서 공통으로 발견되는 단어들을 모아서 다시 한번 더 검색을 수행하는 방식 
- 지리 좌표계
  - 지리 좌표계 데이터 관리
    - MBR(Minimum Bounding Rectangle)을 이용한 ST_Within() 함수를 이용
    - ST_Within() 함수는 2개의 공간 데이터를 파라미터로 입력하는데, 첫 번째 파라미터로 주어진 공간 데이터가 두 번째 파라미터의 공간 데이터에 포함되는지를 체크하는 함수 
    - MySQL 서버는 여러 형태의 점과 선, 그리고 다각형들을 위한 데이터 타입을 지원함
      - POINT & MULTIPOINT
      - LINESTRING & MULTILINESTRING
      - POLYGON & MULTIPOLYGON
      - GEOMETRY & GEOMETRYCOLLECTION

# 파티션
- 파티션 기능은 테이블을 논리적으로 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리할 수 있게 해줌 
- 파티션 기능은 주로 대용량 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용함 
- 파티션을 사용하는 이유
  - 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리 보다 훨씬 크거나 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등이 파티션이 필요한 대표적인 예 
  - 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리 
    - 파티션하지 않고 하나의 큰 테이블로 사용하면 인덱스도 커지고 그만큼 물리적인 메모리 공간도 많이 필요해진다는 사실을 알 수 있음
    - 파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할수 있게 만들어줌 
  - 데이터의 물리적인 저장소를 분리
  - 이력 데이터의 효율적인 관리
    - 요즘은 거의 모든 애플리케이션이 로그라는 이력 데이터를 가지고 있는데, 이는 단기간의 대량으로 누적됨과 동시에 일정 기간이 지나면 쓸모가 없어짐. 로그 데이터는 결국 시간이 지나면 별도로 아카이빙하거나 백업한 후 삭제해버리는 것이 일반적, 다른 데이터에 비해 라이프 사이클이 상당히 짧은 것이 특징 
- 파티션 프루닝(Partition pruning) : 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 뜻함 
- 주의 사항
  - MySQL 서버의 파티션이 가지는 제약 사항 
    - 스토어드 루틴이나 UDF, 사용자 변수 등을 파티션 표현식에 사용할 수 없음
    - 파티션 표현식은 일반적으로 칼럼 그 자체 또는 MySQL 내장 함수를 사용할 수 있는데, 여기서 일부 함수들은 파티션 생성은 가능하지만 파티션 프루닝을 지원하지 않을 수도 있음 
    - 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야 함 
    - 파티션된 테이블의 인덱스는 모두 로컬 인덱스이며, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있음. 파티션 개별로 인덱스를 변경하거나 추가할 수 없음
    - 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 가질 수 있음 
    - 최대(서브 파티션까지 포함해서) 8192개의 파티션을 가질 수 있음 
    - 파티션 생성 이후 MySQL 서버의 sql_mode 시스템 변수 변경은 데이터 파티션의 일관성을 깨뜨릴 수 있음
    - 파티션 테이블에서는 외래키를 사용할 수 없음
    - 파티션 테이블은 전문 검색 인덱스 생성이나 전문 검색 쿼리를 사용할 수 없음 
    - 공간 데이터를 저장하는 칼럼 타입(POINT, GEOMETRY, ...)은 파티션 테이블에서 사용할 수 없음
    - 임시 테이블(Temporary table)은 파티션 기능 사용할 수 없음
  - 파티션 테이블을 생성할 때 가장 크게 영향을 미치는 제약 사항은 모든 유니크 인덱스에 파티션 키 칼럼이 포함돼야 한다는 것 
  - 파티션 사용 시 주의사항
    - 파티션의 목적이 작업 범위를 좁히는 것인데, 유니크 인덱스는 중복 레코드에 대한 체크 작업 때문에 범위가 좁혀지지 않는다는 점 
- MySQL 파티션 종류
  - 레인지 파티션
    - 파티션 키의 연속된 범위로 파티션을 정의하는 방법, 가장 일반적으로 사용되는 파티션 방법 중 하나 
    - MAXVALUE라는 키워드를 이용해 명시되지 않은 범위의 키 값이 담긴 레코드를 저장하는 파티션을 정의할 수 있음
    - 레인지 파티션의 용도
      - 날짜를 기반으로 데이터가 누적되고 연도나,월 또는 일 단위로 분석하고 삭제해야 할 때
      - 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
      - 파티션 키 위주로 검색이 자주 실행될 때 
    - 데이터베이스에서 파티션의 장점
      - 큰 테이블을 작은 크기의 파티션으로 분리
      - 필요한 파티션만 접근(쓰기와 읽기 모두) 
    - 저자가 경험했던 많은 응용 프로그램에서 사용했던 파티션은 대부분 이력을 저장하는 로그 테이블에 레인지 파티션을 적용한 경우
    - 레인지 파티션 테이블 생성
      - ```sql
        CREATE TABLE employee (
        id INT NOT NULL,
        first_name VARCHAR(30),
        last_name VARCHAR(30),
        hired DATE NOT NULL DEFAULT '1970-01-01'
        ...
        ) PARTITION BY RANGE( YEAR(hired) ) (
        PARTITION p0 VALUES LESS THAN (1991),
        PARTITION p1 VALUES LESS THAN (1996),
        PARTITION p2 VALUES LESS THAN (2001),
        PARTITION p3 VALUES LESS THAN MAXVALUE
        );
        ```
    - 레인지 파티션의 분리와 병합
      - 단순 파티션의 추가
      - ```sql
        ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
        REORGANIZE PARTITION p3 INTO(
        PARTITION p3 VALUES LESS THAN (2011),
        PARTITION p4 VALUES LESS THAN MAXVALUE
        );
        ```
      - 파티션 삭제
        - > ALTER TABLE employees DROP PARTITON p0;
        - 레인지 파티션을 사용하는 테이블에서 이렇게 파티션을 삭제할 때 항상 가장 오래된 파티션 순서로만 삭제할 수 있음, 레인지 파티션을 사용하는 테이블에서는 가장 마지막 파티션만 새로 추가할 수 있고, 가장 오래된 파티션만 삭제할 수 있음 
      - 기존 파티션의 분리
      - ```sql
        ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
        REORGANIZE PARTITION p3 INTO (
        PARTITION p3 VALUES LESS THAN (2011),
        PARTITION p4 VALUES LESS THAN MAXVALUE
        ); 
        ```
      - 파티션이 재구성 되는 동안은 테이블의 쓰기가 불가능해지므로 파티션 재구성 작업은 서비스 점검 시간대나 쿼리 처리가 많지 않은 시간대에 진행하는 것이 좋음 
  - 리스트 파티션
    - 레인지 파티션과 가장 큰 차이는 레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다는점 
    - 리스트 파티션에서는 레인지 파티션과 같이 MAXVALUE 파티션을 정의할 수 없음 
    - 리스트 파티션의 용도
      - 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
      - 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
      - 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때 
    - 리스트 파티션 주의사항
      - 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없음
      - 레인지 파티션과 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있음 
  - 해시 파티션
    - 해시 파티션은 MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결장하는 방법
    - MySQL에서 정의한 해시 함수는 복잡한 알고리즘이 아니라 파티션 표현식의 결과값을 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정하는 방식 
    - 해시 파티션의 파티션 키는 항상 정수 타입의 칼럼이거나 정수를 반환하는 표현식만 사용될 수 있음 
    - 해시 파티션의 용도
      - 다음과 같은 특성을 지닌 테이블에 적합함(ex 회원 테이블)
        - 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때 
        - 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때 
    - 해시 파티션 추가
      - 해시 파티션은 특정 파티션 키 값을 테이블의 파티션 개수로 MOD 연산한 결괏값에 의해 각 레코드가 저장될 파티션을 결정함 
      - 해시 파티션은 테이블에 존재하는 파티션의 개수에 의해 파티션 알고리즘이 변하는 것 
      - 새로운 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치돼야 함 
    - 해시 파티션 분할
      - 해시 파티션이나 키 파티션에서 특정 파티션을 두 개 이상의 파티션으로 분할하는 기능은 없으며, 테이블 전체적으로 파티션의 개수를 늘리는 것만 가능함 
    - 해시 파티션 주의사항
      - 특정 파티션만 삭제(DROP PARTITION)하는 것은 불가능함
      - 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아니라 기존 모든 데이터의 재배치 작업이 필요함
      - 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문에 해시 파티션이 용도에 적합한 해결책인지 확인이 필요함 
      - 일반적으로 사용자들에게 익숙한 파티션의 조작이나 특성은 대부분 리스트 파티션이나 레인지 파티션에만 해당하는 것들이 많음. 해시 파티션이나 키 파티션을 사용하거나 조작할 때는 주의가 필요함
  - 키 파티션
    - 키 파티션에서는 정수 타입이나 정숫값을 반환하는 표현식뿐만 아니라 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있음 
    - MySQL 서버는 선정된 파티션 키의 값을 MD5() 함수를 이용해 해시값을 계산하고, 그 값을 MOD 연산해서 데이터를 각 파티션에 분배함, 키 파티션과 해시 파티션의 유일한 차이점 
    - 키 파티션의 주의사항 및 특이사항
      - 키 파티션은 MySQL 서버가 내부적으로 MD5() 함수를 이용해 파티션하기 때문에 파티션 키가 반드시 정수 타입이 아니어도 됨. 해시 파티션으로 파티션이 어렵다면 키 파티션 적용을 고려해보자 
      - 프라이머리 키나 유니크 키를 구성하는 칼럼 중 일부만으로도 파티션할 수 있음 
      - 유니크 키를 파티션 키로 사용할 때 해당 유니크 키는 반드시 NOT NULL이어야 함 
      - 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 때문에 키 파티션이 더 효율적임 
  - 리니어 해시 파티션/리니어 키 파티션
    - 해시 파티션이나 키 파티션은 새로운 파티션을 추가하거나 파티션을 통합해서 개수를 줄일 때 대상 파티션만이 아니라 테이블의 전체 파티션에 저장된 레코드의 재분배 작업이 발생함 
    - 이런 단점을 최소화하기 위해 리니어(Linear) 해시 파티션/리니어 키 파티션 알고리즘이 고안된 것 
    - 리니어 해시 파티션/리니어 키 파티션은 각 레코드 분배를 위해 Power-of-two(2의 승수) 알고리즘을 이용하며, 이 알고리즘은 파티션의 추가나 통합 시 다른 파티션에 미치는 영향을 최소화해줌 
    - 테이블을 10개로 파티션해서 10개의 파티션 중에서 1~3개 정도만 파티션만 읽고 쓴다면 파티션 기능이 성능 향상에 도움이 될 것, 10개로 파티션하고 파티션된 10개를 아주 균등하게 사용한다면 이는 성능 향상보다는 오히려 오버헤드만 심해지는 결과를 가져올 수 있음
    - 파티션을 사용할 때는 반드시 파티션 프루닝이 얼마나 도움이 될지를 먼저 예측해보고 응용 프로그램에 적용하자. 레인지 파티션 이외의 파티션을 적용할 때는 파티션 프루닝을 더 많이 고민해 보고 적용할 것을 권장함 

# 스토어드 프로그램
- 스토어드 프로그램은 스토어드 루틴이라고도 하는데, 스토어드 프로시저와 스토어드 함수, 트리거와 이벤트 등을 모두 아우르는 명칭 
- 스토어드 프로그램의 장점
  - 데이터베이스의 보안 향상
  - 기능의 추상화
  - 네트워크 소요 시간 절감
  - 절차적 기능 구현
  - 개발 업무의 구분 
- 스토어드 프로그램의 단점
  - 낮은 처리 성능
  - 애플리케이션 코드의 조각화
- 스토어드 프로그램의 문법
  - 정의부 : 스토어드 프로그램의 헤더 부분, 주로 스토어드 프로그램의 이름과 입출력 값을 명시하는 부분
  - 본문 부분 : 스토어드 프로그램의 바디(Body)라고도 하며, 스토어드 프로그램이 호출됐을 때 실행하는 내용을 작성하는 부분 
  - 스토어드 프로시저
    - 서로 데이터를 주고 받아야 하는 여러 쿼리를 하나의 그룹으로 묶어서 독립적으로 실행하기 위해 사용하는 것 
    - 배치 프로그램에서 첫 번째 쿼리의 결과를 이용해 두 번째 쿼리를 실행해야 할 때가 대표적인 예 
  - 스토어드 함수
    - 스토어드 함수는 하나의 SQL 문장으로 작성이 불가능한 기능을 하나의 SQL 문장으로 구현해야 할 때 사용함   
- 트리거
  - 트리거는 테이블의 레코드가 저장되거나 변경될 때 미리 정의해둔 작업을 자동으로 실행해주는 스토어드 프로그램, 데이터의 변화가 생길 때 다른 작업을 기동해주는 방아쇠인 것 
  - 칼럼의 유효성 체크나 다른 테이블로의 복사나 백업, 계산된 결과를 다른 테이블에 함께 업데이트 하는 등의 작업을 위해 트리거를 자주 사용함 
  - 트리거 생성
    - ```sql
      CREATE TRIGGER on_delete BEFORE DELETE ON employees
      FOR EACH ROW
      BEGIN
      DELETE FROM salaries WHERE emp_no=OLD.emp_no;
      END;;
      ```
- 이벤트
  - 주어진 특정한 시간에 스토어드 프로그램을 생성할 수 있는 스케줄러 기능 뜻함 
  - 이벤트 생성
    - 일회성 이벤트
      - 단 한 번 실행되는 일회성 이벤트를 등록하려면 ON SCHEDULE AT절을 명시하면 됨 
      - ```sql
        CREATE EVENT onetime_job
        ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
        DO
        INSERT INTO daily_rank_log VALUES (NOW(), 'Done');
        ```
    - 반복성 이벤트
      - ```sql
        CREATE EVENT daily_ranking
        ON SCHEDULE EVERY 1 DAY STARTS '2020-09-07 01:00:00' ENDS '2021-01-01 00:00:00'
        DO
        INSERT INTO daily_rank_log VALUES (NOW(), 'DONE');
        ```
- 핸들러와 컨디션을 이용한 에러 핸들링
  - SQLSTATE와 에러 번호(Error No)
    - ERROR ERROR-NO (SQL-STATE) : ERROR-MESSAGE
      - ERROR-NO 
        - 4자리 (현재까지는) 숫자 값으로 구성된 에러코드, MySQL에서만 유효한 에러 식별 번호
        - 1146이라는 에러 코드 값은 MySQL에서는 테이블이 존재하지 않는다라는 것을 의미하는데 다른 DBMS와 호환되는 에러 코드는 아님
      - SQL-STATE
        - 다섯 글자와 알파벳과 숫자(Alpha-Numeric)로 구성되며 에러뿐만 아니라 여러 가지 상태를 의미하는 코드 
        - DBMS 종류가 다르더라도 ANSI SQL 표준을 준수하는 DBMS(ODBC, JDBC 포함)에서는 모두 똑같은 값과 의미를 가짐. 이 값은 표준값이라서 DBMS 벤더에 의존적이지 않음
  - 다른 에러도 중복된 에러 번호를 지닌 것이 많기 때문에 에러 번호보다는 SQLSTATE를 핸들러에 사용하는 것이 좋음
  - 컨디션
    - 각 에러 번호나 SQLSTATE가 어떤 의미인지 예측할 수 있는 이름을 만들어 두면 훨씬 더 쉽게 코드를 이해할 수 잇을것 
    - > DECLARE condition_name CONDITION FOR condition_value
  - 시그널을 이용한 예외 발생
    - MySQL의 스토어드 프로그램에서 사용자가 직접 예외나 에러를 발생시키려면 시그널(SIGNAL) 명령을 사용해야함 
  - 커서
    - 스토어드 프로그램의 커서(CURSOR)는 JDBC 프로그램에서 자주 사용하는 결과 셋(ResultSet)으로, PHP 프로그램에서는 mysql_query() 함수로 반환되는 결과와 똑같은 것 
      - 스토어드 프로그램의 커서는 전 방향(전진) 읽기만 가능함 
      - 스토어드 프로그램에서는 커서의 칼럼을 바로 업데이트하는 것(Updatable ResultSet)이 불가능함 
      - 센서티브(Sensitive) 커서는 일치하는 레코드에 대한 정보를 실제 레코드의 포인터만으로 유지하는 형태 
      - 인센서티브(Insensitive) 커서는 일치하는 레코드를 별도의 임시 테이블로 복사해서 가지고 있는 형태 
    - 센서티브 커서와 인센서티브 커서를 혼용해서 사용하는 방식을 어센서티브(Asensitive), MySQL의 스토어드 프로그램에서 정의되는 커서는 어센서티브에 속함 

# 데이터 타입
- 칼럼의 데이터 타입과 길이를 선정할 때 가장 주의할 사항
  - 저장되는 값의 성격에 맞는 최적의 타입을 선정
  - 가변 길이 칼럼은 최적의 길이를 지정
  - 조인 조건으로 사용되는 칼럼은 똑같은 데이터 타입으로 선정 
- 문자열
  - 저장공간
    - CHAR와 VARCHAR의 공통점은 문자열을 저장할 수 있는 데이터 타입, 가장 큰 차이는 고정 길이냐 가변 길이
      - 고정 길이는 실제 입력되는 칼럼값의 길이에 따라 사용하는 저장 공간의 크기가 변하지 않음, CHAR 타입은 이미 저장 공간의 크기가 고정적 
      - 가변 길이는 최대로 저장할 수 있는 값의 길이는 제한돼 있지만, 그 이하 크기의 값이 지정되면 그만큼 저장 공간이 줄어듬, VARCHAR 타입은 저장된 값의 유효 크기가 얼마인지를 별도로 저장해 둬야 하므로 1~2바이트의 저장 공간이 추가로 더 필요함 
    - 주민등록번호처럼 항상 값의 길이가 고정적일 때는 당연히 CHAR 타입을 사용해야함, 값이 2~3 바이트씩 차이가 나더라도 자주 변경될 수 있는 부서 번호나 게시물의 상태 값 등은 CHAR 타입을 사용하는 것이 좋음 
  - 콜레이션(Collation)
    - 문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙을 의미함 
    - 비교나 정렬 작업에서 영문 대소문자를 같은 것으로 처리할지, 아니면 더 크거나 작은 것으로 판단할지에 대한 규칙을 정의하는 것 
- 숫자 
  - 참값은 소숫점 이하 값의 유무와 관계없이 정확히 그 값을 그대로 유지하는 것을 의미함. 참값을 관리하는 데이터 타입으로 INTEGER를 포함해 INT로 끝나는 타입과 DECIMAL이 있음 
  - 근삿값은 흔히 부동 소수점이라고 불리는 값을 의미함, 처음 칼럼에 저장한 값과 조회된 값이 정확하게 일치하지 않고 최대한 비슷한 값으로 관리하는 것으로 의미함. 근사값을 관리하는 타입으로는 FLOAT와 DOUBLE이 있음 
  - 이진 표기법이란 흔히 프로그래밍 언어에서 사용하는 정수나 실수 타입을 의미함. 이진 표기법은 한 바이트로 한자리 또는 두 자리 숫자만 저장하는 것이 아니라 256까지의 숫자(양수만 저장한다고 가정할 경우)를 표현할 수 있기 때문에 숫자 값을 적은 메모리나 디스크 공간에 저장할 수 있음. MySQL의 INTEGER나 BIGINT 등 대부분 숫자 타입은 모두 이진 표기법을 사용함 
  - 십진 표기법(DECIMAL)은 숫자 값의 각 자리값을 표현하기 위해 4비트나 한 바이트를 사용해서 표기하는 방법, 우리가 흔히 이야기하는 십진수가 아니라 디스크나 메모리에 십진 표기법으로 저장된다는 것을 의미함. MySQL의 십진 표기법을 사용하는 타입은 DECIMAL뿐이며, DECIMAL 타입은 금액(돈)처럼 정확하게 소수점까지 관리돼야 하는 값을 저장할 때 사용함. DECIMAL 타입은 65자리 숫자까지 표현할 수 있으므로 BIGINT로도 저장할 수 없는 값을 저장할 때 
  - 부동 소수점
    - 부동(Floating point)은 소수점의 위치가 고정적이지 않다는 의미인데, 숫자 값의 길이에 따라 유효 범위의 소수점 자릿수가 바뀜 
  - DECIMAL
    - 소수점의 위치가 가변적이지 않은 고정 소수점 타입을 위해 DECIMAL 타입을 제공함 
    - MySQL에서 소수점 이하의 값까지 정확하게 관리하려면 DECIMAL 타입을 이용해야 함, DECIMAL보다는 BIGINT 타입이 더 빠르다는 사실을 알 수 있음 
    - 소수가 아닌 정숫값을 관리하기 위해 DECIMAL 타입을 사용하는 것은 성능상이나 공간 사용면에서 좋지 않음 
  - 자동 증가(AUTO_INCREMENT)옵션 사용
    - 테이블의 프라이머리 키를 구성하는 칼럼의 크기가 너무 크거나 프라이머리 키로 사용할 만한 칼럼이 없을 때는 숫자 타입의 칼럼에 자동 증가 옵션을 사용해 인조 키(Artificail Key)를 생성할 수 있음 
- ENUM과 SET
  - ENUM
    - ENUM 타입은 테이블의 구조(메타 데이터)에 나열된 목록 중 하나의 값을 가질 수 있음, ENUM 타입의 가장 큰 용도는 코드화된 값을 관리하는 것 
    - ENUM 타입은 테이블 구조에 정의된 코드 값만 사용할 수 있게 강제한다는 장점도 있음, 더 큰 장점은 데이터베이스 서버의 디스크 저장 공간의 크기를 줄여준다는 것 
    - 디스크의 데이터는 InnoDB 버퍼 풀로 적재돼야 쿼리에서 비로소 사용할 수 있음. 디스크의 데이터가 크다는 것은 메모리도 그만큼 만ㅇ히 필요해진다는 이야기 
    - 메모리 사용량 절감 효과를 빼더라도 디스크의 사용량이 적다면 백업이나 복구 시간을 줄일 수 있다는 장점도 큼. 당장 장애가 발생했는데, 백업 파일을 복사하는데 3~4시간이 걸린다면 이 시간 동안은 서비스가 불가능해지는 것. 디스크의 데이터 파일 크기가 작다면 스키마를 변경하는 시간과 인덱스를 생성하는 시간도 줄어듬 
  - SET
    - ENUM의 가장 큰 차이는 SET은 하나의 칼럼에 1개 이상의 값을 저장할 수 있다는 점 
    - MySQL 서버는 내부적으로 BIT-OR 연산을 거쳐 1개 이상의 선택된 값을 저장함. SET 타입의 칼럼은 여러 개의 값을 저장할 수는 있지만 실제 여러 개의 값을 저장하는 공간을 가지는 것이 아님 
- TEXT와 BLOB
  - MySQL에서 대량의 데이터를 저장하려면 TEXT나 BLOB 타입을 사용해야 함. 두 타입은 많은 부분에서 거의 똑같은 설정이나 방식으로 작동함 
  - TEXT 타입과 BLOB 타입의 유일한 차이점은 TEXT 타입은 문자열을 저장하는 대용량 칼럼이라서 문자 집합이나 콜레이션을 가진다는 것이고 BLOB 타입은 이진 데이터 타입이라서 별도의 문자 집합이나 콜레이션을 가지지 않는다는 것 
    - 칼럼 하나에 저장되는 문자열이나 이진 값의 길이가 예측할 수 없이 클 때 TEXT나 BLOB을 사용함
    - 레코드의 전체 크기가 64KB를 넘어서서 더 큰 칼럼을 추가할 수 없다면 일부 칼럼을 TEXT나 BLOB타입으로 전환해야 할 수도 있음 
- 공간 데이터 타입
  - MySQL에서 제공하는 공간 정보 저장용 데이터 타입은 POINT, LINESTRING, POLYGON, GEOMETRY, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION
  - POINT, LINESTRING, POLYGON 타입은 하나의 단위 정보만 가질 수 있음, POINT 객체는 하나의 점 정보만 저장할 수 있으며, LINESTRING 타입은 하나의 라인, POLYGON 타입은 하나의 다각형만 저장할 수 있음
  - 저장하고자 하는 공간 데이터가 점과 선, 다각형 등으로 다양한 타입의 데이터를 저장해야 한다면 칼럼의 데이터 타입을 GEOMETRY 타입으로 생성하면 됨 
  - 공간 데이터 조회
    - MySQL 서버가 관리하는 공간 데이터를 조회하는 방법
      - 이진 데이터 조회(WKB 포맷 또는 MySQL 이진 포맷)
      - 텍스트 데이터 조회(WKT 포맷)
      - 공간 데이터의 속성 함수를 이요한 조회
- JSON 타입
  - 저장 방식
    - MySQL 서버는 내부적으로 JSON 타입의 값을 BLOB 타입에 저장함, JSON 칼럼에 저장되는 값은 사용자가 입력한 값 그대로 저장하는 것이 아니라 바이너리 포맷이 BSON 타입으로 변환해서 저장함 
- 가상 칼럼(파생 칼럼)
  - 다른 DBMS에서는 가상 칼럼(Virtual Column), MySQL 서버에서는 Generated Column 
  - MySQL 서버의 가상 칼럼은 크게 가상 칼럼(Virtual Column)과 스토어드 칼럼(Stored Column)으로 구분할 수 있음 
  - ```sql
    --// 가상 칼럼(Virtual Column) 사용 예제
    CREATE TABLE to_virtual_column(
      id INT NOT NULL AUTO_INCREMENT,
      price DECIMAL(10,2) NOT NULL DEFAULT '0.00',
      quantity INT NOT NULL DEFAULT 1,
      total_price DECIMAL(10,2) AS (quantity * price) VIRTUAL,
      PRIMARY KEY (id)
    );
    
    --// 스토어드 칼럼(Stored Column) 사용 예제
    CREATE TABLE to_stored_column(
      id INT NOT NULL AUTO_INCREMENT,
      price DECIMAL(10,2) NOT NULL DEFAULT '0.00',
      quantity INT NOT NULL DEFAULT 1,
      total_price DECIMAL(10,2) AS (quantity * price) STORED,
      PRIMARY KEY (id)
    );
    ```
  - VIRTUAL이나 STORED 키워드가 정의되지 않으면 MySQL 서버는 기본 모드인 VIRTUAL로 칼럼을 생성함. 가상 칼럼은 다른 칼럼의 값을 참조해서 계산된 값을 관리하기 때문에 항상 AS 절 뒤에는 계산식이나 데이터 가공을 위한 표현식을 정의함 
  - 가상 칼럼과 스토어드 칼럼 모두 다른 칼럼의 값을 참조해서 새로운 값을 만들어 관리한다는 공통점이 있음, 기존 칼럼의 값을 계산해서 관리하는 파생된 칼럼인 것
  - 차이점
    - 가상 칼럼
      - 칼럼의 값이 디스크에 저장되지 않음
      - 칼럼의 구조 변경은 테이블 리빌드를 필요로 하지 않음
      - 칼럼의 값은 레코드가 읽히기 전 또는 BEFORE 트리거 실행 직후에 계산되어 만들어짐 
    - 스토어드 칼럼
      - 칼럼의 값이 물리적으로 디스크에 저장됨
      - 칼럼의 구조 변경은 다른 일반 테이블과 같이 필요 시 테이블 리빌드 방식으로 처리됨
      - INSERT와 UPDATE 시점에서만 칼럼의 값이 계산됨 
  - 가상 칼럼과 스토어드 칼럼의 가장 큰 차이는 계산된 칼럼의 값이 디스크에 실제 저장되는지 여부
  - 가상 칼럼은 데이터를 조회하는 시점에 매번 계산되기 때문에 가상 칼럼의 값을 계산하는 과정이 복잡하고 시간이 오래 걸린다면 스토어드 칼럼으로 변경하는 것이 성능향상에 도움읻 됨
  - 계산 과정이 빠른 반면 상대적으로 결과가 많은 저장 공간을 차지한다면 스토어드 칼럼보다는 가상 칼럼을 선택하는 것이 저장 공간의 절약과 메모리의 효율을 높일 수 있을 것 
  - CPU 사용량을 조금 높여서 디스크 부하를 낮출 것이냐, 디스크 사용량을 조금 높여서 CPU 사용량을 낮출 것이냐

# 복제
- 데이터베이스를 사용하고 운영할 때 가장 중요한 두 가지 요소는 확장성(Scalability)과 가용성(Avaliability) 
- 서비스에서 발생하는 대용량 트랙픽을 안정적으로 처리하기 위해서는 데이터베이스 서버의 확장이 필수적, 사용자가 언제든지 안정적인 서비스를 이용할 수 있게 하려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 반드시 뒷받침돼야함 
- 개요
  - 복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것
  - 소스(Source) 서버 : 원본 데이터를 가진 서버
  - 레플리카(Replica) 서버 : 복제된 데이터를 가지는 서버 
  - 소스 서버에서 데이터 및 스키마에 대한 변경이 최초로 발생하며, 레플리카 서버에서는 이러한 변경 내역을 소스 서버로부터 전달받아 자신이 가지고 있는 데이터에 반영함으로써 소스 서버에 저장된 데이터와 동기화시킴 
  - 복제를 사용해서 얻을 수 있는 대표적인 이점 
    - 스케일 아웃(Scale-out)
      - 스케일 업 : 서비스를 운영하다 보면 사용자가 늘어나고, 이에 따라 DB 서버로 유입되는 트래픽도 자연히 증가해 DB서버의 부하가 높아짐, 서버의 사양을 업그레이드 하는것을 스케일업이라 함, 애플리케이션 단의 큰 변화 없이 늘어난 트래픽을 처리할 수 있다는 장점이 있지만 일시적이라는 단점도 있음. 
      - 스케일 아웃 : 서버의 사양을 업그레이드한다 하더라도 한 대에서 처리할 수 있는 양에는 한계가 있기 때문, 만약 동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 애플리케이션으로부터 실행되는 쿼리들을 분산시킬 수 있을 것
      - 스케일 아웃은 스케일 업 방식보다 갑자기 늘어나는 트래픽을 대응하는 데 훨씬 더 유연한 구조, 복제를 사용해 DB 서버를 스케일 아웃할 수 있으며, 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있음 
    - 데이터 백업
      - DB 서버에 저장된 데이터들은 주기적으로 백업하는 것이 필수적 
      - 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행함. 구축된 백업용 레플리카 서버는 소스 서버가 문제 생겼을 때를 대비한 대체 서버의 역할을 하기도 함 
    - 데이터 분석
      - DB 서버에서는 기본적으로 서비스에 사용되는 쿼리들이 실행되지만 차세대 비즈니스 모델을 발굴하기 위해서나 서비스를 좀 더 발전시킬 수 있는 인사이트를 얻기 위해 분석용 쿼리들을 실행하기도 함
      - 분석용 쿼리는 대량의 데이터를 조회하는 경우가 많고, 또 집계 연산을 하는 등 쿼리 자체가 굉장히 복잡하고 무거운 경우가 대부분이라서 쿼리를 실행할 때 서버의 리소스를 많이 사용하게 됨
      - 서비스에서 직접적으로 사용되는 다른 쿼리들이 영향을 받을 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋음
    - 데이터의 지리적 분산 
      - DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어남
      - 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못한다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있음 
- 복제 아키텍처
  - 바이너리 로그(Binary Log) : MySQL 서버에서 발생하는 모든 변경 사항은 별도의 로그 파일에 순서대로 기록됨 
  - 바이너리 로그에는 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장됨 
  - 이벤트(Event) : 바이너리 로그에 기록된 각 변경 정보들 
  - MySQL의 복제는 이 바이너리 로그를 기반으로 구현됐는데, 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤 자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버 간에 데이터 동기화가 이뤄짐 
  - 릴레이 로그(Relay Log) : 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일
  - MySQL의 복제는 세 개의 스레드에 의해 작동, 하나는 소스 서버에 존재하며 나머지 두 개의 스레드는 레플리카 서버에 존재함 
    - 바이너리 로그 덤프 스레드(Binary Log Dump Thread) 
      - 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 바이너리 로그 정보를 요청함. 소스 서버에서는 레플리카 서버가 연결될 때 내부적으로 바이너리 로그 덤프 스레드를 생성해서 바이너리 로그의 내용을 레플리카 서버로 전송함 
      - 바이너리 로그 덤프 스레드는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제함, SHOW PROCESSLIST 명령을 통해 확인
    - 레플리케이션 I/O 스레드(Replication I/O Thread) 
      - 복제가 시작(START REPLICA 또는 START SLAVE 명령)되면 레플리카 서버는 I/O 스레드를 생성하고 복제가 멈추면(STOP REPLICA 또는 STOP SLAVE 명령) I/O 스레드는 종료됨 
      - I/O 스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일(릴레이 로그)로 저장하는 역할을 담당함. 소스 서버의 바이너리 로그를 읽어서 파일로 쓴느 역할만 하기 때문에 I/O 스레드라고 명명된것. SHOW REPLICA STATUS(SHOW SLAVE STATUS)명령의 결과에서 Replica_IO_Running(Slave_IO_running) 칼럼에 표신된 값을 통해 확인할 수 있음
    - 레플리케이션 SQL 스레드(Replication SQL Thread) 
      - 레플리케이션 I/O 스레드가 소스 서버로부터 가져온 바이너리 로그 이벤트들을 로컬 파일로 기록하는 역할
      - 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일 이벤트들을 읽고 실행함 
      - SQL 스레드도 I/O 스레드와 마찬가지로 SHOW REPLICA STATUS(또는 SHOW SLAVE STATUS) 명령을 통해 스레드 상태를 확인할 수 있으며, Replica_SQL_Running(Slave_SQL_running) 칼럼에 SQL 스레드의 현재 상태가 표시됨 
  - 레플리카 서버는 릴레이 로그를 비롯해 총 세 가지 유형의 복제 관련 데이터를 생성하고 관리함
    - 릴레이 로그(Relay Log)
      - 레플리케이션 I/O 스레드에 의해 작성되는 파일로, 소스 서버의 바이너리 로그에서 읽어온 이벤트(트랜잭션) 정보가 저장됨
      - 릴레이 로그는 바이너리 로그와 마찬가지로 현재 존재하는 릴레이 로그 파일들의 목록이 담김 인덱스 파일과 실제 이벤트 정보가 저장돼 있는 로그 파일들로 구성됨. 릴레이 로그에 저장된 트랜잭션 이벤트들은 레플리이션 SQL 스레드에 의해 레플리카 서버에 적용됨
    - 커넥션 메타데이터(Connection Metadata)
      - 커넥션 메타데이터에는 레플리케이션 I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과 파일 내 위치 값 등이 담겨있으며, 이러한 정보는 기본적으로 mysql.slave_master_info 테이블에 저장됨
    - 어플라이어 메타데이터(Applier Metadata)
      - 레플리케이션 SQL 스레드에서 릴레이 로그에 저장된 소스 서버의 이벤트들을 레플리카 서버에 적용(Replay)하는 컴포넌트를 어플라이어(Applier)라고 함
      - 어프라이어 메타데이터는 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 릴레이 로그 파일명과 파일 내 위치 정보 등을 담고 있으며, 레플리케이션 SQL 스레드는 이 정보들을 바탕으로 레플리카 서버에 나머지 이벤트들을 적용함
- 복제 타입
  - MySQL 복제는 소스 서버의 바이너리 로그에 기록된 변경(바이너리 로그 이벤트)들을 식벽하는 방식에 따라 로그 파일 위치 기반 복제(Binary Log File Position Based Replication)와 글로벌 트랜잭션 ID 기반 복제(Global Transaction Identifiers Based Replication)
    - 바이너리 로그 파일 위치 기반 복제 
      - 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치(Offset 또는 Position)로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태 
      - 이벤트 하나하나를 소스 서버의 바이너리 로그 파일명과 파일 내에서 취치 값(FIle Offset)의 조합으로 식별함 
      - 설정 준비
        - server_id 값도 기보적으로 1로 설정되는데, MySQL 서버마다 고유한 값을 가져야 하므로 기본값이 아닌 다른 값으로 설정하는 것이 좋음 
        - 바이너리 로그 동기화 방식이나 바이너리 로그를 캐시하기 위한 메모리 크기, 바이너리 로그 파일 크기, 보관 주기 등도 지정할 수 있음 
      - 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기 
        - 복제로 구성돼 있는 MySQL 서버들을 운영하다 보면 종종 레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제가 멈추는 현상 발생. MySQL 서버의 비정상 종료와 같이 실제로 정말 예기치 못한 문제가 있어 발생할 수도 있지만 대부분은 사용자의 실수로 인해 발생하는 경우가 많음 
        - 복제를 중단한 후 sql_slave_skip_counter 변수의 값을 1로 지정해 레플리케이션 SQL 스레드를 재시작하면 레플리카 서버는 에러가 발생한 INSERT 쿼리를 건너뛰고 정상적으로 복제를 재개함 
    - 글로벌 트랜잭션 아이디(GTID) 기반 복제
      - 소스 서버에서만 유효한 고유 식별 값이 아닌 복제에 참여한 전체 MySQL 서버들에서 고유하도록 각 이벤트에 부여된 식별 값을 글로벌 트랜재겻ㄴ 아이디(Global Transaction Identifier), 이를 기반으로 복제가 진행되는 형태를 GTID 기반 복제라 함 
      - GTID = [source_id]:[transaction_id]
        - 소스 아이디는 트랜잭션이 발생된 소스 서버를 식별하기 위한 값으로, MySQL 서버의 server_uuid 시스템 변수 값을 사용함. 트랜잭션 아이디는 서버에서 커밋된 트랜잭션 순서대로 부여되는 값으로 1부터 1씩 단조 증가하는 형태로 발급됨 
        - GTID 셋(GTID Sets) : 하나 이상의 GTID 값으로 구성돼 있는 것 
      - 데이터 복사
        - gtid_executed : MySQL 서버에서 실행되어 바이너리 로그 파일에 기록된 모든 트랜잭션들의 GTID 셋을 나타냄
        - gtid_purged : 현재 MySQL 서버의 바이너리 로그 파일에 존재하지 않는 모든 트랜잭션들의 GTID 셋을 나타냄 
- 복제 데이터 포맷
  - MySQL에서는 실행된 SQL문을 바이너리 로그에 기록하는 Statement 방식과 변경된 데이터 자체를 기록하는 Row 방식
  - Statement 기반 바이너리 로그 포맷
    - 변경 이벤트에 대해 이벤트를 발생시킨 SQL문을 바이너리 로그에 기록하는 방식 
    - Statement 포맷을 사용하면 손쉽게 SQL문들을 확인할 수 있으므로 감사에 더 용이함 
    - 대표적인 단점은 비확정적(Non-Deterministic)으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달라질 수 있다는 점, 다른 단점은 Row 포맷으로 복제될 때보다 데이터에 락을 더 많이 건다는점, INSERT INTO ... SELECT 구문이 대표적인 경우, 그 외에 데이터 검색 조건으로 주어진 칼럼에 대한 적절한 인덱스가 테이블에 조재하지 않아 풀 테이블 스캔을 유발하는 UPDATE 쿼리가 실행된 경우 등 
    - Statement 포맷 기반 복제에서 소스 서버와 레플리카 서버 간의 데이터 일관성을 해칠 수 있는 비확정적 쿼리 유형의 몇 가지 예
      - DELETE/UPDATE 쿼리에서 OREDER BY 절 없이 LIMIT 사용
      - SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAIT이나 SKIP LOCKED 옵션을 사용
      - LOAD_FILE(), UUID(), UUID_SHORD(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같은 함수를 사용하는 쿼리
      - 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수(User-defined Function)나 스토어드 프로시저(Stored Procedure)를 사용하는 쿼리 
    - Statement 기반 바이너리 로그 포맷은 사용할 때 한 가지 제한사항이 있는데, 바로 트랜잭션 격리 수준이 반드시 REPEATABLE-READ 이상이어야 한다는 점 
  - Row 기반 바이너리 로그 포맷
    - MySQL 서버에서 데이터 변경이 발생했을 때 변경된 값 자체가 바이너리 로그에 기록되는 방식
    - 어떤 형태의 쿼리가 실행됐든 간에 복제 시 소스 서버와 레플리카 서버의 데이터를 일관되게 하는 가장 안전한 방식
    - Row 포맷에서는 소스 서버에서 실행된 쿼리가 UUID(), USER() 등과 같은 비확정적 함수를 사용했다 하더라도 레플리카 서버에서 똑같이 이 함수가 다시 실행되는 것이 아니라 함수의 결과값을 전달받아 처리되므로 이 같은 경우에 있어서도 안전하게 복제가 가능함 
    - 변경된 데이터가 그대로 바이너리 로그에 기록된다는 것은 가장 큰 장점이자 단점, MySQL 서버에서 실행된 쿼리가 굉장히 많은 데이터를 변경하는 경우에는 변경된 데이터가 전부 기록되므로 바이너리 로그 파일 크기가 단시간에 매우 커질 수 있음. 변경된 데이터 수가 적더라도 BLOB 형태의 큰 값이 새로 저장되거나 변경되는 경우에는 마찬가지로 파일 크기가 많이 커질 수 있음을 유의해야함 
  - Mixed 포맷 
    - MySQL 서버는 MIXED 포맷으로 설정되면 기본적으로는 Statement 포맷을 사용하며, 실행된 쿼리와 스토리지 엔진의 종류에 따라 필요 시 자동으로 Row 포맷으로 전환해서 로그에 기록함 
  - Row 포맷의 용량 최적화 
    - 바이너리 로그 Row 이미지
      - Row 포맷을 사용하는 경우 바이너리 로그에 쿼리로 인해 변경된 데이터들이 전부 저장되기 때문에 Statement 포맷보다 더 많은 저장 공간과 네트워크 트래픽을 유발할 가능성이 있음 
      - PKE(Primary Key Equivalent)는 테이블의 프라이머리 키 또는 프라이머리 키 역항릉 하는 칼럼 조합 
    - 바이너리 로그 트랜잭션 압축
      - MySQL 서버의 바이너리 로그는 안정적인 복제를 위해 일정 기간 동안 보관되도록 설정하며, 또한 시점 보구(Point-In-Time Recovery)를 고려하는 경우에는 원격 스토리지 서버에 바이너리 로그들을 백업해두기도 함 
      - MySQL 서버에서 생성되는 바이너리 로그 파일의 양이 많은 경우에는 디스크 저장 공간은 물론 네트워크 대역폭을 많이 소비하게 됨 
      - 사용자는 디스크 저장 공간과 네트워크 대역폭 사용량 절약을 위해 바이너리 로그 로그 보관 주기를 더 짧게 설정하고, 원격 스토리지 서버에 저장할 때는 별도의 툴을 사용해 바이너리 로그 파일들을 압축한 뒤 전송할 수 있음 
      - Row 포맷으로 기록되는 트랜잭션에 대해 트랜잭션에서 변경한 데이터를 압축해서 바이너리 로그에 기록할 수 있게 하는 기능이 도입됨 
      - 사용자는 기존과 동일한 바이너리 로그 보관 주기를 유지하면서 이전보다 디스크 공간을 절약할 수 있게 됐으며, 복제로 인해 소비되는 네트워크 대역폭 사용량도 줄일 수 있게 됐음 
      - 다음과 같은 이벤트 타입들은 압축 기능이 활성화돼 있다 하더라도 항상 바이너리 로그에 압축되지 않은 상태로 기록됨
        - GTID 설정 관련 이벤트
        - 그룹 복제에서 발생하는 View Change 이벤트 또는 소스 서버에서 레플리카 서버에 살아있음을 알리는 Heartbeat 이벤트와 같은 제어 이벤트(Heartbeat 이벤트는 바이너리 로그에 실제로 기록되지 않음)
        - 복제 실패 및 소스 서버와 레플리카 서버 간 데이터 불일치를 발생시킬 수 있는 Incident 타입의 이벤트
        - 트랜잭션을 지원하지 않는 스토리지 엔진에 대한 이벤트 및 그러한 이벤트를 포함하고 있는 트랜잭션 이벤트
        - Statement 포맷으로 기록되는 트랜잭션 이벤트(바이너리 로그 포맷이 Mixed로 설정돼 있는 경우에 해당한다고 볼 수 있음. 바이너리 로그 트랜잭션 압축 기능은 Row 포맷으로 기록되는 이벤트들에만 적용됨) 
      - 압축된 트랜잭션 데이터는 트랜잭션 개별 이벤트들의 내용이 어떤 것인지 실제로 확인이 필요할 때 압축이 해제되는데, 다음과 같은 경우가 해당됨
        - 레플리카 서버에서 레플리케이션 SQL 스레드에 의해 복제된 트랜잭션이 적용될 때 
        - mysqlbinlog를 사용해 트랜잭션을 재실행할 때
        - SHOW BINLOG EVENTS 혹은 SHOW RELAYLOG EVENTS 구문이 사용될 때 
- 복제 동기화 방식
  - 비동기 복제(Asynchronous replication)
    - 비동기 방식이란 소스 서버가 자신과 복제 연결된 레플리카 서버에서 변경 이벤트가 정상적으로 전달되어 적용됐는지를 확인하지 않는 방식
    - 비동기 복제 방식에서 소스 서버는 레플리카 서버로 변경 이벤트가 잘 전달됐는지, 실제로 적용됐는지 알지 못하며 이에 대한 어떠한 보장도 하지 않음
    - 소스 서버에 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있음, 누락된 트랜잭션이 존재하게 되는 것 
    - 만약 소스 서버 장애로 인해 레플리카 서버를 새로운 소스 서버로 승격시키는 경우 사용자는 이 레플리카 서버가 소스 서버로부터 전달받지 못한 트랜잭션이 있는지 직접 확인하고 그런 것들이 있다면 필요 시 레플리카 서버에 수동으로 다시 적용해야 함 
    - 비동기 복제는 소스 서버가 레플리카 서버의 동기화 여부를 보장하지 않는다는 것이 가장 큰 단점이지만 소스 서버가 각 트랜잭션에 대해 레플리카 서버로 전송되는 부분을 고려하지 않기 때문에 트랜잭션 처리에 있어서도 좀 더 빠른 성능을 보이고, 아울러 레플리카 서버에 문제가 생기더라도 소스 서버는 아무런 영향도 받지 않는다는 장점
    - 레플리카 서버에 무거운 쿼리가 실행되어 성능 저하가 있다고 하더라도 소스 서버와는 무관한 일이므로 분석 용도 등으로 사용하기에 적합함 
  - 반동기 복제(Semi-synchronous replication)
    - 반동기 복제는 비동기 복제보다 좀 더 향상된 데이터 무결성을 제공하는 복제 동기화 방식으로, 반동기 복제에서 소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답(ACK)을 보내면 그때 트랜잭션을 완전히 커밋시키고 클라이언트에 결과를 반환함
    - 반동기 복제에서는 소스 서버에서 커밋되어 정상저긍로 결과가 반환된 모든 트랜잭션들에 대해 적어도 하나의 레플리카 서버에는 해당 트랜잭션들이 전송됐음을 보장함
    - AFTER_SYNC 방식은 AFTER_COMMIT 방식돠 비교해서 다음과 같은 장점이 있음
      - 소스 서버에 장애가 발생했을 때 팬텀 리드(Phantom Read)가 발생하지 않음
      - 장애가 발생한 소스 서버에 대해 좀 더 수월하게 복구 처리가 가능 
    - AFTER_COMMIT에서는 트랜잭션이 스토리지 엔진 커밋까지 처리된 후 레플리카 서버의 응답을 기다리는데, 이처럼 스토리지 엔진 커밋까지 완료된 데이터는 다른 세션에서도 조회가 가능함.     - 팬텀 리드(Phantom Read) : 소스 서버가 어떤 트랜잭션에 대해 스토리지 엔진 커밋 후 레플리카 서버로부터 아직 응답을 기다리고 있는 상황에서 소스 서버에 장애가 발생한 경우, 사용자는 이후 새로운 소스 서버로 승격된 레플리카 서버에서 데이터를 조회할 때 자신이 이전 소스 서버에서 조회했던 데이터를 보지 못할 수도 있음 
- 복제 토폴리지
  - 싱글 레플리카 복제 구성
    - 하나의 소스 서버에 하나의 레플리카 서버만 연결돼 있는 복제 형태를 말함, 가장 기본적인 형태로, 제일 많이 사용되는 형태 
    - 애플리케이션 서버는 소스 서버에만 직접적으로 접근해 사용하고 레플리카 서버에는 접근하지 않으며, 레플리카 서버는 소스 서버에서 장애가 발생했을 때 사용될 수 있는 예비 서버 및 데이터 백업 수행을 위한 용도로 많이 사용됨 
    - 소스 서버와 레플리카 서버가 일대일로 구성된 형태에서는 레플리카 서버를 정말 예비용 서버로서만 사용하는 게 제일 적합함 
  - 멀티 레플리카 복제 구성
    - 하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태, 보통 싱글 레플리카 복제 구성에서 추가적인 용도를 위해 여분의 레플리카 서버가 더 필요해 졌을 때 자주 사용되는 형태 
    - 여러 용도로 나누어 사용하는 경우와 더불어 서비스의 읽기 요청 처리를 분산하는 용도로 사용하는 경우 모두 레플리카 서버 한 대는 예비용으로 남겨두는 것이 좋음 
  - 체인 복제 구성
    - 멀티 레플리카 복제 구성에서 레플리카 서버가 너무 많아 소스 서버의 성능에 악영향이 예상된다면 1:M:M 구조의 체인 복제 구성을 고려해 볼 수 있음 
  - 듀얼 소스 복제 구성
    - 두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버로 구성돼 있는 형태
    - 듀얼 소스 구성은 두 MySQL 서버 모두 쓰기가 가능하다는 것이 제일 큰 특징이며, 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에서 쓰기가 발생하지만 두 서버는 서로 동일한 데이터를 갖게 됨 
    - ACTIVE-PASSIVE
      - 하나의 MySQL 서버에서만 쓰기 작업이 수행되는 형태
      - 싱글 레플리카 복제 구성과 동일하다고 생각할 수 있지만 예비 서버인 다른 MySQL 서버가 바로 쓰기 작업이 가능한 상태이기 때문에 쓰기 작업이 수행되고 있는 서버에서 문제 발생 시 별도의 설정 변경 없이 바로 예비용 서버로 쓰기 작업을 전환할 수 있다는 점이 다름
      - 한 서버에서 다른 서버로 바로 쓰기가 전환될 수 있는 환경이 필요한 경우에 주로 사용됨 
    - ACTIVE-ACTIVE
      - 두 서버 모두에 쓰기 작업을 수행하는 형태로, 지리적으로 매우 떨어진 위치에서 유입되는 쓰기 요청도 원활하게 처리하기 위해 주로 상요됨 
    - 듀얼 소스 복제 구성 문제 발생
      - 동일한 데이터를 각 서버에서 변경
      - 테이블에서 Auto-Increment 키 사용 
  - 멀티 소스 복제 구성
    - 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태 
    - 멀티 소스 복제 구성의 목적
      - 여러 MySQL 서버에 존재하는 각기 다른 데이터를 하나의 MySQL 서버로 통합
      - 여러 MySQL 서버에 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합
      - 여러 MySQL 서버의 데이터들을 모아 하나의 MySQL 서버에서 백업을 수행 
    - 늘어날 서비스 트래픽에 대비해 사전에 MySQL 서버들을 동일한 테이블 스키마 구조를 가지는 샤드 형태(분산해서 사용하는 형태)로 구성해뒀으나 예상했던 것만큼 트래픽이 유입되지 않은 경우 멀티 소스 복제를 구성해서 샤딩된 테이블들의 데이터를 통합(Consolidation)해 MySQL 서버 수를 줄일 수도 있음 
    - 멀티 소스 복제 동작
      - MySQL의 멀티 소스 복제에서 레플리카 서버는 자신과 연결된 소스 서버들의 변경 이벤트들을 동시점에, 병렬로 동기화함 
      - 각 소스 서버들에 대한 복제가 독립적으로 처리되는 것을 의미하며, 각각의 독립된 복제 처리를 채널(Channel)
- 복제 고급 설정
  - 지연된 복제(Delayed Replication)
    - 복제는 최대한 빠르게 동기화해서 소스 서버와 레플리카 서버 간의 데이터를 동일한 상태로 만드는 것이 원래의 목적
    - 이전 시점의 데이터 값에 대해 확인이 필요한 경우에도 백업 데이터를 사용하지 않고 지연된 복제본에서 확인할 수 있게 됨 
    - 지연된 복제 기능은 데이터 반영에 지연이 있을 때 어떻게 서비스가 동작하는지 테스트할 때도 매우 유용함 
  - 멀티 스레드 복제(Multi-threaded Replication)
    - MySQL 복제에서는 레플리카 서버에서 소스 서버로부터 복제된 트랜잭션들을 하나의 스레드가 아닌 여러 스레드로 처리할 수 있게 하는 멀티 스레드 복제 기능을 제공함 
    - 기존의 단일 스레드 복제에서는 레플리케이션 SQL 스레드가 릴레이 로그 파일을 읽어서 바로 트랜잭션을 적용하는 형태였다면 멀티 스레드 복제에서는 SQL 스레드는 코디네이터 스레드(Coordinator Thread), 실제로 이벤트를 실행하는 스레드인 워커 스레드(Worker Thread)와 협업해서 동기화를 진행함
    - 코디네이터 스레드는 릴레이 로그 파일에서 이벤트들을 읽은 뒤 설정된 방식에 따라 스케줄링해서 워커 스레드에 각 이벤트를 할당함. 각 이벤트는 워커 스레드들의 큐에 적재되며, 워커 스레드는 큐에서 이벤트들을 꺼내 순차적으로 레플리카 서버에 적용함
    - 멀티 스레드 복제는 소스 서버로부터 복제된 트랜잭션들을 어떻게 병렬로 처리할 것인가에 따라 데이터베이스 기반과 LOGICAL CLOCK 기반 처리 방식으로 나뉨
      - 데이터베이스 기반 멀티 스레드 복제
        - 스키마 기반(Schema-based)처리 방식이라고도 하며 MySQL 내의 데이터베이스 단위로 병렬 처리를 수행하는 형태를 말함 
      - LOGICAL CLOCK 기반 멀티 스레드 복제
        - 데이터베이스 기반 멀티 스레드 복제에서는 MySQL 서버에 하나의 데이터베이스만 존재한느 경우 멀티 스레드로 처리될 수 없다는 큰 단점이 있음 
        - 여러 개의 데이터베이스가 있다 하더라도 데이터베이스별로 발생하는 DML 쿼리 양이 균등하지 않고 특정 데이터베이스로만 쿼리 요청이 집주오디는 경우에만 여전히 레플리카 서버에서 쉽게 복제 지연이 발생할 수 있다는 점도 아쉬운 점 중 하나 
        - 같은 데이터베이스 내에서도 멀티 스레드 동기화 처리가 가능함 
        - 바이너리 로그 그룹 커밋
          - 분산 트랜잭션(XA, Two-Phase Commit) : 클라이언트로부터 커밋 요청이 들어오면 MySQL 서버에서는 Prepare와 Commit의 두 단계를 거쳐 커밋을 처리함
          - 분산 트랜잭션은 트랜잭션을 커밋할 때 스토리지 엔진에 적용된 내용과 바이너리 로그에 기록된 내용 간의 일관성을 유지하기 위해 사용됨 
          - 리더(Leader) : 비어있는 대기 큐에 첫번째로 등록된 트랜잭션
          - 팔로워(Follower) : 이후 등록된 다른 트랜잭션들
          - 트랜잭션들 처리
            - 1.Flush 단계 : 대기 큐에 등록된 각 트랜잭션들을 순서대로 바이너리 로그에 기록함 
            - 2.Sync 단계 : 앞서 기록된 바이너리 로그 내용들을 디스크와 동기화하는 fsync() 시스템 콜이 수행됨 
            - 3.Commit 단계 : 대기 큐에 등록된 트랜잭션들에 대해 스토리지 엔진 커밋을 진행함 
        - Commit-parent 기반 LOGICAL CLOCK 방식
        - 잠금(Lock) 기반 LOGICAL CLOCK 방식
        - WriteSet 기반 LOGICAL CLOCK 방식
          - WriteSet 기반 방식은 트랜잭션의 커밋 처리 시점이 아닌 트랜잭션이 변경한 데이터를 기준으로 병렬 처리 가능 여부를 결정함 
          - 동일한 데이터를 변경하지 않는 트랜잭션들은 레플리카 서버에서 모두 병렬로 실행될 수 있는 것 
  - 크래시 세이프 복제(Crash-safe Replication)
    - MySQL이 비정상 종료된 후 재구동됐을 때도 복제가 원활하게 재개될 수 있게 여러 설정을 제공하며 이를 통해 사용자는 서버 장애 이후에도 MySQL에서 문제없이 복제가 진행되는 크래시 세이프 복제를 실현함
    - 서버 장애와 복제 실패
      - I/O 스레드는 소스 서버로부터 바이너리 로그 이벤트를 네트워크를 통해 가져온 후 레플리카 서버의 로컬 디스크에 파일로 저장하는 역할을 담당하며, SQL 스레드는 I/O 스레드가 가져온 바이너리 로그 이벤트를 실제 MySQL 서버에서 재실행하는 역할을 담당함 
      - I/O 스레드와 SQL 스레드는 각각 자신이 어느 시점까지의 바이너리 로그를 가져왔는지, 어느 트랜잭션까지 재실행했는지에 대한 포지션 정보를 남기며, MySQL 서버가 종료됐다가 다시 실행되면 이 포지션 정보들을 참조해서 복제를 어느 시점부터 다시 시작해야 할지를 판단하게 됨 
      - MySQL 서버가 비정상 종료하는 경우 처리한 내역과 포지션 정보 간에 불일치가 발생할 수 있었음
        - I/O 스레드가 릴레이 로그 이벤트를 기록한 후 아직 포지션 정보 파일에 업데이트를 하지 않은 상태에서 MySQL이 비정상 종료되면 MySQL을 재구동할 때 릴레이 로그에 동일한 이벤트가 기록될 수 있음 
        - SQL 스레드가 릴레이 로그에 기록된 트랜잭션을 커밋한 후 아직 포지션 정보 파일에 업데이트를 하지 않은 상태에서 MySQL이 비정상 종료되면 MySQL을 재구동할 때 동일한 트랜잭션이 재실행될 수 있음
        - 불일치로 인해 흔히 겪는 Duplicate key 에러가 발생함

# InnoDB 클러스터
- MySQL 서버 자체적으로 페일오버(Failover)를 처리하는 기능을 제공하지 않으므로 사용자는 장애가 발생했을 때 레플리카 서버가 새로운 소스 서버가 될 수 있도록 일련의 작업들을 수행해야 함, 레플리카 서버에 설정된 읽기 모드를 해제해야 하며, 스플릿 브레인(Split-Brain) 현상을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 실행하지 못하도록 해야 함. 
- 애플리케이션 서버는 새로운 소스 서버를 바라보도록 커넥션 설정을 변경해야 함 
- MySQL 서버 장애를 감지해 자동으로 페일오버를 처리하는 프로그램을 직접 개발해서 사용하거나 혹은 서드파티(Third-party) HA 솔루션을 사용, MMA,MHA,Orchestrator 등이 있음 
- MySQL 5.1.17 버전에서 빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입되면서 사용자는 좀 더 쉽고 편리하게 고가용성을 실현할 수 있게됨 
- InnoDB 클러스터 아키텍처
  - InnoDB 클러스터는 MySQL의 고가용성 실현을 위해 만들어진 여러 구성 요소들의 집합체
  - InnoDB 클러스터를 구성하는 요소 
    - 그룹 복제(Group Replication)
      - 소스 서버의 데이터를 레플리카 서버로 동기화하는 기본적인 복제 역할뿐만 아니라 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리(그룹에 새로운 멤버의 추가 및 제거 등) 역할을 담당함 
    - MySQL 라우터(MySQL Router)
      - 애플리케이션 서버와 MySQL 서버 사이에 동작하는 미들웨어 프로그램으로, 애플리케이션이 실행한 쿼리를 적절한 MySQL 서버로 전달하는 프락시(Proxy) 역할을 함 
    - MySQL 셸(MySQL Shell)
      - 기존 MySQL 클라이언트보다 좀 더 확장된 기능을 가진 새로운 클라이언트 프로그램으로, 기본적인 SQL문 실행뿐만 아니라 자바스크립트 및 파이썬 기반의 스크립트 작성 기능과 MySQL 서버에 대해 클러스터 구성 등의 어드민 작업을 할 수 있게 하는 API(AdminAPI)를 제공함 
  - InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하는 것이 아니라 MySQL 라우터에 연결해서 쿼리를 실행함. 
  - MySQL 라우터는 InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타데이터 정보를 지니며, 이를 바탕으로 클라이언트로부터 실행된 쿼리를 클러스터 내 적절한 MySQL 서버로 전달함
  - MySQL 셸은 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있도록 API를 제공하며, 그 외에도 InnoDB 클러스터의 상태를 확인하거나 MySQL 서버의 설정을 변경하는 것과 같은 여러가지 기능들을 제공함 
  - InnoDB 클러스터에서는 MySQL 서버에 장애가 발생하면 그룹 복제가 먼저 이를 감지해서 자동으로 해당 서버를 복제 그룹에 제외심키며, MySQL 라우터는 이러한 복제 토폴리지 변경을 인지하고 자신이 가진 메타데이터를 갱신해서 클라이언트로부터 실행된 쿼리가 현재 복제 그룹에서 정상정으로 동작했던 부분들이 InnoDB 클러스터에서는 모두 자동으로 처리되며, 클라이언트에서도 MySQL에 대한 커넥션 설정 변경 등과 같은 부수적인 작업을 수행할 필요 없이 기존에 설정된 그대로 쿼리를 실행하면 되는 것 
  - InnoDB 클러스터는 MySQL에서 공식적으로 제공하는 빌트인 HA 솔루션으로 구성 요소들 또한 MySQL에서 제공하는 것들로 전부 하나의 패키지로서 테스트되고 개발된다는 점에서 매우 큰 장점 
- 그룹 복제(Group Replication)
  - 그룹 복제는 기존 MySQL 복제 프레임워크를 기반으로 구현되어 내부적으로 Row 포맷의 바이너리 로그와 릴레이 로그, GTID를 사용함 
  - 기존 복제의 경우 일반적으로 소스-레플리카 형태로 구성되어 단반향으로만 복제가 이뤄지는 반면, 그룹 복제에서는 복제에 참여하는 MySQL 서버들이 하나의 복제 그룹으로 묶인 클러스터 형태를 가지며 그룹 내 서버들은 서로 통신하면서 양방향으로도 복제를 처리할 수 있음, 하나의 복제 그룹 내에서 쓰기를 처리하는 서버가 여러 대 존재할 수 있다는 것 
  - 쓰기를 처리하는 서버를 프라임러, 읽기 전용으로 동작하는 서버를 세컨더리라고 하며 그룹 복제에 참여하는 MySQL 서버들은 그룹 멤버라고 지칭함 
  - 기존 복제에서의 복제 처리 방식을 데이터 동기화 측면에서 분류하면 비동기(Asynchronous) 방식과 반동기(Semi-Synchronous)방식으로 나눌수 있음 
    - 그룹 복제는 반동기 방식
    - 기본 복제에서는 기본적으로 소스 서버에서의 트랜잭션 커밋 처리가 레플리카 서버와는 무관하게 처리되는 비동기 방식으로 동작함. 소스 서버에서는 트랜잭션 커밋 시 레플리카 서버로도 해당 트랜잭션이 정상적으로 전달됐고 잘 적용됐는지를 확인하지 않음 
    - 반동기 방식은 트랜잭션을 처리할 때 소스 서버와 레플리카 사이에 확인 단계가 하나 추가된 것으로 반동기 방식을 사용하는 경우 소스 서버에서는 트랜잭션 커밋 처리 중 레플리카 서버로 트랜잭션이 잘 전달됐는지 응답을 기다린 후 최종적으로 커밋을 처리하게 됨 
  - 그룹 복제에서는 한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션 정보를 그룹의 다른 멤버들에게 전송하고 과반수 이상의 멤버로부터 응답을 전달받으면 그때 해당 트랜잭션 인증(Certify)하고 최종적으로 커밋 처리를 완료함 
  - 합의(Consensus) : 그룹 복제에서는 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정, 그룹 멤버들로부터 이 트랜잭션을 복제그룹에 적용하는 것에 대한 동의를 구하는 것이기 때문 
  - 그룹 복제에서 제공하는 대표적인 기능
    - 그룹 멤버 관리
    - 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지 
    - 자동 페일오버
    - 자동 분산 복구
  - 그룹 복제 아키텍처
    - 그룹 복제 플러그인 내부 구조
      - MySQL Server > Group Replication Plugin(Plugin API, Replication Plugin, Group Communication System API, Group Communication Engine(XCom)) > Group
    - 플러그인 최상위 계층에는 그룹 복제 플러그인이 MySQL 서버와 상호작용하기 위해 구현된 인터페이스 플러그인 API 집합이 존재
    - API를 통해 MySQL 서버에서 그룹 복제 플러그인으로 혹은 그 반대 방향으로 요청이 전달되며, MySQL 서버에서는 MySQL 서버의 시작 또는 복구, 트랜잭션 커밋등의 이벤트를 그룹 복제 플러그인에 전달하고 그룹 복제 플러그인에서는 처리 중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 등을 서버에 전달함 
    - 그룹 복제의 기능들이 실질적으로 구현돼 있는 복제 플러그인 계층이 존재함. 계층 내부는 여러 가지 모듈들로 나눠져 있으며, API를 통해 들어온 요청들은 각각 적절한 모듈로 전달됨 
    - 로컬 및 그룹 복제의 다른 MySQL 서버에서 실행된 원격 트랜잭션들이 처리되며, 트랜잭션들에 대한 충돌 감지 및 그룹 내 전파 등이 수행됨. 그룹 복제의 분산 복구 작업도 이 계층에서 처리됨 
    - 그룹 통신 시스템 API와 그룹 통신 엔진, 상위 플러그인 계층에서는 그룹 통신 시스템 API를 통해 그룹 통신 엔진과 상호작용함. 그룹 통신 엔진은 eXtended CoMmunicaiton 또는 간단하게 XCom이라고도 하며 그룹 복제에 참여 중인 다른 MySQL 서버들과의 통신처리르 담당하는 그룹 복제의 핵심 구성 요소
    - 그룹 통신 엔진은 트랜잭션이 그룹 복제 멤버들에거 동일한 순서로 전달될 수 있도록 보장해주며, 그룹 복제 토폴리지의 변경과 그룹 멤버의 장애 들을 감지함. 트랜잭션 적용 등을 위한 그룹 멤버 간의 합의 처리도 담당함 
    - 그룹 복제에서 또 다른 중요한 부분은 바로 그룹 복제를 구성하는 MySQL 서버의 수. 그룹 복제에서는 복제를 처리할 때 그룹 멤버들 간에 합의 절차가 수행되므로 그룹 복제가 정상적으로 동작하려면 그룹의 과반수에 해당하는 서버가 정상적으로 동작하고 있어야 함. 하나의 서버에 장애가 발생하더라도 그룹 복제가 저반적으로 문제없이 처리되려면 적어도 세 대의 서버가 그룹에 존재해야 함 
    - 그룹 복제로 구성해야 할 서버수를 결정해야 함
      - n = 2f + 1(n:전체 서버 수, f: 허용하고자 하는 장애 서버 수)
  - 그룹 복제 모드 
    - 싱글 프라이머리 모드
      - 싱글 프라이머리 모드는 그룹 내에서 쓰기를 처리할 수 잇는 프라이머리 서버가 한 대만 존재하는 형태 
      - 그룹 내 프라이머리 서버가 변경될 수 있는 상황
        - 자발적으로 혹은 예기치않게 현재 프라이머리 서버가 그룹을 탈퇴하는 경우
        - group_replication_set_as_primary() UDF를 사용해 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우
    - 멀티 프라이머리 모드
      - 그룹 복제에서 그룹 멤버들이 전부 프라이머리로 동작하는 형태로, 클라이언트는 그룹의 어떤 MySQL 서버로든 쓰기와 읽기 요청을 보낼 수 있음 
    - 그룹 멤버 관리(Group Membership)
      - 그룹 복제가 관리하는 멤버 목록과 상태 정보를 뷰(View), 그룹 복제에서 멤버는 새로 가입하거나 탈퇴할수 있으므로 뷰는 특정 시점의 그룹 멤버 목록이라고 할 수 있음 
      - View ID = [Prefix value]:[Sequence Value] 
        - 첫번째 부분은 그룹 복제가 초기화될 때 생성되며 그 시점의 타임스탬프를 기반으로 값이 만들어짐 
        - 두번째 부분은 단조 증가하는 정숫값으로, 값은 1 부터 시작하며 그룹에서 멤버가 변경될 때마다 1씩 증가함 
  - 그룹 복제에서 트랜잭션 처리 
    - 합의(Consensus)는 그룹 내 일관된 트랜잭션 적용을 위해 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙을 받는 과정, 그룹 멤버 간의 통신 결과를 바탕으로 처리됨
    - 그룹 복제의 그룹 통신 엔진에서는 트랜잭션 데이터를 전파하면서 Paxos 기반의 프로토콜을 바탕으로 그룹 멤버들 간의 합의를 수행하며, 최종적으로 합의가 완료되어 트랜잭션이 실행된 멤버에서 그룹의 과반수 이상에 해당하는 메버들로부터 응답 메시지(ACK)를 전달받으며 해당 멤버는 그다음 프로세스를 진행하게 됨 
    - 다수의 그룹 멤버들에서 실행된 트랜잭션들은 합의 단계를 거친 후 글로벌하게 정렬되어, 각 멤버들에서 모두 동일한 순서로 인증(Certificaiton) 단계를 거치게 됨. 인증 단계에서 각 멤버들은 전달받은 트랜잭션 WriteSet 데이터와 로컬에서 내부적으로 관리하고 있는 WriteSet 히스토리 데이터를 바타응로 해당 트랜잭션이 이미 인증 단계를 거친 선행 트랜잭션과 동시점에 동일한 데이터를 변경한 것인지를 검사해서 트랜잭션 충돌 여부를 확인함 
    - 흐름 제어(Flow Control)
      - 흐름 제어 : 그룹 복제에서는 그룹 멤버 간의 트랜잭션 적용 불균형으로 인해 발생하는 문제를 방지하기 위해 그룹 멤버들의 쓰기 처리량을 조절하는 메커니즘이 구현돼 있음 
      - 그룹 복제에서는 흐름 제어를 통해 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들의 데이터가 최대한 동기화된 상태로 유지될 수 있게 하며, 그룹에 평소와 다른 워크로드가 유입되는 등의 변화에도 빠르게 적응해서 각 멤버들의 쓰기 처리량이 균등할 수 있게 함. 필요 이상으로 처리량을 줄이지 않음으로써 서버의 자원을 불필요하게 유휴 상태에 놓여 있지 않게 함 
      - 흐름 제어에서는 멤버에서 다음과 같은 통계 정보들을 수집하며 수집된 데이터들은 그룹의 다른 멤버들에게도 공유됨 
        - 인증(Certification) 큐 크기
        - 적용(Application) 큐 크기
        - 인증된 총 트랜잭션 수
        - 적용된 원격 트랜잭션 수
        - 로컬 트랜잭션 수 
- 그룹 복제의 분산 복구
  - 분산 복구 : 그룹 복제에서는 그룹 가입 시 가입 멤버가 다른 그룹 멤버들과 동일한 최신 데이터를 가질 수 있도록 가입 멤버에서 누락된 트랜잭션들을 다른 그룹 멤버에서 가져와 적용하는 복구 프로세스로 수행하게 됨
  - 기증자(Donor) 멤버 : 분산복구에서 가입 멤버가 복구 작업을 위해 선택한 기존 멤버
  - 분산 복구 프로세스
    - 로컬 복구 
      - 가입 멤버가 이전에 그룹에 가입한 적이 있는 경우 릴레이 로그에 미처 적용하지 못한 트랜잭션이 존재할 수 있음. 따라서 이 트랜잭션들을 먼저 적용한 후 본격적인 복구 작업을 진행함
    - 글로벌 복구
      - 가입 멤버는 그룹의 기존 멤버들에서 기증자 역할을 할 멤버를 선택해서 행당 멤버로부터 데이터 또는 누락된 트랜잭션들을 가져와 자신에게 적용함. 이 작ㅇ버을 진행하는 동안 현재 그룹에서 처리되는 트랜잭션들을 내부적으로 캐싱해 둠 
    - 캐시 트랜잭션 적용
      - 글로벌 복구 단계가 완료되면 캐싱해서 보관하고 있던 트랜잭션들을 적용해 최종적으로 그룹에 참여함 
- MySQL 라우터
  - MySQL 라우터(MySQL Router)는 InnoDB 클러스터에서 애플리케이션 서버로부터 유입된 쿼리 요청을 클러스터 내 적절한 MySQL 서버로 전달하고 MySQL 서버에서 반환된 쿼리 결과를 다시 애플리케이션 서버로 전달하는 프락시(Proxy) 역할을 수행함 
  - 주요 기능 
    - InnoDB 클러스터의 MySQL 구성 변경 자동 감지
    - 쿼리 부하 분산
    - 자동 페일 오버 
- InnoDB 클러스터 트러블슈팅
  - 클러스터 인스턴스 장애
    - 클러스터의 인스턴스들은 네트워크 문제로 인해 일시적으로 통신이 끊어지거나 장애로 인해 서버가 중단되면 클러스터의 그룹 복제에서 추방될 수 있음 
    - 인스턴스가 네트워크 문제로 통신이 단절됐던 경우에는 통신이 회복되면 자동으로 클러스터에 재연결을 시도하는데, 이때 인스턴스의 autoRejoinTries 옵션에 설정된 횟수만큼 시도함 
  - 클러스터의 정족수 손실
    - 클러스터에서 정족수에 해당하는, 즉 과반수 이상의 인스턴스에 장애가 발생한 경우 클러스터는 쓰기 요청을 처리할 수 없게 됨. 인스턴스 추가 및 제거 등과 같이 클러스터 토폴로지를 변경하는 작업들도 수행할 수 없음 
- InnoDB 클러스터 버전 업그레이드
  - 클러스터를 좀 더 안전하게 업그레이드하기 위한 순서
    - MySQL 라우터 업그레이드
    - MySQL 셸 및 InnoDB 클러스터 메타데이터 스키마 업그레이드
    - MySQL 인스턴스 업그레이드 
# Performance 스키마 & Sys 스키마
- 서비스가 성장하면서 데이터가 커지고 데이터베이스 서버의 쿼리 처리량이 늘어나면 최적화되지 않은 설정이나 쿼리 등으로 인해서 성능 문제가 나타날 가능성이 높으며, 이로 인해 서비스에서 응답 지연이 발생하고 경우에 따라 큰 장애 상황이 야기될 수 있음 
- 어떤 경우든지 사용 중인 데이터베이스의 성능을 기존보다 향상시켜야 하는 상황에 놓이면 가장 먼저 해야 할 일은 현재 데이터베이스가 어떤 상태인지 분석하고 성능을 향상시킬 수 있는 튜 닝 요소를 찾는 것 
- Performance 스키마와 Sys 스키마, 사용자는 이를 통해 일반 테이블에 저장된 데이터를 조회하는 것처럼 SQL 문을 사용해 수집된 정보를 조회함
- Performance 스키마
  - MySQL 서버가 기본적으로 제공하는 시스템 데이터베이스 중 하나로, MySQL 서버의 데이터베이스 목록에서 performance_schema라는 이름의 데이터베이스로 확인할 수 있음
  - MySQL 서버 내부 동작 및 쿼리 처리와 관련된 세부 정보들이 저장되는 테이블들이 존재하며, 사용자는 이러한 테이블들을 통해 MySQL 서버의 성능을 분석하고 내부 처리 과정 등을 모니터링 할 수 있음. 
  - Performance 스키마에 저장되는 데이터들은 MySQL 서버 소스코드 곳곳에 존재하는 성능 측정 코드로부터 수집되며 Performance 스키마를 위해 별도로 구현된 전용 스토리지 엔진인 PERFORMANCE_SCHEMA 스토리지 엔진에 의해 수행됨 
  - PERFORMACNE_SCHEMA 스토리지 엔진은 MySQL 서버가 동작 중인 상태에서 실시간으로 정보를 수집하며, 수집한 정보를 디스크가 아닌 메모리에 저장함 
  - 운영체제와 같은 하위 플랫폼에 종속되지 않고 MySQL 서버내에서 서버 상태 및 처리 성능 관련 정보를 확인할 수 있다는 것은 Performance 스키마의 가장 큰 장점 
- Performance 스키마 구성
  - Performance 스키마 설정과 관련된 테이블과 Performance 스키마가 수집한 데이터가 저장되는 테이블로 나눌 수 있음
  - 쿼리 다이제스트는 정규화된 쿼리문(Normalized Statement)을 SHA-256 방식으로 해싱한 값을 나타냄 
  - Setup 테이블
    - Setup 테이블에는 Performance 스키마의 데이터 수집 및 저장과 관련된 설정 정보가 저장돼 있으며, 사용자는 이 테이블들을 통해 Performance 스키마의 설정을 동적으로 변경할 수 있음 
  - Instance 테이블
    - Performance 스키마가 데이터를 수집하는 대상인 실체화된 객체들, 즉 인스턴스들에 대한 정보를 제공하며, 인스턴스 종류별로 테이블이 구분돼 있음 
  - Connection 테이블
    - MySQL에서 생성된 커넥션들에 대한 통계 및 속성 정보를 제공함 
  - Variable 테이블
    - MySQL 서버의 시스템 변수 및 사용자 정의 변수와 상태 변수들에 대한 정보를 제공함 
  - Event 테이블
    - Wait Event 테이블
      - 각 스레드에서 대기하고 있는 이벤트들에 대한 정보를 확인할 수 있음. 일반적으로 잠금 경합 또는 I/O 작업 등으로 인해 스레드가 대기함
    - Stage Event 테이블
      - 각 스레드에서 실행한 쿼리들의 처리 단계에 대한 정보를 확인할 수 있음. 실행된 쿼리가 구문 분석, 테이블 열기, 정렬 등과 같은 쿼리 처리 단계 중 현재 어느 단계를 수행하고 있는지와 처리 단계별 소요 시간 등을 알 수 있음 
    - Statement Event 테이블
      - 각 스레드에서 실행한 쿼리들에 대한 정보를 확인할 수 있음. 실행된 쿼리와 쿼리에서 반환된 레코드수, 인덱스 사용 유무 및 처리된 방식 등의 다양한 정보를 함께 확인할 수 있음 
    - Transaction Event 테이블
      - 각 스레드에서 실행한 트랜잭션에 대한 정보를 확인할 수 있음. 트랜잭션별로 트랜잭션 종류와 현재 상태, 격리 수준 등을 알 수 있음 
    - Summary 테이블
      - Performance 스키마가 수집한 이벤트들을 특정 기준별로 집계한 후 요약한 정보를 제공함 
    - Lock 테이블
      - MySQL에서 발생한 잠금과 관련된 정보를 제공함
    - Replication 테이블
      - SHOW [REPLICA | SLAVE] STATUS 명령문에서 제공하는 것보다 더 상세한 복제 관련 정보를 제공함 
    - Clone 테이블
      - Clone 플러그인을 통해 수행되는 복제 작업에 대한 정보를 제공함 
    - 기타 테이블
      - 앞서 분류된 범주들에 속하지 않는 나머지 테이블들을 의미함 
- Performance 스키마 설정
  - 사용자는 performance 스키마에 대해 크게 두 가지 부분으로 나누어 설정할 수 있음
    - 메모리 사용량 설정
    - 데이터 수집 및 저장 설정
  - Performance 스키마에서는 수집한 데이터들을 모두 메모리에 저장하므로 Performance 스키마가 MySQL 서버 동작에 영향을 줄 만큼 과도하게 메모리를 사용하지 않게 제한하는 것이 좋음. Performance 스키마를 수집 가능한 모든 이벤트에 대해 데이터를 수집하도록 설정하는 것보다는 사용자가 필요로 하는 이벤트들에 대해서만 수집하도록 설정하는 편이 MySQL 내부적인 오버헤드를 줄이고 MySQL 서버의 성능 저하를 유발하지 않음
  - 메모리 사용량 설정
    - Performance 스키마에 저장되는 데이터양은 Performance 스키마의 메모리 사용량과 직결되며, 따라서 메모리 사용량 설정은 곧 얼마만큼의 데이터를 저장할 것인지를 설정하는 것 
  - 데이터 수집 및 저장 설정
    - 사용자는 Performance 스키마가 어떤 대상에 대해 모니터링하며 어떤 이벤트들에 대한 데이터를 수집하고 또 수집한 데이터를 어느 정도 상세한 수준으로 저장하게 할 것인지를 제어할 수 있음. Performance 스키마는 생산자(Product)-소비자(Consumer) 방식으로 구현되어 내부적으로 데이터를 수집하는 부분과 저장하는 부분으로 나누어 동작함 
    - 사용자는 수집 부분과 관련해서 모니터링 대상들과 수집 대상 이벤트들을 설정할 수 있으며, 저장 부분과 관련해서는 데이터를 얼마나 상세하게 저장할 것인지 데이터 저장 레벨을 설정할 수 있음 
    - 런타임 설정 적용 
      - 저장 레벨 설정(setup_consumers)
        - Performance 스키마에서 데이터를 수집하고 저장하는 데 가장 큰 영향을 미치는 설정은 저장 레벨 설정 
        - 저장 레벨이 설정돼 있으면 Performance 스키마에서는 설정된 모니터링 대상 및 수집 대상 이벤트들을 바탕으로 데이터를 수집하고 설정된 저장 레벨에 따라 적절한 테이블에 수집한 데이터를 저장함 
      - 수집 대상 이벤트 설정(setup_instruments)
      - 모니터링 대상 설정(setup_objects, setup_threds, setup_actors)
    - Performance 스키마 설저의 영구 적용
      - MySQL 서버가 동작 중인 상태에서 사용자가 setup 테이블을 통해 동적으로 변경한 Performance 스키마 설정은 MySQL 서버가 재시작되면 모두 초기화됨
- Sys 스키마
  - Performance 스키마의 어려운 사용법을 해결해주는 솔루션 
  - Performance 스키마는 사용자에게 MySQL 서버 내부에서 발생하는 이벤트들에 대해 다양하고 상세한 정보를 제공함. Performance 스키마에는 설정 테이블들을 포함해 백여 개에 달하는 테이블이 존재하며, 이로 인해 어느 테이블에 어떤 정보가 저장돼 있는지 익숙하지 않은 사용자들은 원하는 정보를 얻기까지 다소 시간이 걸릴 수 있음
  - Sys 스키마는 Performance 스키마의 이 같은 불편한 사용성을 보완하고자 도입됐으며, Performance 스키마 및 Information 스키마에 저장돼 있는 데이터를 사용자들이 더욱 쉽게 이해할 수 있는 형태로 출력하는 뷰와 스토어드 프로시저, 함수들을 제공함 
- Sys 스키마 구성
  - 테이블 
    - Sys 스키마에서 일반 테이블로는 Sys 스키마의 데이터베이스 객체에서 사용되는 옵션의 정보가 저장돼 있는 테이블 하나만 존재하며, InnoDB 스토리지 엔진으로 설정돼 있어 데이터가 영구적으로 보존됨 
    - > SELECT * FROM sys_config;
  - 뷰
    - Sys 스키마의 뷰는 Formatted-View와 Raw-View로 구분되며, Formatted-View는 출력되는 결과에서 시간이나 용량과 같은 값들을 사람이 쉽게 읽을 수 있는(Human Readable) 수치로 변환해서 보여주는 뷰, Raw-View는 "x$"라는 접두사로 시작하는데 이 뷰들은 데이터를 저장된 원본 형태 그대로 출력해서 보여줌 
  - 스토어드 프로시저
    - 사용자는 Sys 스키마에서 제공하는 스토어드 프로시저들을 사용해 Performance 스키마의 설정을 손쉽게 확인 및 변경할 수 있으며, MySQL 서버 상태와 현재 실행 중인 쿼리들에 대한 종합적으로 분석한 보고서 형태의 데이터도 확인할 수 있음 
    - statement_performance_analyzer(in_action_ENUM, in_table VARCHAR(129), in_views SET) - 서버에서 실행 중인 쿼리들에 대한 분석 보고서를 출력함 
  - 함수
    - Sys 스키마에서는 값의 단위를 반환하고, Performance 스키마의 설정 및 데이터를 조회하는 등 다양한 기능을 가진 함수를 제공함. Sys 스키마의 뷰와 프로시저에서 사용됨 
- Performance 스키마 및 Sys 스키마 활용 예제
  - 호스트 접속 이력 확인
    - MySQL 서버가 구동된 시점부터 현재까지 MySQL에 접속했던 호스트들의 전체 목록을 얻고자 할 때는 Performance 스키마의 hosts 테이블을 조회해서 해당 내용을 확인할 수 있음 
    - > SELECT * FROM perfromance_schema.hosts;
    - HOST 칼럼이 NULL인 데이터에는 MySQL 내부 스레드 및 연결 시 인증에 실패한 커넥션들이 포함됨 
  - 미사용 DB 계정 확인 
    - MySQL 서버가 구동된 시점부터 현재까지 사용되지 않은 DB 계정들을 확인. 현재 MySQL에 생성돼 있는 계정들을 대상으로 계정별 접속 이력 유무와 뷰, 또는 트리거, 스토어드 프로시저 같은 스토어드 프로그램들의 생성 유무를 확인해서 두 경우 모두 해당되지 않는 계정들의 목록이 출력됨
    - ```sql
      SELECT Distinct m_u.user, m_u.host
      FROM mysql.user m_u
      LEFT JOIN performance_schema.accounts ps_a ON m_u.user = ps_a.user AND ps_a.host = m_u.host
      LEFT JOIN information_schema.views is_v ON is_v.definer = CONCAT(m_u.User,'@',m_u.Host)
      AND is_v.security_type = 'DEFINER'
      LEFT JOIN information_schema.routines is_r ON is_r.definer = CONCAT(m_u.User,'@',m_u.Host) AND is_r.security_type = 'DEFINER'
      LEFT JOIN infroamtion_schema.events is_e ON is_e.definer = CONCAT(m_u.user,'@', m_u.host)
      LEFT JOIN information_schema.triggers is_t on is_t.definer = CONCAT(m_u.user,'@',m_u.host)
      WHERE ps_a.user IS NULL
      AND is_v.definer IS NULL
      AND is_r.definer IS NULL
      AND is_e.definer IS NULL
      AND is_t.definer IS NULL
      ORDER BY m_u.user, m_u.host;
      ```
  - MySQL 총 메모리 사용량 확인
    - MySQL 서버에 할당된 메모리의 전체 크기를 확인할 수 있음. MySQL 서버가 사용하고 있는 메모리 양보다 클 수 있음 
    - > SELECT * FROM sys.memory_global_total;
  - 스레드별 메모리 사용량 확인
    - MySQL에서 동작 중인 스레드들의 메모리 사용량을 확인하고자 할 때, MySQL 내부 백그라운드 스레드 및 클라이언트 연결 스레드들의 현재 메모리 사용량이 출력됨 
    - ```sql
      SELECT thread_id, user, current_allocated
      FROM sys.memory_by_thread_by_current_bytes
      LIMIT 10;
      ```
  - 미사용 인덱스 확인
    - Sys 스키마의 schema_unused_indexes 뷰를 통해 MySQL 서버가 구동된 시점부터 현재까지 사용되지 않은 인덱스의 목록을 확인할 수 있음 
    - ```sql
      SELECT *
      FROM sys.schema_unused_indexes;
      ```
    - 사용하지 않은 인덱스는 불필요하게 디스크 공간을 차지하므로 MySQL 서버 관리 측면에서도 명시적으로 제거하는 것이 좋음. 제거할 때는 안전하게 인덱스가 쿼리에 사용되지 않는 INVISIBLE 상태로 먼저 변경해서 일정 기간 동안 문제가 없음을 확인한 후 제거하는 것이 좋음
    - ```sql
      --// 인덱스를 INVISIBLE 상태로 변경
      ALTER TABLE users ALTER INDEX ix_name INVISIBLE;
      
      --// INVISIBLE 상태 확인
      SELECT TABLE_NAME, INDEX_NAME, IS_VISIBLE
      FROM information_schema.statistics
      WHERE TABLE_SCHEMA = 'DB1' AND TABLE_NAME='users' AND INDEX_NAME ='ix_name';
      ```
  - 중복된 인덱스 확인
    - Sys 스키마의 scheam_redundant_indexes 뷰를 통해 각 테이블에 존재하는 중복된 인덱스의 목록을 확인할 수 있음
    - ```sql
      SELECT * 
      FROM sys.schema_redundant_indexes 
      LIMIT 1 \G
      ```
    - 인덱스의 중복 여부는 인덱스를 구성하고 있는 칼럼에 대해 두 인덱스의 칼럼 구성 순서가 일치하고 어느 한쪽이 다른 한쪽에 포함되는지를 바탕으로 결정됨 
  - 변경이 없는 테이블 목록 확인
    - MySQL 서버가 구동된 시점부터 현재까지 쓰기가 발생하지 않은 테이블의 목록을 확인하고자 할 때 
    - ```sql
      SELECT t.table_schema, t.table_name, t.table_rows, tio.count_read, tio.count_write
      FROM information_schema.tables AS t
      JOIN performance_schema.table_io_waits_summary_by_table AS tio
      ON tio.object_schema = t.table_schema AND tio.object_name = t.table_name
      WHERE t.table_schema NOT IN ('mysql', 'performance_schema', 'sys')
      AND tio.count_write = 0
      ORDER BY t.table_schema, t.table_name;
      ```
  - I/O 요청이 많은 테이블 목록 확인
    - Sys 스키마의 io_global_by_file_by_bytes 뷰를 조회해서 테이블들에 대한 I/O 발생량을 종합적으로 확인해볼 수 있음 
    - 사용자는 해당 뷰에서 테이블 데이터 파일에 대한 데이터들만 선별해서 조회함으로써 MySQL 서버가 구동되는 동안 I/O 요청이 가장 많이 발생한 테이블들을 확인할 수 있음 
    - > SELECT * FROM sys.io_global_by_file_by_bytes WHERE file LIKE '%ibd';
  - 테이블별 작업량 통계 확인
    - Sys 스키마의 schema_table_statistics 뷰를 통해 MySQL 서버에 존재하는 각 테이블에 대한 데이터 작업 유형 및 I/O 유형별 전체 통계 정보를 확인할 수 있음 
    - ```sql
      SELECT table_schema, table_name, rows_fetched, rows_inserted, rows_updated, rows_deleted, io_read, io_write
      FROM sys.schema_table_statistics
      WHERE table_schema NOT IN ('mysql', 'performance_schema', 'sys') \G
      ```
    - 사용자는 이러한 통계 정보들을 통해 각 테이블에서 주로 어떤 작업들이 발생하는지 확인할 수 있으며, 이를 바탕으로 테이블의 대략적인 사용 형태를 파악할 수도 있음. 각 테이블의 주된 사용 형태는 MySQL 서버의 현재 상태를 분석하고 튜닝하는 데 있어 사용자가 기본적으로 파악해야 하는 부분 중 하나
  - 테이블의 Auto-Increment 칼럼 사용량 확인
    - MySQL 서버에서 테이블을 생성할 때 테이블의 프라이머리 키로 순차적으로 증가하는 값을 사용하고 싶은 경우, 일반적으로 테이블의 첫 번째 칼럼에 Auto-Increment 속성을 지정하고 이를 프라이머리 키로 사용함
    - ```sql
      SELECT table_schema, table_name, column_name, auto_increment AS "current_value", max_value, ROUND(auto_increment_ratio * 100, 2) AS "usage_ratio"
      FROM sys.schema_auto_increment_columns;
      ```
  - 풀 테이블 스캔 쿼리 확인
    - 테이블 풀스캔은 쿼리의 성능을 저하시키는 대표적인 원인 중 하나. 테이블 풀스캔은 일반적으로 쿼리가 실행될 때 쿼리에서 사용할 적절한 인덱스가 테이블에 존재하지 않는 경우에 발생함. 테이블 풀스캔을 발생시키는 쿼리가 일회성으로 사용되는 것이 아니며 조회하는 테이블의 사이즈가 작지 않다면 MySQL 서버에 지속적인 부하를 줄 수 있음 
    - 테이블 풀 스캔을 발생시키는 쿼리는 실행 시간이 긴 경우 슬로우 쿼리 로그(Slow Query Log) 파일에서도 확인할 수 있지만, 슬로우 쿼리 로그 파일에서는 테이블 풀스캔 쿼리뿐만 아니라 실행 시간이 오래 걸리는 다양한 쿼리가 기록됨 
    - ```sql
      SELECT db, query, exec_count, sys.format_time(total_latency) as "formatted_total_latency", rows_sent_avg, rows_examined_avg, last_seen
      FROM sys.x$statements_with_full_table_scans 
      ORDER BY total_latency DESC \G
      ```
  - 자주 실행되는 쿼리 목록 확인
    - MySQL 서버에서 빈번하게 실행되는 쿼리들을 확인하고자 할 때 다음 쿼리를 사용해 확인할 수 있음
    - ```sql
      SELECT db, exec_count, query
      FROM sys.statement_analysis
      ORDER BY exec_count DESC;
      ```
  - 실행 시간이 긴 쿼리 목록 확인
    - MySQL 서버에서 오랫동안 실행된 쿼리들의 목록을 확인하고자 할 때 다음 쿼리를 사용할 수 있음
    - ```sql
      SELECT query, exec_count, sys.format_time(avg_latency) as "formatted_avg_latency", rows_sent_avg, rows_examined_avg, last_seen
      FROM sys.x$statement_analysis
      ORDER BY avg_latency DESC;
      ```
  - 정렬 작업을 수행한 쿼리 목록 확인
    - 많은 양의 데이터를 읽은 후 내부적으로 정렬 작업을 수행하는 쿼리들의 경우 서버의 CPU 자원을 많이 소모함. 이러한 쿼리들이 갑자기 대량으로 MySQL 서버에서 유입되면 서버에 부하를 주어 문제가 발생할 수 있음
    - 정렬 작업을 수행하는 쿼리들을 확인해서 정렬이 발생하지 않게 쿼리를 수정하거나 테이블 인덱스를 조정해 새로운 인덱스를 추가하는 방안을 고려해보는 것이 좋음
    - ```sql
      SELECT * 
      FROM sys.statements_with_sorting
      ORDER BY last_seen DESC LIMIT 1 \G
      ```
  - 임시 테이블을 생성하는 쿼리 목록 확인
    - 실행 시 임시 테이블을 생성하는 쿼리들의 목록을 확인하고자 할 때 다음 쿼리를 사용할 수 있음
    - ```sql
      SELECT *
      FROM sys.statements_with_temp_tables
      LIMIT 10 \G
      ```
  - 트랜잭션이 활성 상태인 커넥션에서 실행한 쿼리 내역 확인
    - 종종 MySQL 서버에서 세션의 트랜잭션이 정상적으로 종료되지 않고 오랫동안 남아있는 경우가 있음. 트랜잭션에서 실행한 쿼리들로 인해 다른 세션에서 실행된 쿼리가 처리되지 못하고 대기 할 수 있으며, 다량으로 쌓인 언두 데이터로 인해 쿼리 성능이 저하되는 등의 문제가 발생할 수도 있음 
    - 트랜잭션에서 실행된 쿼리들을 확인. 트랜잭션에서 실행된 쿼리 내역을 통해 애플리케이션 서버의 어느 로직에서 이 트랜잭션을 발생시킨 건지 짐작해볼 수 있기 때문 
    - 현재 열려 있는 트랜잭션이 아닌 특정 세션에서 실행된 쿼리들의 전체 내역을 확인하과 싶은 경우, 쿼리 내역을 살펴보고 싶은 세션의 PROCESSLIST ID 값을 먼저 확인한 후 쿼리의 WHERE 절에 입력해줌 
