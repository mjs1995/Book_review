# 서평
# 쿼리 작성및 최적화
- MySQL 예약어
  - 테이블을 생성할 때는 항상 역따옴표(`)로 테이블이나 칼럼의 이름을 둘러싸지 않은 상태로 생성하길 권장함, 예약어인지 아닌지 MySQL 서버가 에러로 알려주기 때문
- 리터럴 표기법 문자열
  - SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해서 표시함 
  - REGEXP 연산자
    - ^ : 문자열의 시작을 표시. 정규 표현식은 그 표현식에 일치하는 부분이 문자열의 시작이나 중간 또는 끝부분 어디에 나타나든 상관없지만 "^"심범을 표현식의 앞쪽에 넣어주면 일치하는 부분이 반드시 문자열의 제일 앞쪽에 있어야 함을 의미
    - $ : 문자열의 끝을 표시. "^"와는 반대로 표현식의 끝부분에 "$"를 넣어주면 일치하는 부분이 반드시 문자열의 제일 끝에 있어야 함을 의미함 
    - [] : 문자 그룹을 표시. [xyz] 또는 [x-z]라고 표현하면 'x','y','z' 문자 중 하나인지 확인한느 것, 대괄호는 문자열이 아니라 문자 하나와 일치하는지 확인하는 것 
    - () : 문자열 그룹을 표시, (xyz)라고 표현하면 세 문자 중 한 문자가 있는지 체크하는 것이 아니라 반드시 xyz가 모두 있는지 확인하는 것 
    - |: "|"로 연결된 문자열 중 하나인지 확인함. "abc|xyz"라고 표현하면 "abc"이거나 "xyz"인지 확인하는 것
    - .: 어떠한 문자든지 1개의 문자를 표시하며, 정규 표현식으로 "..."이라고 표현했다면 3개의 문자(실제 문자의 값과 관계없이)로 구성된 문자열을 찾는 것 
    - *: 이 기호 앞에 표시된 정규 표현식이 0 또는 1번 이상 반복될 수 있다는 표시
    - +: 이 기호 앞에 표시된 정규 표현식이 1번 이상 반복될 수 있다는 표시
    - ?: 이 기호 앞에 표시된 정규 표현식이 0 또는 1번만 올 수 있다는 표시 
- MySQL 내장 함수
  - 현재 시간 조회(NOW, SYSDATE)
    - 하나의 SQL에서 모든 NOW() 함수는 같은 값을 가지지만 SYSDATE() 함수는 하나의 SQL 내에서도 호출되는 시점에 따라 결괏값이 달라짐
    - SYSDATE() 함수는 두 가지 큰 잠재적인 문제 존재
      - 첫 번째로는 SYSDATE() 함수가 사용된 SQL 레플리카 서버에서 안정적으로 복제되지 못함
      - 두 번째로는 SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못함
  - 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
    - UNIX_TIMESTAMP() 함수는 '1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수 
  - 문자열 처리
    - RPAD(), LAPD() 함수는 문자열의 좌측 또는 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수
    - RTRIM() 함수와 LTRIM() 함수는 문자열의 우측 또는 좌측에 연속된 공백 문자(Space, NewLine, Tab문자)를 제거하는 함수 
  - GROUP BY 문자열 결합
    - GROUP_CONCAT() 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하므로 상당히 유용하게 사용됨
  - 암호화 및 해시 함수(MD5, SHA, SHA2)
    - MD5와 SHA 모두 비대칭형 암호화 알고리즘인데, 인자로 전달된 문자열을 각각 지정된 비트 수의 해시 값을 만들어내는 함수
    - SHA() 함수는 SHA-1 암호화 알고리즘을 사용하며, 결과로 160비트(20바이트) 해시 값을 반환함 
    - SHA2() 함수는 SHA 암호화 알고리즘보다 더 강력한 224비트부터 512비트 암호화 알고리즘을 사용해 생성된 해시 값을 반환함
    - MD5() 함수는 메시지 다이제스트(Message Digest) 알고리즘을 사용해 128비트(16바이트) 해시 값을 반환함
  - 벤치마크(BENCHMARK)
    - BENCHMARK() 함수는 SLEEP() 함수와 같이 디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수
    - 지정한 횟수만큼 반복 실행하는데 얼마나 시간이 소요됐는지가 중요할뿐
    - SELECT BENCHMARK(10, expr)로 실행하는 경우에는 벤치마크 횟수에 관계없이 단 1번의 네트워크, 쿼리 파싱 및 최적화 비용이 소요된다는 점을 고려해야함
  - IP 주소 변환(INET_ATON, INET_NTOA)
     - INET_ATON() 함수와 INET_NTOA() 함수를 이용해 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공함
     - INET_ATON() 함수는 문자열로 구성된 IPv4 주소를 정수형으로 반환하는 함수, INET_NTOA() 함수는 정수형의 IPv4 주소를 사람이 읽을 수 있는 형태의 '.'으로 구분된 문자열로 반환하는 함수 
  - JSON 필드 크기(JSON_STORAGE_SIZE)
    - JSON 데이터는 텍스트 기반이지만 MySQL 서버는 디스크의 저장 공간을 절약하기 위해 JSON 데이터를 실제 디스크에 저장할 때 BSON(Binary JSON) 포맷을 사용함
    - JSON_STORAGE_SIZE() 함수를 제공
  - JSON 필드 추출(JSON_EXTRACT)
  - JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
    - JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지를 확인하는 함수 
  - JSON 오브젝트 생성(JSON_OBJECT)
    - RDBMS 칼럼의 값을 이용해 JSON 오브젝트를 생성하는 함수
  - JSON 칼럼으로 집계
    - JSON_OBJECTAGG()와 JSON_ARRAYAGG() 함수는 GROUP BY 절과 함께 사용되는 집계 함수로서, RDBMS 칼럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수 
  - JSON 데이터를 테이블로 변환
    - JSON_TABLE() 함수는 JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어 반환함
- SELECT
  - Short-Circuit Evaluation
    - 여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화
    - MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 Short-circuit Evaluation 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정함
    - WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 Short-circuit Evaluation과는 무관하게 MySQL 서버는 그 조건을 가장 최우선으로 사용함 
    - MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것 
    - WHERE 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 평가되기 때문에 고려하지 않아도 됨
- DISTINCT
  - LIMIT
    - ORDER BY나 GROUP BY 또는 DISTINCT가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어주기 때문에 쿼리의 작업량을 상당히 줄여줌
- JOIN
  - JOIN 순서와 인덱스
    - 조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면됨, 하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복함 
    - 드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지함 
    - 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립함 
    - 드리븐 테이블을 풀 테이블 스캔하는 실행 계획으로 조인이 실행됐기 때문에 옵티마이저가 조인 버퍼를 사용함
  - OUTER JOIN의 성능과 주의사항
    - ```sql
      SELECT *
      FROM employees e
        LEFT(->INNER) JOIN dept_manger mgr ON mgr.emp_no = e.emp_no
      WHERE mgr.dept_no = 'd001';
      ```
    - ON 절에 조인 조건을 명시했지만 아우터로 조인되는 테이블인 dept_manager의 dept_no='d001' 조건을 WHERE 절에 명시한 것은 잘못된 조인 방법, LEFT JOIN이 사용된 쿼리는 WHERE 절의 조건 때문에 MySQL 옵티마이저가 LEFT JOIN을 다음 쿼리와 같이 INNER JOIN으로 변환해서 실행시킴
    - ```sql
      SELECT *
      FROM employee e 
        LEFT JOIN dept_manger mgr on mgr.emp_no = e.emp_no AND mgr.dept_no='d001';
      ``` 
  - 지연된 조인(Delayed join)
    - 조인의 결과를 GROUP BY하거나 ORDER BY하면 조인을 실행하기 전의 레코드에 GROUP BY나 ORDER BY를 수행하는 것보다 많은 레코드를 처리해야 함 
    - 지연된 조인이란 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미함, 지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있음
    - 지연된 조인은 조인의 개수를 줄이는 것뿐만 아니라 GROUP BY나 ORDER BY 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 함 
  - 레터럴 조인(Lateral Join)
    - 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인하는 것이 가능해짐
    - ```sql
      SELECT *
      FROM employees e
        LEFT JOIN LATERAL (SELECT *
                           FROM salaries s 
                           WHERE s.emp_no = e.emp_no
                           ORDER BY s.from_date DESC LIMIT 2) s2 ON s2.emp_no = e.emp_no
      WHERE e.first_name = 'Matt';
      ```
    - employees 테이블에서 이름이 matt인 사원에 대해 사원별로 가장 최근 급여 변경 내역을 최대 2건씩만 반환함. 래터럴 조인에서 가장 중요한 부분은 FROM 절에 사용된 서브쿼리(Derived Table)에서 외부 쿼리의 FROM 절에 정의된 테이블의 칼럼을 참조할 수 있다는 것 
    - LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성되기 때문에 꼭 필요한 경우에만 사용해야함
  - ORDER BY
    - 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행하는 SELECT를 가정. MyISAM 테이블은 테이블에 저장된 순서대로 가져오는데, 이 순서가 정확히 ISNERT된 순서는 아닐 수도 있음. 일반적으로 테이블의 레코드가 삭제되면서 빈 공간이 생기고, INSERT되는 레코드는 항상 테이블의 마지막이 아니라 빈 공간이 있으면 그 빈 공간에 저장되기 때문. InnoDB의 경우에는 항상 프라이머리 키로 클러스터링돼 있기 때문에 풀 테이블 스캔의 경우에는 기본적으로 프라이머리 키 순서대로 레코드를 가져옴 
  - 서브쿼리
    - SELECT 절에 사용된 서브쿼리
      - SELECT 절에 사용된 서브쿼리는 내부적으로 임시 테이블을 만들거나 쿼리를 비효올적으로 실행하게 만들지는 않기 때문에 서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의할 사항은 없음 
      - SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고, 오로지 스칼라 서브쿼리만 사용할 수 있음 
      - 스칼라 서브쿼리 : 레코드의 칼럼이 각각 하나인 결과를 만들어내는 서브쿼리
      - 로우 서브쿼리, 레코드 서브쿼리 : 스칼라 서브쿼리보다 레코드 건수가 많거나 칼럼 수가 많은 결과를 만들어 내는 서브쿼리
      - 서브쿼리로 실행될 때보다 조인으로 처리할 때가 조금 더 빠르기 때문에 가능하다면 조인으로 쿼리를 작성하는 것이 좋음 
  - CTE(Common Table Expression)
    - CTE(Common Table Expression)는 이름을 가지는 임시 테이블로서, SQL 문장 내에서 한 번 이상 사용될 수 있으며 SQL 문장이 종료되면 자동으로 CTE 임시 테이블은 삭제됨 
    - CTE는 재귀적 반복 실행 여부를 기준으로 Non-recursive와 Recursive CTE로 구분됨 
    - 비 재귀적 CTE(Non-Recursive CTE)
      - CTE를 재귀적으로 사용하지 않더라도 기존 FROM 절에 사용되던 서브쿼리에 비해 3가지 장점이 존재
        - CTE는 임시 테이블은 재사용 가능하므로 FROM 절의 서브쿼리보다 효율적
        - CTE로 선언된 임시 테이블은 다른 CTE 쿼리에서 참조할 수 있음 
        - CTE는 임시 테이블의 생성 부분과 사용 부분의 코드를 분리할 수 있으므로 가독성이 높음 
    - 재귀적 CTE(Recursive CTE)
      - 윈백(Win Back)이라는 단어는 처음 프로젝트를 시작할 때는 MySQL 서버를 검토했다가 MySQL 서버의 기능이나 처리 성능이 부족해서 다른 DBMS를 선택했지만 시간이 지나서 다시 MySQL 서버로 되돌아가는 것을 의미함 
      - 윈백 프로젝트 : 특정 DBMS에서 다른 DBMS로 일괄 마이그레이션하는 작업
  - 윈도우 함수(Window Function)
    - 윈도우 함수를 GROUP BY 칼럼으로 사용하거나 WHERE 절에 사용할 수 없다는 것 
    - 윈도우 함수 기본 사용법
      - 프레임 : 윈도우 함수의 각 파티션 안에서도 연산 대상 레코드별로 연산을 수행할 소그룹이 사용되는데 이를 뜻함
      - 윈도우 함수에서 프레임을 명시적으로 지정하지 않아도 MySQL 서버는 상황에 맞게 프레임을 묵시적으로 선택함
      - 프레임은 레코드의 순서대로 현재 레코드 기준 앞뒤 몇 건을 연산 범위로 제한하는 역할을 함 
  - 잠금을 사용하는 SELECT
    - 잠금 없는 읽기(Non Lokcing Consistent Read) : InnoDB 테이블에 대해서는 레코드를 SELECT할 때 레코드에 아무런 잠금도 걸지 않는데 이를 뜻함
    - FOR SHARE는 SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 걸고, FOR UPDATE는 SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금을 검 
    - NOWAIT & SKIP LOCKED
      - NOWAIT 옵션을 사용하면 SELECT 쿼리가 해당 레코드에 대해 즉시 잠금을 획득했다면 NOWAIT 옵션이 없을때와 동일하게 실행됨
      - SKIP LOCKED 옵션은 SELECT하려는 레코드가 다른 트랝개션에 의해 이미 잠겨진 상태라면 에러를 반환하지 않는 잠긴 레코드는 무시하고 잠금이 걸리지 않은 레코드만 가져옴 
      - SKIP LOCKED 절을 가진 SELECT 구문은 확정적이지 않은 (NOT-DETERMINISTIC) 쿼리가 됨 
        - 확정적(DETERMINISTIC)이란 말의 의미는 입력이 동일하면 시점에 관계없이 동일한 결과를 반환하는 것을 의미함, SKIP LOCKED 절을 가진 SELECT 쿼리는 실행하는 시점에 따라(아무런 데이터 변경이 없는 상태에서도) 각 트랜잭션의 간섭에 의해 다른 결과를 반환할 수도 있는데, 이를 비확정적(NOT-DETERMINISTIC)
- INSERT 
  - INSERT IGNORE
    - INSERT 문장의 IGNORE 옵션은 저장하는 레코드의 프라이머리 키나 유니크 인덱스 칼럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우, 그리고 저장하는 레코드의 칼럼이 테이블의 칼럼과 호환되지 않는 경우 모두 무시하고 다음 레코드를 처리할 수 있게 해줌
  - INSERT ... ON DUPLICATE KEY UPDATE
    - 프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATE 문장의 역할을 수행하게 해줌 
  - LOAD DATA 명령 주의 사항
    - MySQL 서버의 LOAD DATA 명령의 단점
      - 단일 스레드로 실행
      - 단일 트랜잭션으로 실행
  - Auto-Increment 칼럼
    - AUTO_INC 잠금 : MySQL 서버에서는 자동 증가 값의 채번을 위해서는 잠금이 필요함 
- UPDATE와 DELETE
  - JOIN UPDATE
    - 두 개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭젷는 쿼리를 JOIN UPDATE라고 함
    - 조인된 테이블 중에서 특정 테이블의 칼럼값을 다른 테이블의 칼럼에 업데이트해야 할 때 주로 조인 업데이트를 사용함
    - 일반적으로 JOIN UPDATE는 조인되는 모든 테이블에 대해 읽기 참조만 되는 테이블은 읽기 잠금이 걸리고, 칼럼이 변경되는 테이블은 쓰기 잠금이 걸림 
    - JOIN UPDATE 문장이 웹 서비스 같은 OLTP 환경에서는 데드락을 유발할 가능성이 높으므로 너무 빈번하게 사용하는 것은 피하는 것이 좋음. 배치 프로그램이나 통계용 UPDATE 문장에서는 유용하게 사용할 수 있음
- 데이터베이스 변경
  - 다른 DBMS에서는 스키마와 데이터베이스를 구분해서 관리하지만 MySQL 서버에서는 스키마와 데이터베이스는 동격의 개념 
- 테이블 스페이스 변경
  - 제너럴 테이블스페이스 : 여러 테이블의 데이터를 한꺼번에 저장하는 테이블스페이스
- 테이블 변경
  - SHOW CREATE TABLE 명령은 칼럼의 목록과 인덱스, 외래키 정보를 동시에 보여주기 때문에 SQL을 튜닝하거나 테이블의 구조를 확인할 때 주로 이 명령을 사용함 
  - 테이블 리빌드 작업은 주로 레코드의 삭제가 자주 발생하는 테이블에서 데이터가 저장되지 않은 빈 공간(프래그멘테이션, Fragmentation)을 제거해 디스크 사용 공간을 줄이는 역할을 함 
  - 테이블 명 변경
    - 일정 주기로 테이블을 교체(Swap)해야 하는 경우 존재
    - 여러 테이블의 RENAME 명령을 하나의 문장으로 묶어서 실행할 수 있음
      - > RENAME TABLE batch TO batch_old, batch_new TO batch;
      - MySQL 서버는 RENAME TABLE 명령에 명시된 모든 테이블에 대해 잠금을 걸고 테이블의 이름 변경 작업을 실행하게 됨, 응용 프로그램의 입장에서 보면 batch 테이블을 조회하려고 할 때 이미 잠금이 걸려있기 때문에 대기함 
  - 테이블 상태 조회
    - MySQL의 모든 테이블은 만들어진 시간, 대략의 레코드 건수, 데이터 파일의 크기 등의 정보를 가지고 있음. 또한 데이터 파일의 버전이나 레코드 포맷 등과 같이 자주 사용되지는 않지만 중요한 정도보 가지고 있는데 이러한 정보를 조회할 수 있는 명령어는 SHOW TABLE STATUS ...
    - > SHOW TABLE STATUS LIKE 'employees' \G
      - Like 패턴관 같은 조건을 사용해 특정 테이블의 상태만 조회하는 것도 가능
      - \G는 레코드의 칼럼을 라인당 하나씩만 표현하게 하는 옵션, \G는 SQL 문장의 끝을 의미하기도 하기 때문에 \G가 있으면 별도로 ","를 붙이지 않아도 쿼리 입력이 종료된 것으로 간주함 
    - ```sql
      SELECT * FROM information_schema.TABLES
      WHERE TABLE_SCHEMA = 'employees' AND TABLE_NAME ='employees' \G
      ```
      - information_schema 데이터베이스에는 MySQL 서버가 가진 스키마들에 대한 메타 정보를 가진 딕셔너리 테이블이 관리됨 
      - information_schema 데이터베이스에 존재하는 테이블들은 실제로 존재하는 테이블이 아니라 MySQL 서버가 시작되면서 데이터베이스와 테이블 등에 대한 다양한 메타 정보를 모아서 메모리에 모아두고 사용자가 참조할 수 있는 테이블 
    - ```sql
      SELECT TABLE_SCHEMA,
             SUM(DATA_LENGTH)/1024/1024 as data_size_mb
             SUM(INDEX_LENGTH)/1024/1024 as index_size_mb
      FROM information_schema.TABLES
      GROUP BY TABLE_SCHEMA;
      ```
    - information_schema 데이터베이스의 테이블
      - 데이터베이스 객체에 대한 메타 정보
      - 테이블과 칼럼에 대한 간략한 통계 정보
      - 전문 검색 디버깅을 위한 뷰(view)
      - 압축 실행과 실패 횟수에 대한 집계 
  - 테이블 구조 복사
    - 데이터는 복사하지 않고 테이블의 구조만 동일하게 복사하는 명령으로 CREATE TABLE ... LIKE를 사용하면 구조가 같은 테이블들을 손쉽게 생성할 수 있음
