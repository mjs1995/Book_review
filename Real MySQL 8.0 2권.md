# 서평
# 쿼리 작성및 최적화
- MySQL 예약어
  - 테이블을 생성할 때는 항상 역따옴표(`)로 테이블이나 칼럼의 이름을 둘러싸지 않은 상태로 생성하길 권장함, 예약어인지 아닌지 MySQL 서버가 에러로 알려주기 때문
- 리터럴 표기법 문자열
  - SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해서 표시함 
  - REGEXP 연산자
    - ^ : 문자열의 시작을 표시. 정규 표현식은 그 표현식에 일치하는 부분이 문자열의 시작이나 중간 또는 끝부분 어디에 나타나든 상관없지만 "^"심범을 표현식의 앞쪽에 넣어주면 일치하는 부분이 반드시 문자열의 제일 앞쪽에 있어야 함을 의미
    - $ : 문자열의 끝을 표시. "^"와는 반대로 표현식의 끝부분에 "$"를 넣어주면 일치하는 부분이 반드시 문자열의 제일 끝에 있어야 함을 의미함 
    - [] : 문자 그룹을 표시. [xyz] 또는 [x-z]라고 표현하면 'x','y','z' 문자 중 하나인지 확인한느 것, 대괄호는 문자열이 아니라 문자 하나와 일치하는지 확인하는 것 
    - () : 문자열 그룹을 표시, (xyz)라고 표현하면 세 문자 중 한 문자가 있는지 체크하는 것이 아니라 반드시 xyz가 모두 있는지 확인하는 것 
    - |: "|"로 연결된 문자열 중 하나인지 확인함. "abc|xyz"라고 표현하면 "abc"이거나 "xyz"인지 확인하는 것
    - .: 어떠한 문자든지 1개의 문자를 표시하며, 정규 표현식으로 "..."이라고 표현했다면 3개의 문자(실제 문자의 값과 관계없이)로 구성된 문자열을 찾는 것 
    - *: 이 기호 앞에 표시된 정규 표현식이 0 또는 1번 이상 반복될 수 있다는 표시
    - +: 이 기호 앞에 표시된 정규 표현식이 1번 이상 반복될 수 있다는 표시
    - ?: 이 기호 앞에 표시된 정규 표현식이 0 또는 1번만 올 수 있다는 표시 
- MySQL 내장 함수
  - 현재 시간 조회(NOW, SYSDATE)
    - 하나의 SQL에서 모든 NOW() 함수는 같은 값을 가지지만 SYSDATE() 함수는 하나의 SQL 내에서도 호출되는 시점에 따라 결괏값이 달라짐
    - SYSDATE() 함수는 두 가지 큰 잠재적인 문제 존재
      - 첫 번째로는 SYSDATE() 함수가 사용된 SQL 레플리카 서버에서 안정적으로 복제되지 못함
      - 두 번째로는 SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못함
  - 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
    - UNIX_TIMESTAMP() 함수는 '1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수 
  - 문자열 처리
    - RPAD(), LAPD() 함수는 문자열의 좌측 또는 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수
    - RTRIM() 함수와 LTRIM() 함수는 문자열의 우측 또는 좌측에 연속된 공백 문자(Space, NewLine, Tab문자)를 제거하는 함수 
  - GROUP BY 문자열 결합
    - GROUP_CONCAT() 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하므로 상당히 유용하게 사용됨
  - 암호화 및 해시 함수(MD5, SHA, SHA2)
    - MD5와 SHA 모두 비대칭형 암호화 알고리즘인데, 인자로 전달된 문자열을 각각 지정된 비트 수의 해시 값을 만들어내는 함수
    - SHA() 함수는 SHA-1 암호화 알고리즘을 사용하며, 결과로 160비트(20바이트) 해시 값을 반환함 
    - SHA2() 함수는 SHA 암호화 알고리즘보다 더 강력한 224비트부터 512비트 암호화 알고리즘을 사용해 생성된 해시 값을 반환함
    - MD5() 함수는 메시지 다이제스트(Message Digest) 알고리즘을 사용해 128비트(16바이트) 해시 값을 반환함
  - 벤치마크(BENCHMARK)
    - BENCHMARK() 함수는 SLEEP() 함수와 같이 디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수
    - 지정한 횟수만큼 반복 실행하는데 얼마나 시간이 소요됐는지가 중요할뿐
    - SELECT BENCHMARK(10, expr)로 실행하는 경우에는 벤치마크 횟수에 관계없이 단 1번의 네트워크, 쿼리 파싱 및 최적화 비용이 소요된다는 점을 고려해야함
  - IP 주소 변환(INET_ATON, INET_NTOA)
     - INET_ATON() 함수와 INET_NTOA() 함수를 이용해 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공함
     - INET_ATON() 함수는 문자열로 구성된 IPv4 주소를 정수형으로 반환하는 함수, INET_NTOA() 함수는 정수형의 IPv4 주소를 사람이 읽을 수 있는 형태의 '.'으로 구분된 문자열로 반환하는 함수 
  - JSON 필드 크기(JSON_STORAGE_SIZE)
    - JSON 데이터는 텍스트 기반이지만 MySQL 서버는 디스크의 저장 공간을 절약하기 위해 JSON 데이터를 실제 디스크에 저장할 때 BSON(Binary JSON) 포맷을 사용함
    - JSON_STORAGE_SIZE() 함수를 제공
  - JSON 필드 추출(JSON_EXTRACT)
  - JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
    - JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지를 확인하는 함수 
  - JSON 오브젝트 생성(JSON_OBJECT)
    - RDBMS 칼럼의 값을 이용해 JSON 오브젝트를 생성하는 함수
  - JSON 칼럼으로 집계
    - JSON_OBJECTAGG()와 JSON_ARRAYAGG() 함수는 GROUP BY 절과 함께 사용되는 집계 함수로서, RDBMS 칼럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수 
  - JSON 데이터를 테이블로 변환
    - JSON_TABLE() 함수는 JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어 반환함
- SELECT
  - Short-Circuit Evaluation
    - 여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화
    - MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 Short-circuit Evaluation 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정함
    - WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 Short-circuit Evaluation과는 무관하게 MySQL 서버는 그 조건을 가장 최우선으로 사용함 
    - MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것 
    - WHERE 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 평가되기 때문에 고려하지 않아도 됨
- DISTINCT
  - LIMIT
    - ORDER BY나 GROUP BY 또는 DISTINCT가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어주기 때문에 쿼리의 작업량을 상당히 줄여줌
- JOIN
  - JOIN 순서와 인덱스
    - 조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면됨, 하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복함 
    - 드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지함 
    - 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립함 
    - 드리븐 테이블을 풀 테이블 스캔하는 실행 계획으로 조인이 실행됐기 때문에 옵티마이저가 조인 버퍼를 사용함
  - OUTER JOIN의 성능과 주의사항
    - ```sql
      SELECT *
      FROM employees e
        LEFT(->INNER) JOIN dept_manger mgr ON mgr.emp_no = e.emp_no
      WHERE mgr.dept_no = 'd001';
      ```
    - ON 절에 조인 조건을 명시했지만 아우터로 조인되는 테이블인 dept_manager의 dept_no='d001' 조건을 WHERE 절에 명시한 것은 잘못된 조인 방법, LEFT JOIN이 사용된 쿼리는 WHERE 절의 조건 때문에 MySQL 옵티마이저가 LEFT JOIN을 다음 쿼리와 같이 INNER JOIN으로 변환해서 실행시킴
    - ```sql
      SELECT *
      FROM employee e 
        LEFT JOIN dept_manger mgr on mgr.emp_no = e.emp_no AND mgr.dept_no='d001';
      ``` 
  - 지연된 조인(Delayed join)
    - 조인의 결과를 GROUP BY하거나 ORDER BY하면 조인을 실행하기 전의 레코드에 GROUP BY나 ORDER BY를 수행하는 것보다 많은 레코드를 처리해야 함 
    - 지연된 조인이란 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미함, 지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있음
    - 지연된 조인은 조인의 개수를 줄이는 것뿐만 아니라 GROUP BY나 ORDER BY 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 함 
  - 레터럴 조인(Lateral Join)
    - 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인하는 것이 가능해짐
    - ```sql
      SELECT *
      FROM employees e
        LEFT JOIN LATERAL (SELECT *
                           FROM salaries s 
                           WHERE s.emp_no = e.emp_no
                           ORDER BY s.from_date DESC LIMIT 2) s2 ON s2.emp_no = e.emp_no
      WHERE e.first_name = 'Matt';
      ```
    - employees 테이블에서 이름이 matt인 사원에 대해 사원별로 가장 최근 급여 변경 내역을 최대 2건씩만 반환함. 래터럴 조인에서 가장 중요한 부분은 FROM 절에 사용된 서브쿼리(Derived Table)에서 외부 쿼리의 FROM 절에 정의된 테이블의 칼럼을 참조할 수 있다는 것 
    - LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성되기 때문에 꼭 필요한 경우에만 사용해야함
  - ORDER BY
    - 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행하는 SELECT를 가정. MyISAM 테이블은 테이블에 저장된 순서대로 가져오는데, 이 순서가 정확히 ISNERT된 순서는 아닐 수도 있음. 일반적으로 테이블의 레코드가 삭제되면서 빈 공간이 생기고, INSERT되는 레코드는 항상 테이블의 마지막이 아니라 빈 공간이 있으면 그 빈 공간에 저장되기 때문. InnoDB의 경우에는 항상 프라이머리 키로 클러스터링돼 있기 때문에 풀 테이블 스캔의 경우에는 기본적으로 프라이머리 키 순서대로 레코드를 가져옴 
  - 서브쿼리
    - SELECT 절에 사용된 서브쿼리
      - SELECT 절에 사용된 서브쿼리는 내부적으로 임시 테이블을 만들거나 쿼리를 비효올적으로 실행하게 만들지는 않기 때문에 서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의할 사항은 없음 
      - SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고, 오로지 스칼라 서브쿼리만 사용할 수 있음 
      - 스칼라 서브쿼리 : 레코드의 칼럼이 각각 하나인 결과를 만들어내는 서브쿼리
      - 로우 서브쿼리, 레코드 서브쿼리 : 스칼라 서브쿼리보다 레코드 건수가 많거나 칼럼 수가 많은 결과를 만들어 내는 서브쿼리
      - 서브쿼리로 실행될 때보다 조인으로 처리할 때가 조금 더 빠르기 때문에 가능하다면 조인으로 쿼리를 작성하는 것이 좋음 
  - CTE(Common Table Expression)
    - CTE(Common Table Expression)는 이름을 가지는 임시 테이블로서, SQL 문장 내에서 한 번 이상 사용될 수 있으며 SQL 문장이 종료되면 자동으로 CTE 임시 테이블은 삭제됨 
    - CTE는 재귀적 반복 실행 여부를 기준으로 Non-recursive와 Recursive CTE로 구분됨 
    - 비 재귀적 CTE(Non-Recursive CTE)
      - CTE를 재귀적으로 사용하지 않더라도 기존 FROM 절에 사용되던 서브쿼리에 비해 3가지 장점이 존재
        - CTE는 임시 테이블은 재사용 가능하므로 FROM 절의 서브쿼리보다 효율적
        - CTE로 선언된 임시 테이블은 다른 CTE 쿼리에서 참조할 수 있음 
        - CTE는 임시 테이블의 생성 부분과 사용 부분의 코드를 분리할 수 있으므로 가독성이 높음 
    - 재귀적 CTE(Recursive CTE)
      - 윈백(Win Back)이라는 단어는 처음 프로젝트를 시작할 때는 MySQL 서버를 검토했다가 MySQL 서버의 기능이나 처리 성능이 부족해서 다른 DBMS를 선택했지만 시간이 지나서 다시 MySQL 서버로 되돌아가는 것을 의미함 
      - 윈백 프로젝트 : 특정 DBMS에서 다른 DBMS로 일괄 마이그레이션하는 작업
  - 윈도우 함수(Window Function)
    - 윈도우 함수를 GROUP BY 칼럼으로 사용하거나 WHERE 절에 사용할 수 없다는 것 
    - 윈도우 함수 기본 사용법
      - 프레임 : 윈도우 함수의 각 파티션 안에서도 연산 대상 레코드별로 연산을 수행할 소그룹이 사용되는데 이를 뜻함
      - 윈도우 함수에서 프레임을 명시적으로 지정하지 않아도 MySQL 서버는 상황에 맞게 프레임을 묵시적으로 선택함
      - 프레임은 레코드의 순서대로 현재 레코드 기준 앞뒤 몇 건을 연산 범위로 제한하는 역할을 함 
  - 잠금을 사용하는 SELECT
    - 잠금 없는 읽기(Non Lokcing Consistent Read) : InnoDB 테이블에 대해서는 레코드를 SELECT할 때 레코드에 아무런 잠금도 걸지 않는데 이를 뜻함
    - FOR SHARE는 SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 걸고, FOR UPDATE는 SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금을 검 
    - NOWAIT & SKIP LOCKED
      - NOWAIT 옵션을 사용하면 SELECT 쿼리가 해당 레코드에 대해 즉시 잠금을 획득했다면 NOWAIT 옵션이 없을때와 동일하게 실행됨
      - SKIP LOCKED 옵션은 SELECT하려는 레코드가 다른 트랝개션에 의해 이미 잠겨진 상태라면 에러를 반환하지 않는 잠긴 레코드는 무시하고 잠금이 걸리지 않은 레코드만 가져옴 
      - SKIP LOCKED 절을 가진 SELECT 구문은 확정적이지 않은 (NOT-DETERMINISTIC) 쿼리가 됨 
        - 확정적(DETERMINISTIC)이란 말의 의미는 입력이 동일하면 시점에 관계없이 동일한 결과를 반환하는 것을 의미함, SKIP LOCKED 절을 가진 SELECT 쿼리는 실행하는 시점에 따라(아무런 데이터 변경이 없는 상태에서도) 각 트랜잭션의 간섭에 의해 다른 결과를 반환할 수도 있는데, 이를 비확정적(NOT-DETERMINISTIC)
- INSERT 
  - INSERT IGNORE
    - INSERT 문장의 IGNORE 옵션은 저장하는 레코드의 프라이머리 키나 유니크 인덱스 칼럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우, 그리고 저장하는 레코드의 칼럼이 테이블의 칼럼과 호환되지 않는 경우 모두 무시하고 다음 레코드를 처리할 수 있게 해줌
  - INSERT ... ON DUPLICATE KEY UPDATE
    - 프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATE 문장의 역할을 수행하게 해줌 
  - LOAD DATA 명령 주의 사항
    - MySQL 서버의 LOAD DATA 명령의 단점
      - 단일 스레드로 실행
      - 단일 트랜잭션으로 실행
  - Auto-Increment 칼럼
    - AUTO_INC 잠금 : MySQL 서버에서는 자동 증가 값의 채번을 위해서는 잠금이 필요함 
- UPDATE와 DELETE
  - JOIN UPDATE
    - 두 개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭젷는 쿼리를 JOIN UPDATE라고 함
    - 조인된 테이블 중에서 특정 테이블의 칼럼값을 다른 테이블의 칼럼에 업데이트해야 할 때 주로 조인 업데이트를 사용함
    - 일반적으로 JOIN UPDATE는 조인되는 모든 테이블에 대해 읽기 참조만 되는 테이블은 읽기 잠금이 걸리고, 칼럼이 변경되는 테이블은 쓰기 잠금이 걸림 
    - JOIN UPDATE 문장이 웹 서비스 같은 OLTP 환경에서는 데드락을 유발할 가능성이 높으므로 너무 빈번하게 사용하는 것은 피하는 것이 좋음. 배치 프로그램이나 통계용 UPDATE 문장에서는 유용하게 사용할 수 있음
- 데이터베이스 변경
  - 다른 DBMS에서는 스키마와 데이터베이스를 구분해서 관리하지만 MySQL 서버에서는 스키마와 데이터베이스는 동격의 개념 
- 테이블 스페이스 변경
  - 제너럴 테이블스페이스 : 여러 테이블의 데이터를 한꺼번에 저장하는 테이블스페이스
- 테이블 변경
  - SHOW CREATE TABLE 명령은 칼럼의 목록과 인덱스, 외래키 정보를 동시에 보여주기 때문에 SQL을 튜닝하거나 테이블의 구조를 확인할 때 주로 이 명령을 사용함 
  - 테이블 리빌드 작업은 주로 레코드의 삭제가 자주 발생하는 테이블에서 데이터가 저장되지 않은 빈 공간(프래그멘테이션, Fragmentation)을 제거해 디스크 사용 공간을 줄이는 역할을 함 
  - 테이블 명 변경
    - 일정 주기로 테이블을 교체(Swap)해야 하는 경우 존재
    - 여러 테이블의 RENAME 명령을 하나의 문장으로 묶어서 실행할 수 있음
      - > RENAME TABLE batch TO batch_old, batch_new TO batch;
      - MySQL 서버는 RENAME TABLE 명령에 명시된 모든 테이블에 대해 잠금을 걸고 테이블의 이름 변경 작업을 실행하게 됨, 응용 프로그램의 입장에서 보면 batch 테이블을 조회하려고 할 때 이미 잠금이 걸려있기 때문에 대기함 
  - 테이블 상태 조회
    - MySQL의 모든 테이블은 만들어진 시간, 대략의 레코드 건수, 데이터 파일의 크기 등의 정보를 가지고 있음. 또한 데이터 파일의 버전이나 레코드 포맷 등과 같이 자주 사용되지는 않지만 중요한 정도보 가지고 있는데 이러한 정보를 조회할 수 있는 명령어는 SHOW TABLE STATUS ...
    - > SHOW TABLE STATUS LIKE 'employees' \G
      - Like 패턴관 같은 조건을 사용해 특정 테이블의 상태만 조회하는 것도 가능
      - \G는 레코드의 칼럼을 라인당 하나씩만 표현하게 하는 옵션, \G는 SQL 문장의 끝을 의미하기도 하기 때문에 \G가 있으면 별도로 ","를 붙이지 않아도 쿼리 입력이 종료된 것으로 간주함 
    - ```sql
      SELECT * FROM information_schema.TABLES
      WHERE TABLE_SCHEMA = 'employees' AND TABLE_NAME ='employees' \G
      ```
      - information_schema 데이터베이스에는 MySQL 서버가 가진 스키마들에 대한 메타 정보를 가진 딕셔너리 테이블이 관리됨 
      - information_schema 데이터베이스에 존재하는 테이블들은 실제로 존재하는 테이블이 아니라 MySQL 서버가 시작되면서 데이터베이스와 테이블 등에 대한 다양한 메타 정보를 모아서 메모리에 모아두고 사용자가 참조할 수 있는 테이블 
    - ```sql
      SELECT TABLE_SCHEMA,
             SUM(DATA_LENGTH)/1024/1024 as data_size_mb
             SUM(INDEX_LENGTH)/1024/1024 as index_size_mb
      FROM information_schema.TABLES
      GROUP BY TABLE_SCHEMA;
      ```
    - information_schema 데이터베이스의 테이블
      - 데이터베이스 객체에 대한 메타 정보
      - 테이블과 칼럼에 대한 간략한 통계 정보
      - 전문 검색 디버깅을 위한 뷰(view)
      - 압축 실행과 실패 횟수에 대한 집계 
  - 테이블 구조 복사
    - 데이터는 복사하지 않고 테이블의 구조만 동일하게 복사하는 명령으로 CREATE TABLE ... LIKE를 사용하면 구조가 같은 테이블들을 손쉽게 생성할 수 있음
- 칼럼 변경
  - 칼럼 추가
  - ```sql
    --// 테이블의 제일 마지막에 새로운 칼럼을 추가
    ALTER TABLE employees ADD COLUMN emp_telno VARCHAR(20),
    ALGORITHM = INSTANT;
    --// 테이블의 중간에 새로운 칼럼을 추가 
    ALTER TABLE employees ADD COLUMN emp_telno VARCHAR(20) AFTER emp_no,
    ALGORITHM=INPLACE, LOCK=NONE;
    ```
- 인덱스 변경
  - ```sql
    --// 1.index_new라는 이름으로 새로운 인덱스 생성
    ALTER TABLE employees
    ADD INDEX index_new (first_name, last_name),
    ALGORITHM = INPLACE, LOCK=NONE;
    
    --// 2.기존 인덱스(ix_firstname)를 삭제하고, 동시에 새로운 인덱스(index_new)의 이름을 ix_firstname으로 변경
    ALTER TABLE employees
    DROP INDEX ix_firstname,
    RENAME INDEX index_new TO ix_firstname,
    ALGORITHM = INPLACE, LOCK=NONE;
    ```
- 프로세스 조회 및 강제 종료
  - MySQL 서버에 접속된 사용자의 목록이나 각 클라이언트 사용자가 현재 어떤 쿼리를 실행하고 있는지는 SHOW PROCESSLIST 명령으로 확인할 수 있음 
- 활성 트랜잭션 조회
  - ```sql
    --// 트랜잭션이 5초 이상 활성 상태로 남아있는 프로세스만 조사하는 쿼리 
    SELECT trx_id,
    (SELECT CONCAT(user,'@',host)
    FROM information_schema.processlist
    WHERE id=trx_mysql_thread_id) AS source_info,
    trx_state,
    trx_started,
    now(),
    (unix_timestamp(now()) - unix_timestamp(trx_started)) AS lasting_sec,
    trx_requested_lock_id,
    trx_wait_started,
    trx_mysql_thread_id,
    trx_tables_in_use,
    trx_tables_locked
    FROM information_schema.innodb_trx
    WHERE (unix_timestamp(now()) - unix_timestamp(trx_started)) > 5 \G
    ```
  - 평상시보다 오랜 시간 트랜잭션이 활성 상태를 유지하고 있다면 information_schema.innodb_trx 테이블에서 모든 정보를 조회해서 살펴보면 이 트랜잭션이 얼마나 많은 레코드를 변경했고 얼마나 많은 레코드를 잠그고 있는지 확인할 수 있음
  - > SELECT * FROM information_schema.innodb_trx WHERE trx_id=2300 \G
  - 어떤 레코드를 잠그고 있는지는 performance_schema.data_locks 테이블을 참조하면 됨
  - > SELECT * FROM data_locks \G
  - 장시간에 걸쳐 트랜잭션이 쿼리를 실행 중인 상태에서 그 쿼리만 강제 종료시키면 커넥션이나 트랜젹션은 여전히 활성 상태로 남아있게 됨, 응용 프로그램에서 쿼리의 에러를 감지해서 트랜잭션을 롤백하게 돼 있다면 다음과 같이 쿼리만 종료하면 됨 
  - > KILL QUERY 14;
  - 응용 프로그램에서 쿼리 에러에 대한 핸들링이 확실하지 않다면 쿼리를 종료시키는 것보다 커넥션 자체를 강제 종료시키는 방법이 더 안정적일 수 있음
  - > KILL 14;
- 쿼리 성능 테스트
  - 쿼리의 성능에 영향을 미치는 요소
    - 어떤 종류의 버퍼나 캐시가 영향을 미치는지 살펴보고, 이런 영향을 최소화하는 방법도 알아봄
    - 운영체제의 캐시
      - MySQL 서버는 운영체제의 파일 시스템 관련 기능(시스템 콜)을 이용해 데이터 파일을 읽어옴
      - 일반적으로 대부분의 운영체제는 한 번 읽은 데이터는 운영체제가 관리하는 별도의 캐시 영역에 보관해 뒀다가 다시 해당 데이터가 요청되면 디스크를 읽지 않고 캐시의 내용을 바로 MySQL 서버로 반환함
    - MySQL 서버의 버퍼 풀(InnoDB 버퍼 풀과 MyISAM의 키 캐시)
      - MySQL 서버에서도 데이터 파일의 내용을 페이지(또는 블록) 단위로 캐시하는 기능을 제공함
      - InnoDB 스토로지 엔진이 관리하는 캐시를 버퍼 풀 
      - MyISAM 스토리지 엔진이 관리하는 캐시는 키 캐시 

# 확장 검색 
- 전문 검색
  - 전문 검색(Full-text Search) : MySQL 서버는 예전부터 용량이 큰 문서를 단어 수준으로 잘게 쪼개어 문서 검색을 하게 해주는 기능이 있음 
  - 전문 검색 인덱스의 생성과 검색
    - MySQL 서버에서는 2가지 알고리즘을 이용해 인덱싱할 토큰을 분리해냄
      - 형태소 분석(서구권 언어의 경우 어근 분석)
      - n-gram 파서
    - 형태소 분석: 먼저 문장의 공백과 같은 띄어쓰기 단위로 단어를 분리하고, 각 단어의 조사를 제거해서 명사 또는 어근을 찾아서 인덱싱하는 알고리즘 
    - MySQL 서버에서는 단순히 공백과 같은 띄어쓰기 기준으로 토큰을 분리해서 인덱싱함 
    - n-gram: 문장 자체에 대한 이해 없이 공백과 같은 띄어쓰기 단위로 단어를 분리하고, 그 단어를 단순히 주어진 길이(n-gram의 n은 1~10 사이의 숫자 값)로 쪼개서 인덱싱하는 알고리즘 
- 전문 검색 쿼리 모드
  - 불리언 검색(BOOLEAN MODE)
    - 자연어 검색은 단순히 검색어에 포함된 단어들이 존재하는 결과만 가져오는 반면, 불리언 검색은 쿼리에 사용되는 검색어의 존재 여부에 대해 논리적 연산이 가능함 
    - 불리언 검색에서는 + 표시를 가진 검색 단어는 전문 검색 인덱스 칼럼에 존재해야 하며 - 표시를 가진 검색 단어는 전문 검색 인덱스 칼럼에 포함돼 있지 않아야 함 
    - 불리언 검색에서는 쌍따옴표로 묶인 구는 마치 하나의 단어인 것처럼 취급됨 
    - 불리언 검색에서 불리언 연산자나 +나 -를 전혀 사용하지 않으면 검색어에 포함된 단어 중 아무거나 하나라도 있으면 일치하는 것으로 판단함 
  - 검색어 확장(QUERY EXPANSION)
    - 검색어 확장은 사용자가 쿼리에 사용한 검색어로 검색된 결과에서 공통으로 발견되는 단어들을 모아서 다시 한번 더 검색을 수행하는 방식 
- 지리 좌표계
  - 지리 좌표계 데이터 관리
    - MBR(Minimum Bounding Rectangle)을 이용한 ST_Within() 함수를 이용
    - ST_Within() 함수는 2개의 공간 데이터를 파라미터로 입력하는데, 첫 번째 파라미터로 주어진 공간 데이터가 두 번째 파라미터의 공간 데이터에 포함되는지를 체크하는 함수 
    - MySQL 서버는 여러 형태의 점과 선, 그리고 다각형들을 위한 데이터 타입을 지원함
      - POINT & MULTIPOINT
      - LINESTRING & MULTILINESTRING
      - POLYGON & MULTIPOLYGON
      - GEOMETRY & GEOMETRYCOLLECTION

# 파티션
- 파티션 기능은 테이블을 논리적으로 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리할 수 있게 해줌 
- 파티션 기능은 주로 대용량 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용함 
- 파티션을 사용하는 이유
  - 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리 보다 훨씬 크거나 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등이 파티션이 필요한 대표적인 예 
  - 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리 
    - 파티션하지 않고 하나의 큰 테이블로 사용하면 인덱스도 커지고 그만큼 물리적인 메모리 공간도 많이 필요해진다는 사실을 알 수 있음
    - 파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할수 있게 만들어줌 
  - 데이터의 물리적인 저장소를 분리
  - 이력 데이터의 효율적인 관리
    - 요즘은 거의 모든 애플리케이션이 로그라는 이력 데이터를 가지고 있는데, 이는 단기간의 대량으로 누적됨과 동시에 일정 기간이 지나면 쓸모가 없어짐. 로그 데이터는 결국 시간이 지나면 별도로 아카이빙하거나 백업한 후 삭제해버리는 것이 일반적, 다른 데이터에 비해 라이프 사이클이 상당히 짧은 것이 특징 
- 파티션 프루닝(Partition pruning) : 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 뜻함 
- 주의 사항
  - MySQL 서버의 파티션이 가지는 제약 사항 
    - 스토어드 루틴이나 UDF, 사용자 변수 등을 파티션 표현식에 사용할 수 없음
    - 파티션 표현식은 일반적으로 칼럼 그 자체 또는 MySQL 내장 함수를 사용할 수 있는데, 여기서 일부 함수들은 파티션 생성은 가능하지만 파티션 프루닝을 지원하지 않을 수도 있음 
    - 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야 함 
    - 파티션된 테이블의 인덱스는 모두 로컬 인덱스이며, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있음. 파티션 개별로 인덱스를 변경하거나 추가할 수 없음
    - 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 가질 수 있음 
    - 최대(서브 파티션까지 포함해서) 8192개의 파티션을 가질 수 있음 
    - 파티션 생성 이후 MySQL 서버의 sql_mode 시스템 변수 변경은 데이터 파티션의 일관성을 깨뜨릴 수 있음
    - 파티션 테이블에서는 외래키를 사용할 수 없음
    - 파티션 테이블은 전문 검색 인덱스 생성이나 전문 검색 쿼리를 사용할 수 없음 
    - 공간 데이터를 저장하는 칼럼 타입(POINT, GEOMETRY, ...)은 파티션 테이블에서 사용할 수 없음
    - 임시 테이블(Temporary table)은 파티션 기능 사용할 수 없음
  - 파티션 테이블을 생성할 때 가장 크게 영향을 미치는 제약 사항은 모든 유니크 인덱스에 파티션 키 칼럼이 포함돼야 한다는 것 
  - 파티션 사용 시 주의사항
    - 파티션의 목적이 작업 범위를 좁히는 것인데, 유니크 인덱스는 중복 레코드에 대한 체크 작업 때문에 범위가 좁혀지지 않는다는 점 
- MySQL 파티션 종류
  - 레인지 파티션
    - 파티션 키의 연속된 범위로 파티션을 정의하는 방법, 가장 일반적으로 사용되는 파티션 방법 중 하나 
    - MAXVALUE라는 키워드를 이용해 명시되지 않은 범위의 키 값이 담긴 레코드를 저장하는 파티션을 정의할 수 있음
    - 레인지 파티션의 용도
      - 날짜를 기반으로 데이터가 누적되고 연도나,월 또는 일 단위로 분석하고 삭제해야 할 때
      - 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
      - 파티션 키 위주로 검색이 자주 실행될 때 
    - 데이터베이스에서 파티션의 장점
      - 큰 테이블을 작은 크기의 파티션으로 분리
      - 필요한 파티션만 접근(쓰기와 읽기 모두) 
    - 저자가 경험했던 많은 응용 프로그램에서 사용했던 파티션은 대부분 이력을 저장하는 로그 테이블에 레인지 파티션을 적용한 경우
    - 레인지 파티션 테이블 생성
      - ```sql
        CREATE TABLE employee (
        id INT NOT NULL,
        first_name VARCHAR(30),
        last_name VARCHAR(30),
        hired DATE NOT NULL DEFAULT '1970-01-01'
        ...
        ) PARTITION BY RANGE( YEAR(hired) ) (
        PARTITION p0 VALUES LESS THAN (1991),
        PARTITION p1 VALUES LESS THAN (1996),
        PARTITION p2 VALUES LESS THAN (2001),
        PARTITION p3 VALUES LESS THAN MAXVALUE
        );
        ```
    - 레인지 파티션의 분리와 병합
      - 단순 파티션의 추가
      - ```sql
        ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
        REORGANIZE PARTITION p3 INTO(
        PARTITION p3 VALUES LESS THAN (2011),
        PARTITION p4 VALUES LESS THAN MAXVALUE
        );
        ```
      - 파티션 삭제
        - > ALTER TABLE employees DROP PARTITON p0;
        - 레인지 파티션을 사용하는 테이블에서 이렇게 파티션을 삭제할 때 항상 가장 오래된 파티션 순서로만 삭제할 수 있음, 레인지 파티션을 사용하는 테이블에서는 가장 마지막 파티션만 새로 추가할 수 있고, 가장 오래된 파티션만 삭제할 수 있음 
      - 기존 파티션의 분리
      - ```sql
        ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
        REORGANIZE PARTITION p3 INTO (
        PARTITION p3 VALUES LESS THAN (2011),
        PARTITION p4 VALUES LESS THAN MAXVALUE
        ); 
        ```
      - 파티션이 재구성 되는 동안은 테이블의 쓰기가 불가능해지므로 파티션 재구성 작업은 서비스 점검 시간대나 쿼리 처리가 많지 않은 시간대에 진행하는 것이 좋음 
  - 리스트 파티션
    - 레인지 파티션과 가장 큰 차이는 레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다는점 
    - 리스트 파티션에서는 레인지 파티션과 같이 MAXVALUE 파티션을 정의할 수 없음 
    - 리스트 파티션의 용도
      - 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
      - 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
      - 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때 
    - 리스트 파티션 주의사항
      - 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없음
      - 레인지 파티션과 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있음 
  - 해시 파티션
    - 해시 파티션은 MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결장하는 방법
    - MySQL에서 정의한 해시 함수는 복잡한 알고리즘이 아니라 파티션 표현식의 결과값을 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정하는 방식 
    - 해시 파티션의 파티션 키는 항상 정수 타입의 칼럼이거나 정수를 반환하는 표현식만 사용될 수 있음 
    - 해시 파티션의 용도
      - 다음과 같은 특성을 지닌 테이블에 적합함(ex 회원 테이블)
        - 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때 
        - 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때 
    - 해시 파티션 추가
      - 해시 파티션은 특정 파티션 키 값을 테이블의 파티션 개수로 MOD 연산한 결괏값에 의해 각 레코드가 저장될 파티션을 결정함 
      - 해시 파티션은 테이블에 존재하는 파티션의 개수에 의해 파티션 알고리즘이 변하는 것 
      - 새로운 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치돼야 함 
    - 해시 파티션 분할
      - 해시 파티션이나 키 파티션에서 특정 파티션을 두 개 이상의 파티션으로 분할하는 기능은 없으며, 테이블 전체적으로 파티션의 개수를 늘리는 것만 가능함 
    - 해시 파티션 주의사항
      - 특정 파티션만 삭제(DROP PARTITION)하는 것은 불가능함
      - 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아니라 기존 모든 데이터의 재배치 작업이 필요함
      - 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문에 해시 파티션이 용도에 적합한 해결책인지 확인이 필요함 
      - 일반적으로 사용자들에게 익숙한 파티션의 조작이나 특성은 대부분 리스트 파티션이나 레인지 파티션에만 해당하는 것들이 많음. 해시 파티션이나 키 파티션을 사용하거나 조작할 때는 주의가 필요함
  - 키 파티션
    - 키 파티션에서는 정수 타입이나 정숫값을 반환하는 표현식뿐만 아니라 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있음 
    - MySQL 서버는 선정된 파티션 키의 값을 MD5() 함수를 이용해 해시값을 계산하고, 그 값을 MOD 연산해서 데이터를 각 파티션에 분배함, 키 파티션과 해시 파티션의 유일한 차이점 
    - 키 파티션의 주의사항 및 특이사항
      - 키 파티션은 MySQL 서버가 내부적으로 MD5() 함수를 이용해 파티션하기 때문에 파티션 키가 반드시 정수 타입이 아니어도 됨. 해시 파티션으로 파티션이 어렵다면 키 파티션 적용을 고려해보자 
      - 프라이머리 키나 유니크 키를 구성하는 칼럼 중 일부만으로도 파티션할 수 있음 
      - 유니크 키를 파티션 키로 사용할 때 해당 유니크 키는 반드시 NOT NULL이어야 함 
      - 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 때문에 키 파티션이 더 효율적임 
  - 리니어 해시 파티션/리니어 키 파티션
    - 해시 파티션이나 키 파티션은 새로운 파티션을 추가하거나 파티션을 통합해서 개수를 줄일 때 대상 파티션만이 아니라 테이블의 전체 파티션에 저장된 레코드의 재분배 작업이 발생함 
    - 이런 단점을 최소화하기 위해 리니어(Linear) 해시 파티션/리니어 키 파티션 알고리즘이 고안된 것 
    - 리니어 해시 파티션/리니어 키 파티션은 각 레코드 분배를 위해 Power-of-two(2의 승수) 알고리즘을 이용하며, 이 알고리즘은 파티션의 추가나 통합 시 다른 파티션에 미치는 영향을 최소화해줌 
    - 테이블을 10개로 파티션해서 10개의 파티션 중에서 1~3개 정도만 파티션만 읽고 쓴다면 파티션 기능이 성능 향상에 도움이 될 것, 10개로 파티션하고 파티션된 10개를 아주 균등하게 사용한다면 이는 성능 향상보다는 오히려 오버헤드만 심해지는 결과를 가져올 수 있음
    - 파티션을 사용할 때는 반드시 파티션 프루닝이 얼마나 도움이 될지를 먼저 예측해보고 응용 프로그램에 적용하자. 레인지 파티션 이외의 파티션을 적용할 때는 파티션 프루닝을 더 많이 고민해 보고 적용할 것을 권장함 

# 스토어드 프로그램
- 스토어드 프로그램은 스토어드 루틴이라고도 하는데, 스토어드 프로시저와 스토어드 함수, 트리거와 이벤트 등을 모두 아우르는 명칭 
- 스토어드 프로그램의 장점
  - 데이터베이스의 보안 향상
  - 기능의 추상화
  - 네트워크 소요 시간 절감
  - 절차적 기능 구현
  - 개발 업무의 구분 
- 스토어드 프로그램의 단점
  - 낮은 처리 성능
  - 애플리케이션 코드의 조각화
- 스토어드 프로그램의 문법
  - 정의부 : 스토어드 프로그램의 헤더 부분, 주로 스토어드 프로그램의 이름과 입출력 값을 명시하는 부분
  - 본문 부분 : 스토어드 프로그램의 바디(Body)라고도 하며, 스토어드 프로그램이 호출됐을 때 실행하는 내용을 작성하는 부분 
  - 스토어드 프로시저
    - 서로 데이터를 주고 받아야 하는 여러 쿼리를 하나의 그룹으로 묶어서 독립적으로 실행하기 위해 사용하는 것 
    - 배치 프로그램에서 첫 번째 쿼리의 결과를 이용해 두 번째 쿼리를 실행해야 할 때가 대표적인 예 
  - 스토어드 함수
    - 스토어드 함수는 하나의 SQL 문장으로 작성이 불가능한 기능을 하나의 SQL 문장으로 구현해야 할 때 사용함   
- 트리거
  - 트리거는 테이블의 레코드가 저장되거나 변경될 때 미리 정의해둔 작업을 자동으로 실행해주는 스토어드 프로그램, 데이터의 변화가 생길 때 다른 작업을 기동해주는 방아쇠인 것 
  - 칼럼의 유효성 체크나 다른 테이블로의 복사나 백업, 계산된 결과를 다른 테이블에 함께 업데이트 하는 등의 작업을 위해 트리거를 자주 사용함 
  - 트리거 생성
    - ```sql
      CREATE TRIGGER on_delete BEFORE DELETE ON employees
      FOR EACH ROW
      BEGIN
      DELETE FROM salaries WHERE emp_no=OLD.emp_no;
      END;;
      ```
- 이벤트
  - 주어진 특정한 시간에 스토어드 프로그램을 생성할 수 있는 스케줄러 기능 뜻함 
  - 이벤트 생성
    - 일회성 이벤트
      - 단 한 번 실행되는 일회성 이벤트를 등록하려면 ON SCHEDULE AT절을 명시하면 됨 
      - ```sql
        CREATE EVENT onetime_job
        ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
        DO
        INSERT INTO daily_rank_log VALUES (NOW(), 'Done');
        ```
    - 반복성 이벤트
      - ```sql
        CREATE EVENT daily_ranking
        ON SCHEDULE EVERY 1 DAY STARTS '2020-09-07 01:00:00' ENDS '2021-01-01 00:00:00'
        DO
        INSERT INTO daily_rank_log VALUES (NOW(), 'DONE');
        ```
- 핸들러와 컨디션을 이용한 에러 핸들링
  - SQLSTATE와 에러 번호(Error No)
    - ERROR ERROR-NO (SQL-STATE) : ERROR-MESSAGE
      - ERROR-NO 
        - 4자리 (현재까지는) 숫자 값으로 구성된 에러코드, MySQL에서만 유효한 에러 식별 번호
        - 1146이라는 에러 코드 값은 MySQL에서는 테이블이 존재하지 않는다라는 것을 의미하는데 다른 DBMS와 호환되는 에러 코드는 아님
      - SQL-STATE
        - 다섯 글자와 알파벳과 숫자(Alpha-Numeric)로 구성되며 에러뿐만 아니라 여러 가지 상태를 의미하는 코드 
        - DBMS 종류가 다르더라도 ANSI SQL 표준을 준수하는 DBMS(ODBC, JDBC 포함)에서는 모두 똑같은 값과 의미를 가짐. 이 값은 표준값이라서 DBMS 벤더에 의존적이지 않음
  - 다른 에러도 중복된 에러 번호를 지닌 것이 많기 때문에 에러 번호보다는 SQLSTATE를 핸들러에 사용하는 것이 좋음
  - 컨디션
    - 각 에러 번호나 SQLSTATE가 어떤 의미인지 예측할 수 있는 이름을 만들어 두면 훨씬 더 쉽게 코드를 이해할 수 잇을것 
    - > DECLARE condition_name CONDITION FOR condition_value
  - 시그널을 이용한 예외 발생
    - MySQL의 스토어드 프로그램에서 사용자가 직접 예외나 에러를 발생시키려면 시그널(SIGNAL) 명령을 사용해야함 
  - 커서
    - 스토어드 프로그램의 커서(CURSOR)는 JDBC 프로그램에서 자주 사용하는 결과 셋(ResultSet)으로, PHP 프로그램에서는 mysql_query() 함수로 반환되는 결과와 똑같은 것 
      - 스토어드 프로그램의 커서는 전 방향(전진) 읽기만 가능함 
      - 스토어드 프로그램에서는 커서의 칼럼을 바로 업데이트하는 것(Updatable ResultSet)이 불가능함 
      - 센서티브(Sensitive) 커서는 일치하는 레코드에 대한 정보를 실제 레코드의 포인터만으로 유지하는 형태 
      - 인센서티브(Insensitive) 커서는 일치하는 레코드를 별도의 임시 테이블로 복사해서 가지고 있는 형태 
    - 센서티브 커서와 인센서티브 커서를 혼용해서 사용하는 방식을 어센서티브(Asensitive), MySQL의 스토어드 프로그램에서 정의되는 커서는 어센서티브에 속함 

# 데이터 타입
- 칼럼의 데이터 타입과 길이를 선정할 때 가장 주의할 사항
  - 저장되는 값의 성격에 맞는 최적의 타입을 선정
  - 가변 길이 칼럼은 최적의 길이를 지정
  - 조인 조건으로 사용되는 칼럼은 똑같은 데이터 타입으로 선정 
- 문자열
  - 저장공간
    - CHAR와 VARCHAR의 공통점은 문자열을 저장할 수 있는 데이터 타입, 가장 큰 차이는 고정 길이냐 가변 길이
      - 고정 길이는 실제 입력되는 칼럼값의 길이에 따라 사용하는 저장 공간의 크기가 변하지 않음, CHAR 타입은 이미 저장 공간의 크기가 고정적 
      - 가변 길이는 최대로 저장할 수 있는 값의 길이는 제한돼 있지만, 그 이하 크기의 값이 지정되면 그만큼 저장 공간이 줄어듬, VARCHAR 타입은 저장된 값의 유효 크기가 얼마인지를 별도로 저장해 둬야 하므로 1~2바이트의 저장 공간이 추가로 더 필요함 
    - 주민등록번호처럼 항상 값의 길이가 고정적일 때는 당연히 CHAR 타입을 사용해야함, 값이 2~3 바이트씩 차이가 나더라도 자주 변경될 수 있는 부서 번호나 게시물의 상태 값 등은 CHAR 타입을 사용하는 것이 좋음 
  - 콜레이션(Collation)
    - 문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙을 의미함 
    - 비교나 정렬 작업에서 영문 대소문자를 같은 것으로 처리할지, 아니면 더 크거나 작은 것으로 판단할지에 대한 규칙을 정의하는 것 
- 숫자 
  - 참값은 소숫점 이하 값의 유무와 관계없이 정확히 그 값을 그대로 유지하는 것을 의미함. 참값을 관리하는 데이터 타입으로 INTEGER를 포함해 INT로 끝나는 타입과 DECIMAL이 있음 
  - 근삿값은 흔히 부동 소수점이라고 불리는 값을 의미함, 처음 칼럼에 저장한 값과 조회된 값이 정확하게 일치하지 않고 최대한 비슷한 값으로 관리하는 것으로 의미함. 근사값을 관리하는 타입으로는 FLOAT와 DOUBLE이 있음 
  - 이진 표기법이란 흔히 프로그래밍 언어에서 사용하는 정수나 실수 타입을 의미함. 이진 표기법은 한 바이트로 한자리 또는 두 자리 숫자만 저장하는 것이 아니라 256까지의 숫자(양수만 저장한다고 가정할 경우)를 표현할 수 있기 때문에 숫자 값을 적은 메모리나 디스크 공간에 저장할 수 있음. MySQL의 INTEGER나 BIGINT 등 대부분 숫자 타입은 모두 이진 표기법을 사용함 
  - 십진 표기법(DECIMAL)은 숫자 값의 각 자리값을 표현하기 위해 4비트나 한 바이트를 사용해서 표기하는 방법, 우리가 흔히 이야기하는 십진수가 아니라 디스크나 메모리에 십진 표기법으로 저장된다는 것을 의미함. MySQL의 십진 표기법을 사용하는 타입은 DECIMAL뿐이며, DECIMAL 타입은 금액(돈)처럼 정확하게 소수점까지 관리돼야 하는 값을 저장할 때 사용함. DECIMAL 타입은 65자리 숫자까지 표현할 수 있으므로 BIGINT로도 저장할 수 없는 값을 저장할 때 
