# 스프링과 스프링 부트(Spring & Spring Boot)
- 스프링은 오픈소스 경량형 엔터프라이즈 급 프레임웍이고, 자바 서비스 개발에서의 사실상 표준 프레임워크이다.
- Spring 프레임워크
    - JAVA 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크
        - 애플리케이션 프레임워크 : 특정 계측, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말함
        - 경량급 프레임워크 : 단순한 웹 컨테이너에서도 엔터프라이즈 개발의 고급기술을 대부분 사용할 수 있음 
    - 엔터프라이즈 개발 용이 : 개발자가 복잡하고 실수하기 쉬운 Low Level에 많이 신경 쓰지 않으면서 Business Logic 개발에 전념할 수 있도록 해줌
    - 오픈 소스 : Spring은 OpenSource의 장점을 충분히 취하면서 동시에 OpenSource 제품의 단점과 한계를 잘 극복함 
    - 특징 
        - 컨테이너 역할 : Spring 컨테이너는 Java 객체의 Life Cycle을 관리하며, Spring 컨테이너로부터 필요한 객체를 가져와 사용할 수 있음 
        - DI(Dependency Injection) 지원 : Spring은 설정 파일이나 어노테이션을 통해서 객체 간의 의존관계를 설정할 수 있도록 하고 있음 
        - AOP(Aspect Oriented Programming) 지원 : Spring은 트랜잭션이나 로깅, 보안과 같이 공통적으로 필요로하는 모듈들을 실제 핵심 모듈에서 분리해서 적용할 수 있음 
        - POJO(Plain Old Java Object) 지원 : Spring 컨테이너에 저장되는 Java 객체는 특정한 인터페이스를 구현하거나, 특정 클래스를 상속받지 않아도 됨 
        - 트랜잭션 처리를 위한 일관된 방법을 지원 : JDBC, JTA 등 어떤 트랜잭션을 사용하던 설정을 통해 정보를 관리하므로 트랜잭션 구현에 상관없이 동일한 코드 사용 가능
        - 영속성(Persistence)과 관련된 다양한 API 지원 : Spring은 MyBatis, Hibernate 등 데이터베이스 처리를 위한 ORM(Object Relational Mapping) 프레임워크들과의 연동 지원 
- 스프링과 메이븐
    - Spring의 시작 : Spring을 사용하기 위해 Maven Build가 필요함 
    - Maven
        - Spring의 의존 라이브러리를 간편하게 추가할 수 있도록 의존성 주입을 제공
        - 그 외 오픈 소스 라이브러리도 Maven Repository에 업로드 함으로써 대부분의 라이브러를 자동으로 추가 가능함
        - 프로젝트의 구조를 자동으로 구성함
        - BUild를 통해 배포를 위한 파일을 생성함 

# Spring 개발 환경 설정
- Java Development Kit 1.8 
    - JDK 설치 : 스프링 5.0(스프링 부트 2.0)을 위해서는 JDK8 이상 필요
- 스프링 개발 툴 설치
    - Spring Tool Suite(STS) - 전자정부 프레임워크 개발 툴과 유사
    - IntelliJ IDEA
- 스프링 부트 - 차세대 스프링 프레임워크
    - 스프링 기반 production-ready 어플리케이션 개발
    - Convention over Configuration을 따름
    - 톰캣이 내장되어 단독으로 실행 가능
    - 설정을 최대한 줄이고 XML 설정 파일 필요 없음 
    - 베스트 프랙티스에 따라 자동으로 설정을 수행해줌
    - 프로젝트 기본 구조 
        - pom.xml : 메이븐 빌드 명세
        - mvnw : maven wrapper
        - HelloBootApplication.java : main class
        - application.properties : 필요한 구성을 추가하는 프로퍼터
        - HelloBootApplicationTest.java : Junit Test class 
    - 설정 파일
        - application.proerties
            - 선택적인 파일(사용하지 않아도 됨)
            - 명시적으로 요청하는 부분이 없음
            - spring boot가 로드되면 자동으로 이 파일을 로드 
        - 기존의 XML 설정파일도 가져올 수 있음 
            - Application.java 파일에 아래 어노테이션 추가
            - @ImportResource("classpath:spring/root-context.xml")
    - 개발자 툴
        - 스프링 부트 개발모드 지원
            - thymeleaf 등 템플릿에 대한 개발 캐싱을 비활성화 처리
            - 소스의 변경이 일어나면 스프링 부트 서버가 새로 시작되면 바로 반영
            - html, css 부분을 변경하면 바로 브라우저에서 감지하여 반영
        - 간단 설정
            - 디펜던시 추가 : spring-boot-devtools

# REST 아키텍처 
- HTTP Methods
    - |Method|Description|
      |:---:|:---:|
      |GET|자원 요청|
      |POST|Entity를 포함한 자원 요청|
      |HEAD|HTTP Header 정보만 수신
      |TRACE|Request의 루프백 테스트
      |PUT|URL에 자원을 생성
      |DELETE|URL의 자원을 삭제
      |OPTIONS|응답 가능한 HTTP 메소드를 요청
      |CONNECT|터널링의 목적으로 연결 요청(프록시에서 사용함)
- URL - 식별자로 사용
    - 컨텐츠에 접근하기 위한 위치 정보
    - https://abc.com/index.html
        - https: 프로토콜
        - abc.com: 서버
        - index.html: 리소스 
- 소프트웨어는 대체되어도 수년간 쌓인 데이터는 대체할 수 없음
    - SOAP : 동작과 프로세싱에 집중
    - REST : 관심은 데이터 처리 
- RESTful 기반 웹 서비스
    - Roy Fielding 박사학위 논문에서 제안 - 웹 아키텍처가 웹의 본래 설계의 우수성을 활요하지 못하므로 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 제안 
    - REST는 웹 서비스의 사실상 표준. 스프링과 스프링부트는 REST를 적극적으로 지원함 
    - RESTful 웹 서비스(Representational State Transfer, 2000년)
        - HTTP 프로토콜로 데이터를 전달하는 프레임워크
        - 핵심은 웹에 개발된 리소스 이용 
    - REST 아키텍처 스타일에 따라 정의되고 이용됨
        - REST API - 소유자의 자원에 접근할 수 있는 API
        - RESTful하다 - REST API를 제공하는 웹 서비스 
- REST
    - 기존 웹 서비스들이 HTTP를 적극적으로 활용하지 못한 문제를 해결하기 위해 제안됨
    - HTTP를 보다 HTTP 답게 만들기 위한 방법론 
    - 철저히 Resource 중심적으로 설계를 중요시함
        - Create - POST
        - Read - GET
        - Update - PUT
        - Delete - DELETE와 같이 HTTP 4가지 메소드를 용도에 맞게 사용 
    - REST 원리 및 원칙 (제약조건)
        - 확장성 있는 웹 서비스를 위한 소프트웨어 아키텍처 적인 접근
        - Client-Server
            - View와 Data를 분리
            - Portability(이동성) 향상
            - REST 서버는 Resource를 관리하는 API를 제공
                - 클라이언트는 사용자 인증이나 Context(Session, Login 정보) 직접 관리
                - 서버는 UI나 User State에 상관없이 Server 기능에 집중(단순화, 확장성)
        - Stateless(클라이언트의 상태를 서버에 저장하지 않음, 확장성)
            - 세션정보와 같은 context를 저장할 필요가 없음
            - 클라이언트는 자신을 구분하기 위해 서버에게 충분한 정보를 전달해야 함. API Key 또는 Token
        - Cacheable
            - HTTP 프로토콜의 Caching 기능을 적용할 수 있음
            - 웹 서비스의 60~80%가 GET 방식의 요청
            - 구현은 HTTP 프로토콜 표준인 Last-Modified 태그나 E-Tag를 이용 
        - Layered system
            - 시스템 스케일링을 위해 Gateway, Proxy Server, Firewall 과 같은 또 다른 Layer들을 수용할 수 있음 
        - Code on demand(optional)
            - 서버는 실행 가능한 코드를 클라이언트에게 전송
                - 클라이언트의 기능을 일시적으로 확장하거나 커스터마이징 가능 
                - Java Applet, JavaScript가 대표적 예
        - Uniform interface
            - REST의 코어인 리소스는 URI에 의해 식별됨
            - 데이터 구조(data representation)는 강제하지 않음(주로 XML 또는 JSON)
            - REST 디자인 constraints에서 가장 기본적인 제약
            - 통일된 인터페이스를 통해 기술과 플랫폼에 상관없이 사용 가능 
                - Resource Identifier - URI
                    - Resouce는 서비스나 정보를 제공하는 모든 것들이 될 수 있음
                    - 주문, 송장, DB의 레코드, 검색 결과 등
                    - 웹 상에서 주소를 통해 접근 될 수 있음. 즉, 리소스는 URI를 반드시 가져야 함 
                    - URI 정의는 동사형이 아닌 명사형으로 정의하도록 권장됨 
                - Resource Representations
                    - Resource는 Unique ID로 하나 이상의 URI 뿐만 아니라, 다양한 방법으로 설명(대표)되는 Representation을 가질 수 있음 
                    - Representation에 대한 접근을 위한 URL을 가지고 HTTP 4가지 메서드(POST/GET/PUT/DELETE)를 통해 CRUD 할 수 있음 
                    - GET 메서드 정의
                        - Target resource에 대한 현재의 선택된 representation 하나를 반환함
                        - 리소스는 HTTP 요청의 대상이지만, 리소스의 개념을 제한하지 않음 
                    - Representaiton
                        - 어떤 리소스의 특정 시점의 상태를 반영하고 있는 정보
                        - 두 가지로 구성됨
                            - Representation data
                            - Representation metadata
                - Self-Descriptive Message
                    - REST는 Stateless
                        - 클라이언트 - 서버 간 충분한 설명적인 메시지가 필요
                            - HTTP 메서드
                            - HTTP 상태 코드
                            - HTTP 헤더
                - HATEOAS (Hypermedia As The Engine Of Application State) 
                    - HATEOAS 메시지를 보내는 것은 어플리케이션의 상태를 변화시킴
                    - HTTP 응답에 다음 ACtion이나 관계되는 리소스에 대한 HTTP Link를 함께 리턴
                        - 페이지 처리의 경우 리턴 시, 전후 페이지에 대한 링크를 제공
                        - 연관된 리소스에 대한 디테일한 링크를 표시 
