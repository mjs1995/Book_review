# 스프링과 스프링 부트(Spring & Spring Boot)
- 스프링은 오픈소스 경량형 엔터프라이즈 급 프레임웍이고, 자바 서비스 개발에서의 사실상 표준 프레임워크이다.
- Spring 프레임워크
    - JAVA 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크
        - 애플리케이션 프레임워크 : 특정 계측, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말함
        - 경량급 프레임워크 : 단순한 웹 컨테이너에서도 엔터프라이즈 개발의 고급기술을 대부분 사용할 수 있음 
    - 엔터프라이즈 개발 용이 : 개발자가 복잡하고 실수하기 쉬운 Low Level에 많이 신경 쓰지 않으면서 Business Logic 개발에 전념할 수 있도록 해줌
    - 오픈 소스 : Spring은 OpenSource의 장점을 충분히 취하면서 동시에 OpenSource 제품의 단점과 한계를 잘 극복함 
    - 특징 
        - 컨테이너 역할 : Spring 컨테이너는 Java 객체의 Life Cycle을 관리하며, Spring 컨테이너로부터 필요한 객체를 가져와 사용할 수 있음 
        - DI(Dependency Injection) 지원 : Spring은 설정 파일이나 어노테이션을 통해서 객체 간의 의존관계를 설정할 수 있도록 하고 있음 
        - AOP(Aspect Oriented Programming) 지원 : Spring은 트랜잭션이나 로깅, 보안과 같이 공통적으로 필요로하는 모듈들을 실제 핵심 모듈에서 분리해서 적용할 수 있음 
        - POJO(Plain Old Java Object) 지원 : Spring 컨테이너에 저장되는 Java 객체는 특정한 인터페이스를 구현하거나, 특정 클래스를 상속받지 않아도 됨 
        - 트랜잭션 처리를 위한 일관된 방법을 지원 : JDBC, JTA 등 어떤 트랜잭션을 사용하던 설정을 통해 정보를 관리하므로 트랜잭션 구현에 상관없이 동일한 코드 사용 가능
        - 영속성(Persistence)과 관련된 다양한 API 지원 : Spring은 MyBatis, Hibernate 등 데이터베이스 처리를 위한 ORM(Object Relational Mapping) 프레임워크들과의 연동 지원 
- 스프링과 메이븐
    - Spring의 시작 : Spring을 사용하기 위해 Maven Build가 필요함 
    - Maven
        - Spring의 의존 라이브러리를 간편하게 추가할 수 있도록 의존성 주입을 제공
        - 그 외 오픈 소스 라이브러리도 Maven Repository에 업로드 함으로써 대부분의 라이브러를 자동으로 추가 가능함
        - 프로젝트의 구조를 자동으로 구성함
        - BUild를 통해 배포를 위한 파일을 생성함 

# Spring 개발 환경 설정
- Java Development Kit 1.8 
    - JDK 설치 : 스프링 5.0(스프링 부트 2.0)을 위해서는 JDK8 이상 필요
- 스프링 개발 툴 설치
    - Spring Tool Suite(STS) - 전자정부 프레임워크 개발 툴과 유사
    - IntelliJ IDEA
- 스프링 부트 - 차세대 스프링 프레임워크
    - 스프링 기반 production-ready 어플리케이션 개발
    - Convention over Configuration을 따름
    - 톰캣이 내장되어 단독으로 실행 가능
    - 설정을 최대한 줄이고 XML 설정 파일 필요 없음 
    - 베스트 프랙티스에 따라 자동으로 설정을 수행해줌
    - 프로젝트 기본 구조 
        - pom.xml : 메이븐 빌드 명세
        - mvnw : maven wrapper
        - HelloBootApplication.java : main class
        - application.properties : 필요한 구성을 추가하는 프로퍼터
        - HelloBootApplicationTest.java : Junit Test class 
    - 설정 파일
        - application.proerties
            - 선택적인 파일(사용하지 않아도 됨)
            - 명시적으로 요청하는 부분이 없음
            - spring boot가 로드되면 자동으로 이 파일을 로드 
        - 기존의 XML 설정파일도 가져올 수 있음 
            - Application.java 파일에 아래 어노테이션 추가
            - @ImportResource("classpath:spring/root-context.xml")
    - 개발자 툴
        - 스프링 부트 개발모드 지원
            - thymeleaf 등 템플릿에 대한 개발 캐싱을 비활성화 처리
            - 소스의 변경이 일어나면 스프링 부트 서버가 새로 시작되면 바로 반영
            - html, css 부분을 변경하면 바로 브라우저에서 감지하여 반영
        - 간단 설정
            - 디펜던시 추가 : spring-boot-devtools

# REST 아키텍처 
- HTTP Methods
    - |Method|Description|
      |:---:|:---:|
      |GET|자원 요청|
      |POST|Entity를 포함한 자원 요청|
      |HEAD|HTTP Header 정보만 수신
      |TRACE|Request의 루프백 테스트
      |PUT|URL에 자원을 생성
      |DELETE|URL의 자원을 삭제
      |OPTIONS|응답 가능한 HTTP 메소드를 요청
      |CONNECT|터널링의 목적으로 연결 요청(프록시에서 사용함)
- URL - 식별자로 사용
    - 컨텐츠에 접근하기 위한 위치 정보
    - https://abc.com/index.html
        - https: 프로토콜
        - abc.com: 서버
        - index.html: 리소스 
- 소프트웨어는 대체되어도 수년간 쌓인 데이터는 대체할 수 없음
    - SOAP : 동작과 프로세싱에 집중
    - REST : 관심은 데이터 처리 
- RESTful 기반 웹 서비스
    - Roy Fielding 박사학위 논문에서 제안 - 웹 아키텍처가 웹의 본래 설계의 우수성을 활요하지 못하므로 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 제안 
    - REST는 웹 서비스의 사실상 표준. 스프링과 스프링부트는 REST를 적극적으로 지원함 
    - RESTful 웹 서비스(Representational State Transfer, 2000년)
        - HTTP 프로토콜로 데이터를 전달하는 프레임워크
        - 핵심은 웹에 개발된 리소스 이용 
    - REST 아키텍처 스타일에 따라 정의되고 이용됨
        - REST API - 소유자의 자원에 접근할 수 있는 API
        - RESTful하다 - REST API를 제공하는 웹 서비스 
- REST
    - 기존 웹 서비스들이 HTTP를 적극적으로 활용하지 못한 문제를 해결하기 위해 제안됨
    - HTTP를 보다 HTTP 답게 만들기 위한 방법론 
    - 철저히 Resource 중심적으로 설계를 중요시함
        - Create - POST
        - Read - GET
        - Update - PUT
        - Delete - DELETE와 같이 HTTP 4가지 메소드를 용도에 맞게 사용 
    - REST 원리 및 원칙 (제약조건)
        - 확장성 있는 웹 서비스를 위한 소프트웨어 아키텍처 적인 접근
        - Client-Server
            - View와 Data를 분리
            - Portability(이동성) 향상
            - REST 서버는 Resource를 관리하는 API를 제공
                - 클라이언트는 사용자 인증이나 Context(Session, Login 정보) 직접 관리
                - 서버는 UI나 User State에 상관없이 Server 기능에 집중(단순화, 확장성)
        - Stateless(클라이언트의 상태를 서버에 저장하지 않음, 확장성)
            - 세션정보와 같은 context를 저장할 필요가 없음
            - 클라이언트는 자신을 구분하기 위해 서버에게 충분한 정보를 전달해야 함. API Key 또는 Token
        - Cacheable
            - HTTP 프로토콜의 Caching 기능을 적용할 수 있음
            - 웹 서비스의 60~80%가 GET 방식의 요청
            - 구현은 HTTP 프로토콜 표준인 Last-Modified 태그나 E-Tag를 이용 
        - Layered system
            - 시스템 스케일링을 위해 Gateway, Proxy Server, Firewall 과 같은 또 다른 Layer들을 수용할 수 있음 
        - Code on demand(optional)
            - 서버는 실행 가능한 코드를 클라이언트에게 전송
                - 클라이언트의 기능을 일시적으로 확장하거나 커스터마이징 가능 
                - Java Applet, JavaScript가 대표적 예
        - Uniform interface
            - REST의 코어인 리소스는 URI에 의해 식별됨
            - 데이터 구조(data representation)는 강제하지 않음(주로 XML 또는 JSON)
            - REST 디자인 constraints에서 가장 기본적인 제약
            - 통일된 인터페이스를 통해 기술과 플랫폼에 상관없이 사용 가능 
                - Resource Identifier - URI
                    - Resouce는 서비스나 정보를 제공하는 모든 것들이 될 수 있음
                    - 주문, 송장, DB의 레코드, 검색 결과 등
                    - 웹 상에서 주소를 통해 접근 될 수 있음. 즉, 리소스는 URI를 반드시 가져야 함 
                    - URI 정의는 동사형이 아닌 명사형으로 정의하도록 권장됨 
                - Resource Representations
                    - Resource는 Unique ID로 하나 이상의 URI 뿐만 아니라, 다양한 방법으로 설명(대표)되는 Representation을 가질 수 있음 
                    - Representation에 대한 접근을 위한 URL을 가지고 HTTP 4가지 메서드(POST/GET/PUT/DELETE)를 통해 CRUD 할 수 있음 
                    - GET 메서드 정의
                        - Target resource에 대한 현재의 선택된 representation 하나를 반환함
                        - 리소스는 HTTP 요청의 대상이지만, 리소스의 개념을 제한하지 않음 
                    - Representaiton
                        - 어떤 리소스의 특정 시점의 상태를 반영하고 있는 정보
                        - 두 가지로 구성됨
                            - Representation data
                            - Representation metadata
                - Self-Descriptive Message
                    - REST는 Stateless
                        - 클라이언트 - 서버 간 충분한 설명적인 메시지가 필요
                            - HTTP 메서드
                            - HTTP 상태 코드
                            - HTTP 헤더
                - HATEOAS (Hypermedia As The Engine Of Application State) 
                    - HATEOAS 메시지를 보내는 것은 어플리케이션의 상태를 변화시킴
                    - HTTP 응답에 다음 ACtion이나 관계되는 리소스에 대한 HTTP Link를 함께 리턴
                        - 페이지 처리의 경우 리턴 시, 전후 페이지에 대한 링크를 제공
                        - 연관된 리소스에 대한 디테일한 링크를 표시 
# Spring MVC로 RESTful API 서비스 구현
- Spring-Web MVC에서의 RESTful 지원
    - @Controller와 @RequestMapping(value="url", method=POST/GET/DELETE/PUT), @ResponseBody 사용 
- Spiring Boot에서의 RESTful 지원
    - @RestController와 @X-Mapping 사용
- Layered Architecutre - 특징
    - 인접한 레이어 간의 통신만 허용하고 반드시 레이어를 거쳐서 통신하는 구조를 가짐
    - @Controller, @Service, @Repository 어노테이션을 포함하는 클래스는 모두 컴포넌트로 등록되어 스프링 컨테이너에 의해 관리되어 진다.
    - 계층화 아키텍처
        - 효율적인 개발과 유지보수를 위해 계층화하여 개발
        - 대부분의 중/대규모 어플리케이션에서 적용
        - 각 레이어는 독립된 R&R을 가짐 
    - 프레젠테이션 영역
        - 사용자와 상호작용을 담당
        - 사용자의 요청을 분석/응답
    - 비즈니스 영역
        - 기능을 수행
        - 트랜잭션 수행
    - 데이터 영역
        - 데이터의 저장과 조회를 담당
        - 주로 데이터베이스와 연동하여 작업 
- 컴포넌트 자동등록
    - 어노테이션(Annotation) 사용
        - @Component와 하위 어노테이션 사용
        - @Autowired
            - Component 간의 의존관계는 Autowired라는 Annotation으로 적용 
            - DI 기능으로 자동으로 의존관계를 맺어줌 

# REST에서 CRUD 구현
- 스프링을 이용한 웹 서비스 개발은 Layered Architecture를 활용하여 개발하고, 데이터는 모델 클래스를 작성하여 처리함 
- HTTP의 GET, POST, PUT, DELETE를 주로 활용하여 데이터의 CRUD를 구현함
- HTTP 메소드
    - |Operation|HTTP method|
      |:---:|:---:|
      |Operation|POST
      |Read|GET
      |Update|PUT
      |Delete|DELETE
- CRUD 설계
    - UserController 생성: /users
        - GET
            - public Map<String, Object> getAllUsers();
            - public Map<String, Object> getUser(@PathVariable("userid") Integer userid);
        - POST
            - public Map<String, Object> createUsers();
        - PUT
            - public Map<String, Object> updateUser();
        - DELETE
            - public Map<String, Object> deleteUser();
- Data Transfer Object 디자인 패턴
    - 데이터를 각 서버/클라이언트 간 전달하기 위한 목적으로 만든 객체
    - java.io.Serializable 인터페이스 구현 - 객체직렬화 지원
    - Immutable 객체로 만듬 - setter 포함하지 않음
    - 도메인(모델) 객체를 래핑(wrapping)
- JSON
    - RESTful 웹 서비스와 JSON/XML
    - JSON은 경량(lightweight)의 DATA - 교환 형식
    - Javascript에서 객체를 만들 때 사용하는 표현식을 의미함
    - JSON 표현식은 사람과 기계 모두 이해하기 쉬우며 용량이 작아서, 최근에는 JSON이 XML을 대체해서 데이터 전송 등에 많이 사용함
    - 특정 언어에 종속되지 않으며, 대부분의 프로그래밍 언어에서 JSON 포맷의 데이터를 핸들링 할 수 있는 라이브러리를 제공하고 있음 
    - JSON(JavaScript Object Notation) 형식
        - name-value 형식의 쌍(pair) - 여러 가지 언어들에서 object, hashtable, struct로 실현되었음 
        - 값들의 순서화된 리스트 형식 - 여러 가지 언어들에서 array, list로 실현되었음 
    - JSON 라이브러리 - Jackson
        - High-Performance JSON Processor!
        - JSON 형태를 Java 객체로, Java 객체를 JSON 형태로 변환해주는 JAVA 용 JSON 라이브러리 
- REST 클라이언트
    - Postman : REST API 테스트하는 Chrome 확장 프로그램 
    - 웹 서비스 테스는 REST 클랑이언트 툴인 Postman을 통해서 가능함
- 스프링 REST 어플리케이션은 Layer Architecture로 작성되고, @Controller가 최초로 응답을 받고 @Service를 통해 기능을 수행함
- 각 레이어는 각각의 R & R를 가지며 Controller 단은 클라이언트의 요청을 분석해서 Service 단으로 넘겨주는 역할을 수행함 

# API Security and JWT
- 어플리케이션 보안은 인증과 인가(권한)로 구분되며, 스프링 시큐리티에서 지원함 
- Spring Security
    - 스프링 시큐리티
        - 강력한 인증과 권환 프레임워크
        - REST API를 인증되고 권한이 있는 요청에만 허락해줌 
    - JWT
        - 보안(인증과 권한)에 많이 사용됨
        - JWT 토큰 형태로 사용됨
            - URL-safe, 웹브라우저 호환, SSO 지원 
        - JWT 웹 토큰 방식은 인증을 토큰이라는 클라이언트에게 할됭되는 스트링을 사용하는 것이며, 웹 표준으로 많은 서비스에서 사용이 늘어나고 있음 
    - 주요 인증 방식
        - 로그인 기반 인증(크리덴셜 기반 인증)
            - Credential-based authentication
            - 토큰 기반 인증
        - 인증정보를 다른 어플리케이션으로 전달
            - 제 3자가 인증을 처리하는 방식
            - OAuth2
            - 페이스북/구글 같은 소셜 계정들을 이용하여 로그인 
        - 2단계 인증
            - Two-factor authentication
        - 하드웨어 인증
            - Hardware authentication 
    - 서버 기반 인증 시스템 문제점 
        - 세션
            - 유저가 인증할 때 이 기록을 서버에 저장
            - 메모리에 저장 혹은 데이터베이스 시스템에 저장
            - 유저의 수(동시 접속)가 많으면 서버나 DB에 부하 
        - 확장성
            - 클러스터링 구성 시 세션 정보도 같이 공유해야 함 
            - 서버 구성이 복잡해짐
        - CORS(Cross-Origin Resource Sharing)
            - 쿠키를 여러 도메인에서 관리하는 것이 번거로움 
    - 토큰 기반 인증 시스템 작동 원리
        - 작동 원리
            - 유저가 아이디와 비밀번호로 로그인 수행
            - 서버측에서 해당 정보 검증
            - 계정정보가 정확하다면 서버측에서 유저에서 signed 토큰을 발급
            - 클라이언트에서는 토큰을 저장해 두고 요청마다 토큰을 서버에 함께 전달
            - 서버에서 토큰을 검증하고 요청에 응답
            - 토큰은 HTTP 헤더에 포함시켜서 전달 
        - 토큰의 장점
            - 무상태(Stateless) 이며 확장성(SCalability)이 있음 
            - 보안성 
                - 쿠키를 사용하지 않음
                - 토큰환경에서도 취약점은 존재함 
            - Extensibility
                - 서버 확장이 아닌 기능 확장 가능 
            - 여러 플랫폼 및 도메인
                - CROS - 아무 도메인에서나 토큰만 유효하면 요청이 정상적으로 처리됨
            - 웹 표준 기반
                - JWT - 토큰 기반 인증 시스템 구현체(RFC 7519)
        - JSON Web Token
            - JWT 특징
                - 웹 표준으로 다양한 프로그래밍 언어에서 지원
                - Self-contained - 필요한 모든 정보를 자체적으로 가지고 있음 
                - 웹 서버의 경우 HTTP 헤더에 넣어서 전달 또는 URL 파라미터로 전달 가능 
            - JWT 사용되는 상황
                - 회원인증
                - 정보 교환 
            - JWT 구조
                - JWT는 .을 구분자로 3가지 문자열로 구성
                - aaaaa(헤더).bbbbb(내용,payload).ccccc(서명,signature)
                - 헤더 - 두 가지 정보를 포함
                    - typ: 토큰의 타입을 지정(JWT)
                    - alg: 해싱 알고리즘 지정(HMAC SHA256, RSA ...)
                - 정보(payload)
                    - 토큰에 담을 정보가 포함(클레임이라고 함, name/value 쌍으로 구성)
                    - 클레임(claim)의 세 분류
                        - 등록된(registered) 클레임 - iss, sub, aud, exp, nbf, sat, jti
                        - 공개(public) 클레임 - 충돌 방지 이름이 필요(주로 URI 형식으로 네이밍)
                        - 비공개(private) 클레임 - 클라이언트와 서버 간의 협의 하에 사용되는 클레임 이름들 
                - 서명(signature)
                    - 헤더의 인코딩 값과 정보의 인코딩 값을 합친 후 주어진 비밀키로 해쉬하여 생성 

# RESTful 웹서비스 테스트
- JUnit
    - JUnit : Java에서 독립된 단위테스트(Unit Test)를 지원해주는 프레임워크
    - 단위테스트(Unit Test)
        - 소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차, 즉 모든 함수와 메소드에 대한 테스트 케이스(Test case)를 작성하는 절차
        - JUnit은 보이지 않고 숨겨진 단위 테스트를 끌어내며 정형화시켜 단위테스트를 쉽게 해주는 테스트 지원 프레임워크 
- 스프링에서 기본적으로 사용하는 빌드 툴인 메이븐은 설계시 부터 테스트를 중요하게 생각하고 설계되었음
- JUnit4를 사용하여 단위테스트를 수행하고 Spring-test 라이브러리를 사용하여 자동으로 스프링컨테이너를 로딩하고 @Autowired를 사용하여 빈을 테스트 할 수 있음 

# AOP - Aspect Oriented Programming
- AOP의 개요와 용어
    - 핵심기능과 부가기능
        - 업무(Biz) 로직을 포함하는 기능을 핵심 기능
        - 핵심기능을 도와주는 부가적인 기능(로깅, 보안 등)
        - 핵심기능에서 부가기능을 분리해서 모듈화하는 프로그래밍 기법 - AOP
- 부가기능에 해당하는 코드인 어드바이스와 적용한 위치를 문법적으로 표현한 포인트컷을 합친 개념이 애스팩트
- 스프링 AOP는 메소드 조인 포인트만 지원하여 간단하게 쉽게 AOP를 구현할 수 있음 
- 포인트컷의 문법을 이용하여 원하는 위치에 부가기능 어드바이스를 추가할 수 있음 
- Advice는 타깃객체 이전과 이후 그리고 이전/이후 모두에 적용가능 함 

# 로그와 예외처리
- 로깅 시스템은 여러가지로 사용하지만 SLF4J를 로깅 인터페이스로 해서 Logback을 스프링5(스프링부트2)의 구현체로 많이 사용함 
- Spring boot Logging system
    - Logback framework사용
    - 로깅 레벨
        - TRACE
        - INFO
        - ERROR
        - DEBUG
        - WARN 
- REST 어플리케이션 예외처리
    - 스프링 예외처리 방법
        - 전역처리 Global level - @ControllerAdvice
            - 스프링 예외처리는 주로 컨트롤러 단에서 처리됨
            - 컨트롤러처럼 동작하며 모든 예외를 처리할 수 있는 컨트롤러 
        - 컨트롤러단에서 처리 Controller level - @ExceptionHandler
        - 메소드 단위 처리 Method level - try/catch
