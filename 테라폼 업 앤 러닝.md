# 서평 
- 이 책은 코드를 관리하는 모든 사람을 위한 것으로 시스템 관리자, 운영 엔지니어, 릴리스 엔지니어, 사이트 안전성 엔지니어, 데브옵스 엔지니어, 인프라 개발자, 풀스택 개발자, 엔지니어링 관리자 및 CTO가 포함됩니다.
- 이 책의 목표는 왜 테라폼을 사용하려 하는지, 워크플로에 어떻게 적용할 것인지, 그리고 어떤 모범 사례가 가장 잘 작동하는지에 대해 논의함으로써 테라폼을 제대로 운영할 수 있도록 하는 것입니다.

# 왜 테라폼인가?
- 테라폼은 해시코프사에서 만든 오픈 소스 도구. 테라폼은 간단한 선언적 언어를 사용하여 인프라를 코드로 정의함.(IaC) 몇 가지 명령을 사용하여 아마존 웹 서비스, 마이크로소프트 애저, 구글 클라우드 플랫폼, 디지털오션 같은 다양한 퍼블릭 클라우드 공급자와 오픈스택, VM웨어 같은 프라이빗 클라우드와 가상화 플랫폼에서 해당 인프라를 배포 및 관리하게 함
- 데브옵스의 등장
  - 수많은 운영팀들이 하드웨어에 많은 돈과 노력을 투자하는 대신 셰프(Chef), 퍼핏(Puppet), 테라폼(Terraform), 도커(Docker) 같은 도구를 사용하여 소프트웨어 작업에 더 많은 시간을 들이고 있음. 시스템 관리자가 서버를 설치하고 네트워크 케이블 설치 작업을 하는 대신에 코드를 작성하는 것
  - 데브옵스는 소프트웨어를 효율적으로 전달하는 프로세스다.
  - 지속적으로 코드를 통합하고 항상 배포 가능한 상태로 유지함
  - 데브옵스의 4가지 핵심 가치는 문화, 자동화, 측정, 공유로 줄여서 CAMS라 함
- 코드형 인프라란?
  - IaC란 코드를 작성 및 실행하여 인프라를 생성, 배포, 수정, 정리하는 것을 말함
  - 데브옵스의 핵심은 서버, 데이터베이스, 네트워크, 로그 파일, 애플리케이션 구성, 문서, 자동화된 테스트, 배포 프로세스 등 거의 모든 것을 코드로 관리할 수 있다는 것
  - 코드형 인프라 도구의 다섯 가지 범주
    - 애드혹 스크립트
      - 수행할 작업을 단계별로 나누고 배시, 루비, 파이썬 등 선호하는 언어를 사용하여 각 단계를 코드로 정의하고 작성된 스크립트를 서버에서 수동으로 실행하는 것 
    - 구성 관리 도구
      - 셰프, 퍼핏, 앤서블, 솔트스택 등은 모두 구성 관리 도구로써 대상 서버에 소프트웨어를 설치하고 관리하도록 설계되어 있음. 애드혹 스크립트를 사용할 때와 다른 여러 가지 장점이 있음
      - 코딩 규칙
        - 앤서블은 문서화, 파일 레이아웃, 명확하게 이름 붙여진 매개 변수, 시크릿 관리 등을 포함하는 일관되고 예측 가능한 구조를 제공함
      - 멱등성 : 실행 횟수에 관계없이 올바르게 동작하는 코드를 멱등성을 가진 코드
      - 분산형 구조 : 애드혹 스크립트는 단일 로컬 머신에서만 실행되도록 설계됨. 앤서블과 같은 구성 관리 도구는 원격의 수많은 서버를 관리하기 위해 특별히 설계된 것 
    - 서버 템플릿 도구
      - 구성 관리 도구의 대안으로 최근에 도커, 패커(Packer), 베이그런ㄷ트(Vagrant)와 같은 서버 템플릿 도구도 인기가 높아지고 있음.
      - 여러 서버를 시작하고 각각 동일한 코드를 실행하여 서버를 구성하는 기존 방식과 다르게, 서버 템플릿 도구는 운영 체제, 소프트웨어, 파일 및 기타 필요한 모든 내용을 포함하고 있는 스냅숏으로 이미지를 생성함
      - 가상 머신
        - 호스트 시스템 및 다른 가상 머신 이미지와는 완전히 분리되어 개인 컴퓨터, QA 서버, 실제 운영 환경 등 모든 환경에서 정확히 동일한 방식으로 실행됨. 단점은 모든 하드웨어를 가상화하고 다른 VM과도 완전히 분리했기 때문에 VM마다 별도의 CPU, 메모리, 리소스가 할당되는 오버헤드가 발생하는 것
      - 컨테이너
        - 도커, 코어OS의 rkt 또는 크라이오와 같은 컨테이너 엔진을 실행하여 격리된 프로세스, 메모리, 마운트 지점, 네트워킹을 만듬. 호스트 시스템 및 다른 컨테이너와는 격리되어 개인 컴퓨터, QA 서버, 실제 운영 환경 등 모든 환경에서 정확히 동일하게 실행된다는 것이 장점.
        - 단점은 단일 서버에서 실행되는 모든 컨테이너가 해당 서버의 OS 커널과 하드웨어를 공유하므로 VM을 사용하는 것만큼의 격리 및 보안 수준을 달성하기가 훨씬 어려울 수 있다는 것. 커널과 하드웨어가 공유되므로 밀리세컨드 단위로 부팅할 수 있으며, CPU 또는 메모리에 대한 오버헤드가 거의 없음
      - 서버 템플릿 도구들의 목적은 약간씩 다름
        - 패커는 일반적으로 프로덕션 AWS 계정에서 실행하는 AMI 처럼 프로덕션 서버에서 직접 실행하는 이미지를 생성하는 데 사용됨
        - 베이그런트는 일반적으로 macOS나 Windows 랩톱에서 실행되는 버추얼박스 이미지와 같이 개발 컴퓨터에서 실행되는 이미지를 만드는 데 사용됨.
        - 도커는 일반적으로 개별 응용 프로그램의 이미지를 만드는 데 사용됨
    - 오케스트레이션 도구
      - 실제 사용 환경에서 수행할 방법 필요함
        - VM과 컨테이너를 하드웨어에 효율적으로 배포하기
        - 롤링 배포, 블루-그린 배포, 카나리 배포 전략을 사용하여 기존의 VM이나 컨테이너를 효율적으로 업데이트하거나 롤백하기
        - VM과 컨테이너의 상태를 모니터링하고 비정상적인 부분을 자동으로 대체하기(자동 복구)
        - 발생하는 트래픽에 따라 VM과 컨테이너의 수를 늘리거나 줄이기(자동 확장)
        - VM과 컨테이너의 트래픽을 분산하기(로드 밸런싱)
        - 서로 다른 네트워크에 있더라도 VM과 컨테이너가 서로 식별하고 통신할 수 있게 하기(서비스 검색)
      - 위 작업 들을 처리하기 위해 쿠버네티스, 마라톤/메소스, 아마존 엘라스틱 컨테이너 서비스, 도커 스웜, 그리고 노마드 같은 오케스트레이션 도구가 필요함 
    - 프로비전 도구
      - 구성 관리, 서버 템플릿 및 오케스트레이션 도구가 각 서버에서 실행되는 코드를 정의한다면, 테라폼, 크라우드 포메이션, 오픈스택 하트와 같은 프로비전 도구는 서버 자체를 생성함
      - 데이터베이스, 캐시, 로드 밸런서, 큐, 모니터링, 서브넷 구성, 방화벽 설정, 라우팅 규칙 설정, SSL(Secure Sockets Layer) 인증서 등 인프라에 관한 거의 모든 부분을 프로비저닝할 수 있음 
- 코드형 인프라의 장점
  - 자급식 배포(Self-service) : 인프라를 코드로 정의하면 전체 배포 프로세스를 자동화할 수 있으며 개발자는 필요할 때마다 자체적으로 배포를 진행할 수 있음
  - 속도와 안정성(Speed and safety) : 자동화된 프로세스는 일관되고 반복 가능하며 수동으로 진행했을 때보다 오류가 적게 발생하기 때문에 더 안전함
  - 문서화(Documentation) : 시스템 관리자 조직만 인프라에 관한 정보를 독점하는 것이 아니라 누구나 읽을 수 있는 소스 파일로 인프라 상태를 나타낼 수 있음
  - 버전 관리 : 인프라의 변경 내용이 모두 기록된 코드형 인프라 소스 파일을 저장할 수 있으므로 버전을 쉽게 관리할 수 있음
  - 유효성 검증(Validation) : 인프라 상태가 코드로 정의되어 있으면 코드가 변경될 때마다 검증을 수행하고 일련의 자동화된 테스트를 실행할 수 있으며, 정적 분석(static analysis) 프로그램에 코드를 전달하여 오류 발생 위험을 줄일 수 있음
  - 재사용성 : 인프라를 재사용 가능한 모듈로 패키징할 수 있으므로 모든 제품을 매번 처음부터 배포하는 대신 문서화되고 검증된 모듈로 일관되게 배포할 수 있음 
- 테라폼의 작동 방식
  - 해시 코프사가 GO 언어로 개발한 오픈 소스 도구. 운영 체제마다 바이너리 파일이 존재하는데 Go 코드는 하나의 바이너리 파일로 컴파일되며 terraform이라는 명령어로 실행할 수 있음
  - 투명한 이식성은 예를 들어 AWS에서 생성한 서버, 데이터베이스, 로드 밸런서 등의 인프라를 애저나 구글 클라우드 같은 다른 클라우드 환경에서도 똑같이 생성할 수 있는가 하는 것
- 테라폼과 다른 코드형 인프라 도구 비교
  - 절차적 언어 vs 선언적 언어
    - 셰프와 앤서블은 원하는 최종 상태를 달성하는 방법을 단계별로 지정하는 절차적 스타일 코드를 권장함
    - 테라폼, 클라우드포메이션, 솔트스택, 퍼핏, 오픈스택 히트는 모두 원하는 최종 상태를 지정하는 선언적 방식의 코드를 권장함
    - 선언적 언어(declarative language)란 구현하려는 최종 상태를 지정하는 코드를 말하며 이때 코드형 인프라 자체는 그러한 최종 상태를 어떻게 구현할 것인지 계산하는 역할을 함
    - 코드형 인프라 도구의 주요 문제
      - 절차적 코드는 인프라의 마지막 상태 정보를 기록하고 있지 않음
      - 절차적 코드 재사용 가능성ㅇ르 제한함
  - 마스터 서버 유무
    - 앤서블, 클라우드포메이션, 오픈스택 히트, 테라폼은 기본적으로 마스터가 없는 도구. 일부 서버는 마스터 서버에 의존할 수 있지만 이미 사용 중인 인프라의 일부이며 관리해야 할 추가적인 요소가 아님
  - 에이전트 유무
    - 앤서블, 클라우드포메이션, 오픈스택 히트, 테라폼은 추가적인 에이전트를 설치할 필요가 없음 
  - 커뮤니티 규모와 활성화
    - 커뮤니티는 프로젝트에 참여하는 사람 수, 사용 가능한 플러그인 수, 통합 및 확장 프로그램 수, 블로그 게시물, 스택 오버플로우에 게시된 질문 같은 온라인 도움말을 찾는 방법 또는 직원이나 컨설턴트와 같이 여러분에게 도움을 줄 누군가를 쉽게 채용할 수 있는지 등에 영향을 줌
  - 성숙한 기술 vs 최첨단 기술
    - 테라폼은 이 표에 나온 코드형 인프라 도구들 중 가장 최근에 나온 것
    - 여전히 1.0.0 이전의 버전이므로 안정적이지 않고 이전 버전과 호환되는 API를 보장하지 않으며, 대부분 사소한 것들이기는 해도 버그가 존재할 수 있음. 테라폼의 가장 큰 약점 

# 테라폼
- 단일 웹 서버 배포
  - 비지박스라는 도구로 포트 8080에서 웹 서버를 실행하여 해당 파일을 제공함. Busybox 명령을 nohub과 &로 래핑하여, 배시 스크립트가 종료되더라도 웹 서버가 백그라운드에 영구적으로 실행되도록 함
  - <<-EOF 및 EOF는 테라폼의 히어닥(heredoc) 구문을 이용해 줄 바꿈 문자를 삽입하지 않고도 여러 줄로 된 코드를 작성할 수 있음
  - CIDR 블록 0.0.0.0/0(어디에서든)에서 8080포트에 들어오는 TCP 요청을 승인하도록 지정함. CIDR 블록은 IP 주소 범위를 지정하는 간단한 방법. 10.0.0.0/24의 CIDR 블록은 10.0.0.0과 10.0.0.255 사이의 모든 IP 주소를 나타냄. CIDR 블록 0.0.0.0/0은 가능한 모든 IP 주소를 포함하는 IP 주소 범위이므로 이 보안 그룹은 모든 IP의 8080으로 들어오는 요청을 허용함 
- 웹 서버 클러스터 배포
  - 실제 운영 환경에서 서버가 하나뿐인 경우에는 이것이 단일 장애점이 될 수 있음. 하나뿐인 서버가 충돌하거나 트래픽 과부하가 발생하면 사용자는 사이트에 액세스 할 수 없게 됨
  - 이를 해결하려면 단일 서버가 아니라 서버 클러스터를 구성해서 트래픽을 분산시키고, 트래픽 양에 따라 클러스터의 크기를 늘리거나 줄여야 함. 여러 대의 서버를 수동으로 관리하려면 손이 많이 감
  - 오토스케일링 그룹(ASG)을 사용하여 해결할 수 있음. ASG는 EC2 인스턴스 클러스터 시작, 각 인스턴스 상태 모니터링, 실패한 인스턴스 교체, 로드에 따른 클러스터 사이즈 조정 등 많은 작업을 자동으로 처리함 
- 로드밸런서 배포
  - 각각 고유한 IP 주소를 가진 서버가 여러 개 있지만 사용자에게는 일반적으로 하나의 IP 주소를 제공해야 하기 때문. 이 문제를 해결하는 한 가지 방법은 로드밸런서를 배포하여 서버 전체에 트래픽을 분산시키고 모든 사용자에게 로드밸런서 IP(실제로는 DNS 이름)를 제공하는 것
  - 가용성과 확장성이 뛰어난 로드 밸런서를 생성하는 데는 많은 작업이 필요함. 아마존 엘라스틱 로드 밸런서(ELB) 서비스를 사용하여 AWS가 이를 처리하도록 할 수 있음
- > terraform destory : 테라폼은 생성한 리소스를 추적하기 때문에 destroy 명령어를 실행해 간단히 정리할 수 있음 , destroy 명령어는 실행 취소(undo)를 할 수 없기 때문에 실제 운영 환경에서는 주의해서 실행해야 함
- 코드형 인프라의 장점은 리소스의 모든 정보가 코드로 캡처되므로 언제든지 terraform apply 명령어를 사용하여 모든 리소스를 다시 생성할 수 있다는 것. 인프라의 이력을 추적할 수 있도록 최신 변경 사항을 깃에 저장할 것을 권함

# 테라폼 상태 관리하기
- 테라폼 상태란?
  - 테라폼을 실행할 때마다 테라폼은 생성한 인프라에 대한 정보를 테라폼 상태 파일에 기록함
  - 구성 파일(.tf)의 테라폼 리소스가 실제 리소스의 표현으로 매핑되는 내용을 기록하는 사용자 정의 JSON 형식이 포함되어 있음
  - 다이나모DB : 아마존 분산형 키-값 저장소. 분산 잠금 시스템에 필요한 강력한 읽기 일관성 및 조건부 쓰기를 지원함
- 테라폼 백엔드의 단점
  - 테라폼을 사용하여 테라폼 사앹를 저장할 S3 버킷을 만드는 것은 닭이 먼저인지 달걀이 먼저인지 묻는 것과 같음
  - backend 블록에서는 변수나 참조를 사용할 수 없다는 점. S3 버킷 이름, 리전, 다이나모DB 테이블 이름 등을 모두 테라폼 모듈에 수동으로 복사해서 붙여넣어야 함
  - 유일한 해결책은 부분 구성(partial configuration)의 장점을 이용하는 것. 테라폼 코드의 backend 구성에서 특정 매개 변수를 생략하고 대신 terraform init를 호출할 때 -backend-config 인수를 통해 매개 변수를 전달하는 것
  - 테라폼은 몇 가지 단점을 보완해주는 오픈 소스 두구인 테라그런트(Terragrunt)를 사용하는 것. 테라그런트는 버킷, 이름, 리전, 다이나모DB 테이블 이름 같은 모든 기본 backend 구성을 반복하지 않도록 도와줌
- 테라폼 프로젝트의 파일 레이아웃
  - stage : 테스트 환경과 같은 사전 프로덕션 워크로드 환경
  - prod : 사용자용 맵 같은 프로덕션 워크로드 환경
  - mgmt : 베스천 호스트, 젠킨스와 같은 데브옵스 도구 환경
  - global : S3, IAM과 같이 모든 환경에서 사용되는 리소스를 배치할 수 있는 장소
  - vpc : 해당 환경을 위한 네트워크 토폴로지
  - services : 루비 온 레일즈 프런트엔드 또는 스칼라 백엔드와 같이 해당 환경에서 서비스되는 애플리케이션 또는 마이크로서비스, 각 맵은 자체 폴더에 위치하여 다른 모든 앱과 분리할 수 있음
  - data-storage: MySQL 또는 레디스와 같은 해당 환경에서 실행할 데이터 저장소. 각 데이터 저장소는 자체 폴더에 상주하여 다른 모든 데이터 저장소와 분리할 수 있음
  - variables.tf : 입력 변수
  - outputs.tf : 출력 변수
  - main.tf : 리소스
- terraform_remote_state 데이터 소스
  - terraform_remote_state 데이터 소스를 사용하면 다른 테라폼 구성 세트에 완전한 읽기 전용 방식으로 저장된 테라폼 상태 파일을 가져올 수 있음

# 테라폼 모듈로 재사용 가능한 인프라 생성하기
- 팀의 내부 테스트(스테이징)를 위한 환경이고 다른 하나는 실제 사용자가 액세스(프로덕션) 하기 위한 환경. 이론상 두 환경은 거의 동일하지만 비용을 절약하기 위해 스테이징 환경에서 좀 더 적은 서버 또는 더 작은 서버로 테스트할 수 있음
- 테라폼 코드를 적어도 2개 리포지터리에 분산하는 것
  - 모듈 : 이 리포지터리는 재사용 가능한 모듈을 정의함. 각 모듈을 인프라의 특정 부분을 정의하는 청사진이라 생각
  - 라이브(live) : 이 리포지터리는 스테이징, 프로덕션, 관리 등 각 환경에서 실행 중인 인프라를 정의함. 이것을 모듈 리포지터리의 청사진에서 구축한 집이라고 생각하기
- 모듈에서 코드형 인프라르 정의하면 이점
  - 다양한 소프트웨어 엔지니어링 모범 사례를 인프라에 적용할 수 있음
  - 코드 리뷰 및 자동화된 테스트를 통해 모듈의 각 변경 사항을 확인할 수 있음
  - 각 모듈에 버전을 지정하여 배포할 수 있음.
  - 다른 환경에서 다른 버전의 모듈을 안전하게 사용해보고 문제가 발생하면 이전 버전으로 롤백할 수 있음

# 테라폼의 팁과 요령 : 반복문, if문, 배포 및 주의사항
- 반복문
  - count 매개 변수 : 리소스를 반복
  - for_each 표현식 : 리소스 내에서 및 인라인 블록을 반복
  - for 표현식 : 리스트와 맵을 반복
  - for 문자열 지시어 : 문자열 내에서 리스트와 맵을 반복
  - for_each 표현식을 사용한 반복문 처리
    - for_each 표현식을 사용하면 리스트, 집합, 맵을 사용하여 전체 리소스의 여러 복사본 또는 리소스 내 인라인 블록의 여러 복사본을 생성할 수 있음
