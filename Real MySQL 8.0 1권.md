# 서평

# 소개
- HBase와 MongoDB는 특정 유스케이스에 적합한 DBMS인 반면, MySQL 서버와 같은 RDBMS는 범용 DBMS 영역에 속함. 어떤 서비스를 개발하든 초기에는 범용 DBMS를 선택하고, 사용량이나 데이터의 크기가 커지면 일부 도메인 또는 테이블의 데이터만 전용 DBMS로 이전해서 확장하는 형태를 대부분 회사에서 선택하고 있음 
- MySQL 서버가 견고하게 자리잡고 있음, 다른 DBMS보다 MySQL 서버의 노력과 시간 투자 대비 효율이 가장 높다는 것을 의미함, 서비스 개발자라면 MySQL 서버를 이해하기 위해서 시간을 투자해야 하는 이유 
- ORM은 DBMS와의 인터랙션을 블랙박스로 만들어 버리기 때문에 ORM 도구가 DBMS로 어떤 쿼리르 실행하는지를 알기 어려움. ORM이 최적은 아니어도 최악의 쿼리를 만들어내는 경우를 회피하기 위해 서비스 개발자는 RDBMS와 쿼리 처리 방식을 이해할 필요가 있음 
- 어떤 DBMS를 사용해야 할지 모르겠습니다. 어떤 DBMS가 좋은가요? 저자는 항상 자기가 가장 잘 활용할 수 있는 DBMS가 가장 좋은 DBMS입니다.라고 답변함. 안정성, 성능과 기능, 커뮤니티나 인지도를 고려하기 

# 설치와 설정 
- MySQL 서버가 설치된 디렉터리는 /usr/local/mysql이며, 하위의 각 디렉터리 정보
  - bin : MySQL 서버와 클라이언트 프로그램. 유틸리티를 위한 디렉터리
  - data : 로그 파일과 데이터 파일들이 저장되는 디렉터리
  - include : C/C++ 헤더 파일들이 저장되는 디렉터리
  - lib : 라이브러리 파일들이 저장된 디렉터리
  - share : 다양한 지원 파일들이 저장돼 있으며, 에러 메시지나 샘플 설정 파일(my.cnf)이 있는 디렉터리 
- MySQL 서버의 시작과 종료
  - > mysqld --defaults-file=/etc/my.cnf --initalize-insecure
    - mysqld 명령에 --initialize-insecure 옵션을 사용하면, 필요한 초기 데이터 파일과 로그 파일들을 생성하고 마지막으로 비밀번호가 없는 관리자 계정인 root 유저를 생성함
    - 비밀번호를 가진 관리자 계정을 생성하고자 한다면 다음과 같이 --initialize 옵션을 사용하면 됨. --initialize 옵션을 사용하면 생성된 관리자 계정의 비밀번호를 에러 로그 파일로 기록함 
  - systemctl 유틸리티를 이용해 MySQL을 기동하거나 종료하는 것이 가능함 
  - > SHUTDOWN;
    - 원격으로 MySQL 서버를 셧다운하려면 MySQL 서버에 로그인한 상태에서 SHUTDOWN 명령을 실행하면 됨 
    - 클린 셧다운(Clean shutdown) : 모든 커밋된 데이터를 데이터 파일에 적용하고 종료하는 것 , 클린 셧다운으로 종료되면 다시 MySQL 서버가 기동할 때 별도의 트랜잭션 복구 과정을 진행하지 않기 때문에 빠르게 시작할 수 있음 
  - 서버 연결 테스트
    - telnet 명령이나 nc(Netcat) 명령을 이용해 원격지 MySQL 서버가 응답 가능한 상태인지 확인해볼 수 있음 
    - Telnet과 Netcat 프로그램 모두 MySQL 서버로 접속해서 MySQL 서버가 보내준 메시지를 화면에 출력하는 것을 살펴볼 수 있음 
    - 만약 Telnet이나 Netcat 프로그램이 서버의 버전 정보를 정상적으로 출력하는 상태에서도 응용프로그램이 MySQL 서버에 접속하지 못한다면 이는 MySQL 서버의 계정 비밀번호가 일치하지 않거나 MySQL 서버 계정의 host 부분이 허용되지 않은 경우일 가능성이 높음 
- MySQL 서버 업그레이드
  - 인플레이스 업그레이드(In-Place Upgrade) : MySQL 서버의 데이터 파일을 그대로 두고 업그레이드하는 방법
    - 여러 가지 제약 사항이 있지만 업그레이드 시간을 크게 단축할 수 있음 
  - 논리적 업그레이드(Logical Upgrade) : mysqldump 도구 등을 이용해 MySQL 서버의 데이터를 SQL 문장이나 텍스트 파일로 덤프한 후, 새로 업그레이드된 버전의 MySQL 서버에서 덤프된 데이터를 적재하는 방법 
    - 버전 간 제약 사항이 거의 없지만 업그레이드 시간이 매우 많이 소요될 수 있음 
  - --upgrade 파라미터로 MiNIMAL과 FORCE의 차이는 서버 업그레이드 작업을 실행할지 여부, MINIMAL의 경우 서버 업그레이드를 건너뛰지만, FORCE의 경우 서버 업그레이드를 강제로 실행하게 됨. FORCE 옵션은 MySQL 서버의 시스템 테이블 구조가 잘못 변경됐거나 손상된 경우에 사용하면 됨 
  - 일반적으로 MySQL 서버는 단 하나의 설정 파일을 사용하는데, 리눅스를 포함한 유닉스 계열에서는 my.cnf라는 이름을 사용하고, 윈도우 계열에서는 my.ini라는 이름을 사용함 
- MySQL 시스템 변수의 특징
  - MySQL 서버는 기동하면서 설정 파일의 내용을 읽어 메모리나 작동 방식을 초기화하고, 접속된 사용자를 제어하기 위해 이러한 값을 별도로 저장해 둠, MySQL 서버에서는 이렇게 저장된 값을 시스템 변수(System Variables)라고 함, SHOW VARIABLES 또는 SHOW GLOBAL VARIABLES라는 명령으로 확인할 수 있음 
  - 시스템 변수가 가지는 5가지 속성
    - Cmd-Line : MySQL 서버의 명령행 인자로 설정될 수 있는지 여부를 나타냄 
    - Option file : MySQL의 설정 파일인 my.cnf(또는 my.ini)로 제어할 수 있는지 여부를 나타냄
    - System Var : 시스템 변수인지 아닌지를 나타냄 
    - Var Scope : 시스템 변수의 적용 범위를 나타냄. 이 시스템 변수가 영향을 미치는 곳이 MySQL 서버 전체(Global, 글로벌 또는 전역)를 대상으로 하는지, 아니면 MySQL 서버와 클라이언트 커넥션(Session, 세션 또는 커넥션)만인지 구분함 
    - Dynamic : 시스템 변수가 동적인지 정적인지 구분하는 변수
- 글로벌 변수와 세션 변수
  - 글로벌 범위의 시스템 변수는 하나의 MySQL 서버 인스턴스에서 전체적으로 영향을 미치는 시스템 변수를 의미하며, 주로 MySQL 서버 자체에 관련된 설정일 때가 많음. MySQL 서버에서 단 하나만 존재하는 InnoDB 버퍼 풀 크기(innodb_buffer_pool_size) 또는 MyISAM의 키 캐시 크기(key_buffer_size)등이 가장 대표적인 글로벌 영역의 시스템 변수
  - 세션 범위의 시스템 변수는 MySQL 클라이언트가 MySQL 서버에 접속할 때 기본으로 부여하는 옵션의 기본값을 제어하는 데 사용됨, 기본값은 글로벌 시스템 변수이며, 각 클라이언트가 가지는 값이 세션 시스템 변수. 각 클라이언트에서 쿼리 단위로 자동 커밋을 수행할지 여부를 결정하는 autocommit 변수가 대표적인 예 
- SET PERSIST
  - MySQL 서버의 max_connections라는 시스템 변수, MySQL 서버로 접속할 수 있는 최대 커넥션의 개수를 제한하는 동적 시스템 변수 
  - SET PERSIST 명령으로 시스템 변수를 변경하면 MySQL 서버는 변경된 값을 즉시 적용함과 동시에 별도의 설정 파일(mysqld-auto.cnf)에 변경 내용을 추가로 기록해 둠. MySQL 서버가 다시 시작될 때 기본 설정 파일(my.cnf)뿐만 아니라 자동 생성된 mysqld-auto.cnf 파일을 같이 참조해서 시스템 변수에 적용함. SET_PERSIST 명령을 사용하면 MySQL 서버 설정 파일(my.cnf)에 변경 내용을 수동으로 기록하지 않아도 자동으로 영구 변경이 되는 것 
  - SET PERSIST 명령은 세션 변수에는 적용되지 않으며, SET_PERSIST 명령으로 시스템 변수를 변경하면 MySQL 서버는 자동으로 GLOBAL 시스템 변수의 변경으로 인식하고 변경함. 현재 실행 중인 MySQL 서버에는 변경 내용을 적용하지 않고 다음 재시작을 위해 mysqld-auto.cnf 파일에만 변경 내용을 기록해두고자 한다면 SET_PERSIST_ONLY 명령을 사용하면 됨 
  - SET PERSIST_ONLY 명령은 정적인 변수의 값을 영구적으로 변경하고자 할 때도 사용할 수 있음. SET ERSIST 명령은 현재 실행 중인 MySQL 서버에서 동적인 변수들의 값을 변경함과 동시에 mysqld-auto.cnf 파일에도 기록하는 용도, 정적인 변수는 실행 중인 MySQL 서버에서 변경할 수 없음. innodb_doublewrite는 정적 변수로, MySQL 서버가 재시작될 때만 변경될 수 있음. 정적 변수를 mysqld-auto.cnf파일에 기록해두고자 할 때 SET PERSIST_ONLY 명령을 활용하면 됨 
  - SET PERSIST 명령이나 SET PERSIST_ONLY 명령으로 시스템 변수를 변경하면 JSON 포맷의 mysqld-auto.cnf파일이 생성됨. mysqld-auto.cnf 파일에는 변경된 시스템 변수의 이름과 설정값, 추가로 언제 누구에 의해 시스템 변수가 변경됐는지 등의 정보도 함께 기록됨 
  - SET PERSIST 또는 SET PERSIST_ONLY 명령으로 변경된 시스템 변수의 메타데이터는 performance_schema.variables_info 뷰와 performance_schema.persisted_variables 테이블을 통해 참조할 수도 있음 
  - mysqld-auto.cnf 파일의 내용을 삭제해야 하는 경우에는 다음과 같이 REST PERSIST 명령을 사용하는 것이 안전함 

# 사용자 및 권한
- 사용자 식별
  - MySQL의 사용자는 다른 DBMS와는 조금 다르게 사용자의 계정뿐 아니라 사용자의 접속 지점(클라이언트가 실행된 호스트명이나 도메인 또는 IP 주소)도 계정의 일부가 됨 
  - 만약 모든 외부 컴퓨터에서 접속이 가능한 사용자 계정을 생성하고 싶다면 사용자 계정의 호스트 부분을 % 문자로 대체하면 됨, % 문자는 모든 IP 또는 모든 호스트명을 의미함 
- 사용자 계정 관리
  - 계정은 SYSET_USER 권한을 가지고 있느냐에 따라 시스템 계정(System Account)과 일반 계정(Regular Account)으로 구분됨 
  - 시스템 계정은 데이터베이스 서버 관리자를 위한 계정이며, 일반 계정은 응용 프로그램이나 개발자를 위한 계정 정도로 생각하면 이해하기 쉬울 것 
  - 시스템 계정 
    - 계정 관리(계정 생성 및 삭제, 그리고 계정의 권한 부여 및 제거)
    - 다른 세션(Connection) 또는 그 세션에서 실행 중인 쿼리를 강제 종료
    - 스토어드 프로그램 생성 시 DEFINER를 타 사용자로 설정 
  - 시스템 계정과 일반 계정의 개념이 도입된 것은 DBA(데이터베이스 관리자) 계정에는 SYSTEM_USER 권한을 할당하고 일반 사용자를 위한 계정에는 SYSETM_USER 권한을 부여하지 않게 하기 위해서 
    - 사용자 : MySQL 서버를 사용하는 주체(사람 또는 응용 프로그램)
    - 계정 : MySQL 서버에 로그인하기 위한 식별자(로그인 아이디) 
  - MySQL 서버에 내장된 계정
    - 'mysql.sys'@'localhost': MySQL 8.0부터 기본으로 내장된 sys 스키마의 객체(뷰나 함수, 그리고 프로시저)들의 DEFINER로 사용되는 계정
    - 'mysql.session'@'localhost': MySQL 플러그인이 서버로 접근할 때 사용되는 계정 
    - 'mysql.infoschema'@'localhost' : information_schema에 정의된 뷰의 DEFINER로 사용되는 계정 
- 계정 생성
  - 일반적으로 많이 사용되는 옵션을 가진 CREATE USER 명령
```sql
CREATE USER 'user'@'%'
  IDENTIFIED WITH 'mysql_native_password' BY 'password'
  REQUIRE NONE
  PASSWORD EXPIRE INTERVAL 30 DAY
  ACCOUNT UNLOCK
  PASSWORD HISTORY DEFAULT
  PASSWORD REUSE INTERVAL DEFAULT
  PASSWORD REQUIRE CURRENT DEFAULT;
```
  - IDENTIFIED WITH
    - 사용자의 인증 방식과 비밀번호를 설정함. IDENTIFIED WITH 뒤에는 반드시 인증 방식(인증 플러그인의 이름)을 명시, 기본 인증 방식을 사용하고자 한다면 IDENTIFIED BY 'password' 형식으로 명시해야함 
      - Native Pluggable Authentication : 단순히 비밀번호에 대한 해시(SHA-1 알고리즘) 값을 저장해두고, 클라이언트가 보낸 값과 해시값이 일치하는지 비교하는 인증 방식
      - Caching SHA-2 Pluggable Authentication : 암호화 해시값 생성을 위해 SHA-2(256비트) 알고리즘을 사용함. Native Authentication과의 가장 큰 차이는 사용되는 암호화 해시 알고리즘 차이이며, SHA-2 Authentication은 저장된 해시값의 보안에 더 중점을 둔 알고리즘으로 이해할 수 있음 
      - PAM Pluggable Authentication : 유닉스나 리눅스 패스워드 또는 LDAP(Lightweight Directory Access Protocol) 같은 외부 인증을 사용할 수 있게 해주는 인증 방식으로, MySQL 엔터프라이즈 에디션에서만 사용 가능함 
      - LDAP Pluggable Authenticaiton : LDAP을 이용한 외부 인증을 사용할 수 있게 해주는 인증 방식으로, MySQL 엔터프라이즈 에디션에서만 사용 가능함 
    - Caching SHA-2 Authentication은 SSL/TLS 또는 RSA 키페어를 필요로 하기 때문에 기존 MySQL 5.7까지의 연결방식과는 다른 방식으로 접속해야 함. 보안 수준은 좀 낮아지겠지만 기존 버전과의 호환성을 고려한다면 Caching SHA-2 Authentication보다는 Native Authenticaiton 인증 방식으로 계정을 생성해야 할 수도 있음 
  - REQUIRE
    - MySQL 서버에 접속할 때 암호화된 SSL/TLS 채널을 사용할지 여부를 설정함. 만약 별도로 설정하지 않으면 비암호화 채널로 연결하게 됨 
  - PASSWORD EXPIRED
    - 비밀번호의 유효 기간을 설정하는 옵션, 별도로 명시하지 않으면 default_password_lifetime 시스템 변수에 저장된 기간으로 유효 기간이 설정됨 
      - PASSWORD EXPIRE : 계정 생성과 동시에 비밀번호 만료 처리 
      - PASSWORD EXPIRE NEVER : 계정 비밀번호의 만료 기간 없음 
      - PASSWORD EXPIRE DEFAULT : default_password_lifetime 시스템 변수에 저장된 기간으로 비밀번호의 유효 기간을 설정
      - PASSWORD EXPIRE INTERVAL n DAY : 비밀번호의 유효 기간을 오늘부터 n일자로 설정
  - PASSWORD HISTORY
    - 한 번 사용했던 비밀번호를 재사용하지 못하게 설정하는 옵션
      - PASSWORD HISTORY DEFAULT : password_history 시스템 변수에 저장된 개수만큼 비밀번호의 이력을 저장하며, 저장된 이력에 남아있는 비밀번호는 재사용할 수 없음 
      - PASSWORD HISTORY n : 비밀번호의 이력을 최근 n개까지만 저장하며, 저장된 이력에 남아있는 비밀번호는 재사용할 수 없음 
  - PASSWORD REUSE INTERVAL
    - 한 번 사용했던 비밀번호의 재사용 금지 기간을 설정하는 옵션, 별도로 명시하지 않으면 password_reuse_interval 시스템 변수에 저장된 기간으로 설정함 
      - PASSWORD REUSE INTERVAL DEFAULT : password_reuse_interval 변수에 저장된 기간으로 설정
      - PASSWORD REUSE INTERVAL n DAY : n일자 이후에 비밀번호를 재사용할 수 있게 설정 
  - PASSWORD REQUIRE
    - 비밀번호가 만료되어 새로운 비밀번호로 변경할 때 현재 비밀번호(변경하기 전 만료된 비밀번호)를 필요로 할지 말지를 결정하는 옵션
      - PASSWORD REQUIRE CURRENT : 비밀번호를 변경할 때 현재 비밀번호를 먼저 입력하도로 설정
      - PASSWORD REQUIRE OPTIONAL : 비밀번호를 변경할 때 현재 비밀번호를 입력하지 않아도 되도록 설정
      - PASSWORD REQUIRE DEFAULT : password_require_current 시스템 변수의 값으로 설정 
  - ACCOUNT LOCK / UNLOCK
    - 계정 생성 시 또는 ALTER USER 명령을 사용해 계정 정보를 변경할 때 계정을 사용하지 못하게 잠글지 여부를 결정함 
      - ACCOUNT LOCK : 계정을 사용하지 못하게 잠금
      - ACCOUNT UNLOCK : 잠긴 계정을 다시 사용 가능 상태로 잠금 해제 
- 비밀번호 관리
  - > INSTALL COMPONENT 'file://component_validate_password'; :validate_password 컴포넌트 설치
  - 비밀번호 정책
    - LOW : 비밀번호의 길이만 검증
    - MEDIUM : 비밀번호의 길이를 검증하며, 숫자와 대소문자, 그리고 특수문자 배합을 검증
    - STRONG : MEDIUM 레벨의 검증을 모두 수행하며, 금칙어가 포함됐는지 여부까지 검증 
  - 이중비밀번호 : 하나의 계정에 대해 2개의 비밀번호를 동시에 설정할 수 있는데, 2개의 비밀번호는 프라이머리(Primary)와 세컨더리(Secondary)로 구분됨, 최근에 설정된 비밀번호는 프라이머리 비밀번호, 이전 비밀번호는 세컨더리 비밀번호. RETAIN CURRENT PASSWORD 옵션만 추가하면 됨 
- 권한(Privilege)
  - 글로벌 권한 : 데이터베이스나 테이블 이외의 객체에 적용되는 권한
  - 객체 권한 : 데이터베이스나 테이블을 제어하는 데 필요한 권한 
  - 객체 권한은 GRANT 명령으로 권한을 부여할 때 반드시 특정 객체를 명시해야 하며, 글로벌 권한은 GRANT 명령에서 특정 객체를 명시하지 말아야함 
  - ALL(또는 ALL PRIVILEGES)은 글로벌과 객체 권한 두 가지 용도로 사용될 수 있는데, 특정 객체에 ALL 권한이 부여되면 해당 객체에 적용될 수 있는 모든 객체 권한을 부여하며, 글로벌로 ALL이 사용되면 글로벌 수준에서 가능한 모든 권한을 부여하게 됨 
  - > GRANT SUPER ON *.* TO 'user'@'localhost';
    - *.*은 모든 DB의 오브젝트(테이블과 스토어드 프로시저나 함수 등)를 포함해서 MySQL 서버 전체를 의미함 

# 아키텍처 
- MySQL 서버는 사람의 머리 역할을 담당하는 MySQL 엔진과 손발 역할을 담당하는 스토리지 엔진으로 구분할 수 있음, 손과 발의 역할을 담당하는 스토리지 엔진은 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용할 수 있음 
- MySQL 엔진 아키텍처
  - MySQL은 일반 상용 RDBMDS와 같이 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원함. MySQL 고유의 C API부터 시작해 JDBC나 ODBC, 그리고 .NET의 표준 드라이버를 제공하며, 이러한 드라이버를 이용해 C/C++, PHP, 자바, 펄, 파이썬, 루비나 .NET 및 코볼까지 모든 언어로 MySQL 서버에서 쿼리를 사용할 수 있게 지원함 
  - MySQL 엔진
    - 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룸 
  - 스토리지 엔진
    - MySQL엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고, 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은스토리지 엔진이 전담함
    - 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있음
  - 핸들러 API
    - MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러(Handler) 요청, 여기서 사용되는 API를 핸들러 API
  - MySQL 스레딩 구조
    - MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분할 수 있음 
    - 스레드 풀과 전통적인 스레드 모델의 가장 큰 차이점은 포그라운드 스레드와 커넥션의 관계, 전통적인 스레드 모델에서는 커넥션별로 포그라운드 스레드가 하나씩 생성되고 할당됨. 스레드 풀에서는 커넥션과 포그라운드 스레드는 1:1 관계가 아니라 하나의 스레드가 여러 개의 커넥션 요청을 전담함 
    - 포그라운드 스레드(크라이언트 스레드)
      - 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각  클라이언트 사용자가 요청하는 쿼리 문장을 처리함. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시(Thread cache)로 되돌아감 
      - 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리함. MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만(MyISAM도 지연된 쓰기가 있지만 일반적인 방식은 아님) InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리함 
    - 백그라운 스레드
      - InnoDB는 여러 가지 작업이 백그라운드로 처리됨
        - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
        - 로그를 디스크로 기록하는 스레드
        - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
        - 데이터를 버퍼로 읽어 오는 스레드
        - 잠금이나 데드락을 모니터링하는 스레드 
      - 쓰기 스레드(Write thread) : 로그 스레드(Log Thread)와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리
      - 사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없음 
  - 메모리 할당 및 사용 구조
    - 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당됨 
    - 글로벌 메모리 영역
      - 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당됨
      - 필요에 따라 2개이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와는 무관하며, 생성된 글로벌 영역이 N개가 하더라도 모든 스레드에 의해 공유됨 
        - 테이블 캐시
        - InnoDB 버퍼 풀
        - InnoDB 어댑티브 해시 인덱스
        - InnoDB 리두 로그 버퍼
    - 로컬 메모리 영역
      - 세션 메모리 영역, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역, 커넥션 버퍼와 정렬(소트) 버퍼 등이 있음 
      - 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 함, 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 표현함 
      - 로컬 메모리는 각 클랑이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징
      - 글로벌 메모리 영역의 크기는 주의해서 설정하지만 소트 버퍼와 같은 로컬 메모리 영역은 크게 신경 쓰지 않고 설정하는데, 최악의 경우(가능성은 희박하지만)에는 MySQL 서버가 메모리 부족으로 멈춰 버릴 수도 있으므로 적절한 메모리 공간을 설정하는 것이 중요함 
      - 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다는 점 
      - 로컬 메모리 공간은 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간도 있고(커넥션 버퍼나 결과 버퍼) 그렇지 않고 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간(소트 버퍼나 조인 버퍼)도 있음 
      - 대표적인 로컬 메모리 영역
        - 정렬 버퍼(Sort buffer)
        - 조인 버퍼
        - 바이너리 로그 캐시
        - 네트워크 버퍼
  - 플러그인 스토리지 엔진 모델
    - 대부분의 작업이 MySQL 엔진에서 처리되고, 마지막 데이터 읽기/쓰기 작업만 스토리지 엔진에 의해 처리됨 
    - 핸들러(Handler) - 사람이 핸들(운전대)을 이용해 자동차를 운전하듯이, 프로그래밍 언어에서는 어떤 기능을 호출하기 위해 사용되는 운전대와 같은 역할을 하는 객체를 핸들러(또는 핸들러 객체)라고 표현함. MySQL 서버에서 MySQL 엔진은 사람 역할을 하고 각 스토리지 엔진은 자동차 역할을 하는데, MySQL 엔진이 스토리지 엔진을 조정하기 위해 핸들러라는 것을 사용하게 됨 
    - MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다는 점만 기억하자, Handler_로 시작하는 상태 변수는 MySQL 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수라고 이해하면 됨 
  - 컴포넌트
    - 플러그인은 몇 가지 단점이 있는데 컴포넌트는 이러한 단점을 보완해서 구현함 
      - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음 
      - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨) 
      - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움 
  - 쿼리 실행 구조 
    - 쿼리 파서
      - 사용자의 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조를 만들어내는 작업을 의미함 
      - 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달함 
    - 전처리기
      - 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인함 
      - 각 토큰을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 이 단계에서 수행함 
    - 옵티마이저
      - 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당하며, DBMS의 두뇌에 해당한다고 볼 수 있음 
    - 실행 엔진
      - 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정함 
        - 1.실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
        - 2.다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
        - 3.읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
        - 4.데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
        - 5.최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김 
      - 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행함 
    - 핸들러(스토리지 엔진)
      - 핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당함 
      - 핸들러는 결국 스토리지 엔진을 의미하며, MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우에는 핸들러가 InnoDB 스토리지 엔진이 됨 
    - 쿼리 캐시
      - MySQL 서버에서 쿼리 캐시(Query Cache)는 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할을 담당함 
      - 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 매우 빠른 성능을 보임
      - 쿼리 캐시는 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두 삭제(Invalidate)해야 함, 이는 동시 처리 성능 저하를 유발함 
    - 스레드 풀
      - 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적 
      - 동시에 실행 중인 스레드들은 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능, 스케줄링 과정에서 PCU 시간을 제대로 확보하지 못하는 경우에는 쿼리 처릭리가 더 느려지는 사례도 발생할 수 있다는 점에 주의 
      - 스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드(Worker thread)를 추가할지, 아니면 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단해야 함 
  - 트랜잭션 지원 메타데이터
    - 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 함 
    - 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되며 일관되지 않은 상태로 남는 문제가 있었음, 이를 데이터베이스나 테이블이 깨졌다라고 표현함 
    - MySQL 서버가 작동하는 데 기본적으로 필요한 테이블들을 묶어서 시스템 테이블이라고 함, 대표적으로 사용자의 인증과 권한에 관련된 테이블들이 있음 
- InnoDB 스토리지 엔진 아키텍처
  - MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어남
  - 프라이머리 키에 의한 클러스터링
    - InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장됨, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻
    - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용함 
    - 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있음 
  - 외래 키 지원
    - 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레베렝서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없음 
  - MVCC(Multi Version Concurrency Control)
    - 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있음 
    - 멀티 버전이라 함은 하나의 레코드에 여러 개의 버전이 동시에 관리된다는 의미 
  - 잠금 없는 읽관된 읽기(Non-Locking Consistent Read)
    - InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행함 
    - 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능함 
  - 자동 데드락 감지
    - InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리함
    - InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료함, 이때 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 트랜잭션의 언두 로그 양, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 됨 
  - InnoDB 버퍼 풀
    - InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
    - 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 함 
      - 버퍼 풀의 구조
        - 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 LRU(Least Recently Used) 리스트와 플러시(Flush) 리시트, 그리고 프리(Free) 리스트라는 3개의 자료 구조를 관리함 
        - 프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용됨 
        - 플러시 리스트는 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(이를 더티 페이지라고 함)의 변경 시점 기준의 페이지 목록을 관리함 
        - LSN(Log Sequence Number) : 리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록할 때마다 로그 포지션은 계속 증가된 값을 갖게 됨 
        - 클리너 스레드(Cleaner Thread) : InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 동기화하는 스레드 
        - 워밍업(Warming Up) : 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태
  - 언두 로그 
    - InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업함 
    - 이렇게 백업된 데이터를 언두 로그라고 함 
      - 트랜잭션 보장 : 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구함 
      - 격리 수준 보장 : 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 함 
    - 언두 로그의 데이터의 사용 용도
      - 트랜잭션의 롤백 대비용
      - 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공함
        - 트랜잭션의 격리 수준 : 도잇에 여러 트랜잭션이 데이터를 변경하거나 조회할 때 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지를 결정하는 기준 
    - 언두 테이블스페이스 관리
      - 언두 테이블스페이스(Undo Tablespace) : 언두 로그가 저장되는 공간 
      - Undo tablespace truncate : 언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것 
      - 언두 테이블스페이스의 불필요한 공간을 잘라내는(Truncate) 방법
        - 자동 모드 : InnoDB 스토리지 엔진의 퍼지 스레드(Purge Thread)는 주기적으로 깨어나서 언두 로그 공간에서 불필요해진 언두 로그를 삭제하는 작업을 실행하는데, 이 작업을 언두 퍼지(Undo Purge)
        - 수동 모드 
  - 체인지 버퍼
    - 체인지 버퍼(Change Buffer) : 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데 이때 사용하는 임시 메모리 공간
    - 체인지 버퍼 머지 스레드(Merge thread) : 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 의미함 
  - 리두 로그 및 로그 버퍼
    - 리두 로그는 하드웨어나 소프트웨어 등 여러 가지 문제점으로 인해 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치 
    - 일부 DBMS에서는 리두로그를 WAL 로그라고도 함(Write Ahead Log의 줄임말로 데이터를 디스크에 기록하기 전에 먼저 기록되는 로그)
    - 리두 로그가 비활성화된 상태에서 MySQL 서버가 비정상적으로 종료된다면 MySQL 서버의 마지막 체크포인트 이후 시점의 데이터는 모두 복구할 수 없게 됨 
  - 어댑티브 해시 인덱스(Adaptive Hash Index)
    - 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스 
    - 사용자는 innodb_adaptive_hash_index 시스템 변수를 이용해서 어댑티브 해시 인덱스 기능을 활성화하거나 비활성화할 수 있음 
    - 어댑티브 해시 인덱스는 B-Tree 검색 시간을 줄여주기 위해 도입된 기능 
    - 해시 인덱스는 인덱스 키 값과 해당 인덱스 키 값이 저장된 데이터 페이지 주소의 쌍으로 관리됨, 인덱스 키 값은 B-Tree 인덱스의 고유번호(Id)와 B-Tree 인덱스의 실제 키 값 조합으로 생성됨 
    - 성능 향상에 크게 도움이 되지 않는 경우
      - 디스크 읽기가 많은 경우
      - 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴 검색)
      - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
    - 성능 향상에 많은 도움이 되는 경우
      - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
      - 동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
      - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우 
    - 데이터 페이지를 메모리(버퍼 풀) 내에서 접근하는 것을 더 빠르게 만드는 기능이기 때문에 데이터 페이지를 디스크에 읽어오는 경우가 빈번한 데이터베이스 서버에서는 아무런 도움이 되지 않는다는 점 
- MyISAM 스토리지 엔진 아키텍처
  - 키 캐시
    - MyISAM 키 캐시는 인덱스만을 대상으로 작동하며, 또한 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 함 
  - 슬로우 쿼리 로그
    - MySQL 서버의 쿼리 튜닝
      - 서비스가 적용되기 전에 전체적으로 튜닝하는 경우 : 검토해야 할 대상 쿼리가 전부라서 모두 튜닝 
      - 서비스 운영중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝 : 어떤 쿼리가 문제의 쿼리인지 판단하기 상당히 어려움
    - 슬로우 쿼리 로그 파일에는 long_query_time 시스템 변수에 설정한 시간(long_query_time 파라미터는 초단위로 설정하지만 소수점 값으로 설정하면 마이크로 초 단위로 설정 가능함) 이상의 시간이 소요된 쿼리가 모두 기록됨 
    - 슬로우 쿼리 로그 파일에 기록되는 쿼리는 일단 정상적으로 실행이 완료됐고 실행하는 데 걸린 시간이 long_query_time에 정의된 시간보다 많이 걸린 쿼리인 것 

# 트랜잭션과 잠금
- 트랜잭션은 작업의 안정성을 보장해 주는 것, 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능 
- 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능 
- 트랜잭션
  - 트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT을 실행했을 때) 아무것도 적용되지 않아야(ROLLBACK 또는 트랜잭션을 ROLLBACK시키는 오류가 발생했을 때) 함을 보장해 주는 것 
  - InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜잭션의 원칙대로 INSERT 문장을 실행하기 전 상태로 그대로 복구함, MyISAM 테이블에서 발생하는 이러한 현상을 부분 업데이트(Partial Update), 부분 업데이트 현상은 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어 냄 
  - 부분 업데이트 현상이 발생하면 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리 작업이 필요할 수 있음 
- MySQL 엔진의 잠금
  - 테이블 데이터 동기화를 위한 테이블 락 이외에도 테이블의 구조를 잠그는 메타데이터 락(Metadata Lock), 사용자의 필요에 맞게 사용할 수 있는 네임드 락(Named Lock)이라는 잠금 기능도 제공함 
  - 글로벌 락(GLOBAL LOCK)
    - MySQL에서 제공하는 잠금 가운데 가장 범위가 큼 
    - 글로벌 락을 거는 FLUSH TABLES WITH READ LOCK 명령은 실행과 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 검 
  - 테이블 락(Table Lock)
    - 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있음 
  - 네임드 락(Named Lock)
    - GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있음 
    - 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하느 잠금
    - 배치 프로그램처럼 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되곤 함. 각 프로그램의 실행 시간을 분산하거나 프로그램의 코드를 수정해서 데드락을 최소화할 수는 있지만, 이는 간단한 방법이 아니며 완전한 해결책이 될 수도 없음. 동일한 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있음 
  - 메타데이터 락(Metadata Lock)
    - 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금 
- InnoDB 스토리지 엔진 잠금
  - 레코드 락(Record lock, Record only lock) : 레코드 자체만은 잠그는 것, 다른 상용 DBMS의 레코드 락과 동일한 역할을 함 
  - 갭 락(Gap lock) : 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미함, 갭 락의 역할을 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것 
  - 넥스트 키 락(Next key lock) : 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
- MySQL의 격리 수준
  - 트랜잭션의 격리 수준(isolation level) : 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것 
  - READ UNCOMMITTED
    - 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보임 
    - 더티 리드(Dirty read) : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
    - 더티 리드가 허용되는 격리 수준 
  - READ COMMITTED
    - 오라클 DBMS에서 기본으로 사용되는 격리 수준, 온라인 서비스에서 가장 많이 선택되는 격리 수준 
    - 어떤 트랜잭션에서 데이터르 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문 
    - READ COMMITTED 격리 수준에서는 어떤 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 그러한 변경 내역을 조회할 수 없기 때문 
  - REPEATABLE READ
    - MVCC(Multi Version Concurrency Control) : InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경함 
    - MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수가 없음 
  - SERIALIZABLE
    - 트랜잭션의 격리 수준이 SERIALIZABLE로 설정되면 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 됨
    - 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다는 것 
