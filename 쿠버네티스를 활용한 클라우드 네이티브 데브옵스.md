# 쿠버네티스와 마이크로서비스
- 데브옵스의 실현, 마이크로서비스
  - 데브옵스는 개발 조직과 운영 조직이 물리적으로 격리되지 않는 환경에서 개발, 테스트, 배포, 운영에 이르는 전체 생명주기를 서로 긴밀하게 통합하여 관리 
  - 데브옵스를 실현하기 위한 수단으로 필연적으로 마이크로서비스가 등장
  - 마이크로서비스는 전통적인 거대한 덩치의 애플리케이션을 잘게 쪼개는 것, 서비스의 집합으로서의 애플리케이션 
  - 데브옵스 워크플로우
    - 소프트웨어의 개발과 운영의 합성어로서 소프트웨어 개발자와 정보기술 전문가 간의 소통, 협업 및 통합을 강조하는 개발 환경이나 문화
- 마이크로서비스 아키텍처에 대한 정의
  - 소프트웨어 애플리케이션을 독립적으로 배치 가능한 서비스 조합(suite)으로 설계하는 방식
  - 마이크로서비스 아키텍처는 아주 작은 단위로 동작하는 서비스가 구동되도록 시스템 및 소프트웨어의 구성과 구성요소 간의 관계를 정의한 아키텍처
  - 모든 요소를 하나의 애플리케이션에 구축하는 전통적인 모놀로식 접근 방식 대신 마이크로서비스에서는 모든 요소가 독립적이며 연동되어 동일한 태스크를 완수 
  - 하나의 애플리케이션을 구성함에 있어 분할된 다수의 서버 또는 컨테이너를 통해 애플리케이션 기능뿐만 아니라 데이터까지 분리하여 격리된 독립된 환경으로 구성되는 점이 특징 
- 마이크로서비스 특징
  - 애플리케이션 로직을 각자 책임이 명확한 작은 컴포넌트들로 분해하고 이들을 조합해서 솔루션을 제공
  - 각 컴포넌트는 작은 책임 영역을 담당하고 완전히 상호 독립적으로 배포 
  - 마이크로서비스는 몇가지 기본 원칙에 기반을 두며, 서비스 소비자와 서비스 제공자 사이의 데이터 교환을 위해 HTTP와 JSON같은 경량 통신 프로토콜을 사용 
- 가상화와 컨테이너
  - 전통적인 배포 : 물리서버 기반 애플리케이션 실행
  - 가상화된 배포 : 단일 물리 서버의 CPU에서 여러 가상 시스템(VM)실행
  - 컨테이너 개발 : VM과 유사, 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유 
- 컨테이너의 장점
  - 기민한 애플리케이션 생성과 배포 - VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적임
  - 지속적인 개발, 통합 및 배포 - 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 쉽게 롤백할 수 있음 
  - 개발과 운영의 관심사 분리 - 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 디커플 됨 
  - 가시성은 OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있음
  - 개발, 테스트 및 운영 환경에 걸친 일관성 - 랩탐에서도 클라우드에서와 동일하게 구동됨 
  - 클라우드 및 OS 배포판 간 이식성 
  - 애플리케이션 중심 관리 - 가상 하드웨어의 OS에서 애플리케이션을 구동하는 수준에서 OS의 논리적인 자원을 사용하여 애플리케이션을 구동하는 수준으로 추상화 수준이 높아짐 
  - 느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스 - 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있음 
  - 자원 격리 - 애플리케이션 성능을 예측할 수 있음
  - 자원 사용량 - 고효율 고집적
- 컨테이너 오케스트레이션
  - 컨테이너 배포 관리는 흔히 컨테이너 오케스트레이션(Container Orchestration)
  - 컨테이너 오케스트레이션의 목적은 여러 컨테이너의 배포 프로세스를 최적화
  - 애플리케이션은 더 이상 하나의 통일체가 아니라 특정 애플리케이션이 설계 의도대로 기능하도록 함께 작동해야 하는 수십 또는 수백 개의 느슨하게 결합되고 컨테이너화된 요소로 구성 
  - Apache Mesos, Google Kubernetes, Docker Swarm 등의 플랫폼들은 각자 컨테이너 관리를 위한 자체적인 특별한 방식을 보유 
- 컨테이너 오케스트레이션 기능
  - 컨테이너형 애플리케이션의 배포
  - 컨테이너 그룹에 대한 로드밸런싱
  - 스케일링/오토스케일링
  - 컨테이너 장애 복구
  - 컨테이너 그룹간 격리/연결
  - 외부로 서비스 노출
  - 서비스 디스커버리
  - 로그 수집 집중화 / 자동화
  - 모니터링 집중화 / 자동화 
- Kubernetes
  - 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장 가능한 오픈소스 플랫폼
  - 디플로이(Deploy), 자동화, 스켈일링(Scaling), 컨테이너화된 애플리케이션의 관리를 위한 오픈소스 시스템
  - 여러 클러스터의 호스트간 애플리케이션 컨테이너의 배치, 스케일링, 운영을 자동화하기 위한 플랫폼을 제공
  - 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가짐
  - 쿠버네티스란 명칭은 키잡이(helmsman)이나 파일럿을 뜻하는 그리스어에서 유래
  - 구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화 함 
- Docker Swarm
  - 여러 개의 Docker 호스트를 함께 클러스터링하여 단일 가상 Docker 호스트를 생성
  - 호스트 OS에 Agent만 설치하면 간단하게 작동하고 설정이 쉬움
  - Docker 명령어와 Compose를 그대로 사용가능 
- Apache Mesos
  - 수만 대의 물리적 시스템으로 확장 할 수 있도록 설계되어 있음
  - Hadoop, MPI, Hypertable, Spark같은 응용프로그램을 동적클러스터 환경에서 리소스 공유와 분리를 통해 자원 최적화가 가능
  - Docker 컨테이너를 적극적으로 지원함 
# 쿠버네티스와 컨테이너
- 도커 컨테이너
    - 도커는 BSD와 솔라리스(Solaris)와 같은 유닉스(Unix) 운영체제에서 수십년 간 사용되었던 개념이 현대적으로 재탄생된 최신 개념
    - 각 애플리케이션과 종속물이 운영체제 리소스의 분리된 세그먼트를 이용하는 방식
    - 컨테이너 런타임(container runtime)은 호스트 운영체제가 제공하는 저수준 컨테이너 서비스를 사용해 컨테이너를 셋업하거나 없앰
    - 분리와 조절 기능 제공
        - 도커 컨테이너는 앱을 서로 그리고 기반이 되는 시스템으로 부터 계속 분리 
        - 동시에 더 쉽게 분리된 특정 애플레케이션의 CPU와 GPU, 메모리, I/O, 네트워킹 등 시스템 리소스 사용 방식을 규정 
    - 이식성을 제공하는 도커 컨테이너
        - 컨테이너 런타임 환경을 지원하는 모든 장치에서 실행
    - 결합성(Composability)을 제공하는 도커 컨테이너
        - 대부분의 비즈니스 애플리케이션은 웹 서버, 데이터베이스, 인-메모리 캐시 등 하나의 스택으로 구성되는 여러 별개의 구성 요소로 구성, 이런 조각들을 쉽게 변경할 수 있는 부품으로 구성된 기능 유닛으로 결합 
    - 오케스트레이션과 스케일링이 쉬운 도커 컨테이너
        - 여러 시스템에서의 애플리케이션 스케일링, 수요 증가와 리소스 보존을 위한 서비스 증가 및 다운에도 컨테이너를 사용         
    - 가상 머신이 아닌 도커 컨테이너 
        - 가상 머신은 운영체제에서 자신의 인스턴스에서 실행되기 때문에 고수준의 프로세스 분리 기능을 제공
    - 변경이 불가능하고, 비저장성이 특징인 도커 컨테이너
        - 내용을 설명하는 이미지로부터 부팅 및 실행됨, 이미지는 기본적으로 변경이 불가능함, 일단 생성되면 바뀌지 않음
    - 마이크로서비스가 아닌 도커 컨테이너
        - 컨테이너를 사용하면 더 쉽게 마이크로서비스 애플리케이션을 구현할 수 있음
- 쿠버네티스와 데브옵스 운영
    - 컨테이너 기술은 민첩성을 확보하는 핵심 가상화 기술이며 컨테이너 기반의 가상화 환경을 운영 관리하는 핵심 기술이 바로 쿠버네티스(Kubernetes)
    - 컨테이너화된 애플리케이션을 자동으로 배포, 스케일링 및 관리해주는 오픈소스, 쿠버네티스
    - 마이크로 서비스 아키텍처 발전
    - 데브옵스 모델의 성숙화 
    - 개발 환경을 컨테이너 기반 가상화 환경으로 구현하고 CI(Continuous Integration)/CD(Continuous Development) 도구 및 개발 방법론을 결합함으로써 코딩, 빌드 및 테스트를 보다 쉽고 빠르게 수행하며 개발 환경 자동화와 손쉬운 운영 환경 배포의 기반을 마련
    - CI 기술은 개발 과정에서 빠른 소프트웨어 수정을 통해 품질 및 배포 속도를 향상시키며, CD기술은 소프트웨어 업데이트를 업무 애플리케이션에 적용해 변경 사항을 보다 효율적으로 배포하도록 지원 
- 마이크로 서비스 아키텍처
    - 관리 컨테이너 
        - 개별 서비스 인스턴스에는 작동 할 컨테스트가 필요, 가상 컴퓨터 , Docker 컨테이너 또는 조정 된 프로세스로 구현 된 관리 컨테이너는 이러한 기능을 제공 
    - 외부 게이트웨이
        - MSA 구현은 비즈니스 응용 프로그램 및 응용 프로그램에서 사용할 수 있는 API 형태로 기능을 노출 , 서비스 외부 게이트웨이는 이러한 서비스에 대한 액세스를 관리하고 트래픽 관리 및 보안 정책을 적용하여 마이크로 서비스 환경을 보호
    - 서비스 메쉬 기능
        - 서비스 메쉬는 서비스 간의 통신을 느슨하게 결합, 신뢰성 및 유연성을 유지하는 데 도움이되는 기능으로 구성되며 서비스 분리, 버전 관리 및 전략 지원 및 부하시 탄성 확장성 관리가 가능 
    - 서비스 이미지 레지스트리 : 사용자 환경이 어딘가에는 빌드되고 테스트 된 서비스 불변 이미지를 저장하는 레지스트리로 저장소(동적으로 생성된 서비스의 경우), Docker 이미지 레지스트리, 이진 아티팩트 저장소 또는 VM 이미지 BLOB(Binary Large Object)기반 저장소 등
    - 메시지 지향 미들웨어 : 가장 간단한 MSA 구현은 HTTP와 같은 동기식 프로토콜 또는 gRPC 또는 Thrift와 같은 보다 효율적인 프로토콜을 사용하여 지속 가능하며 이벤트 및 메시지 중심 패턴을 지원하기 위해 비동기 메시징 채널이 필요
    - 빌드 및 테스트 자동화 : MSA의 개발 민첩성 이점은 개발 출력 품질을 극대화하고 전달을 간소화하기 위해 개발주기에서 높은 수준의 빌드 및 테스트 자동화가 필요
    - 배포 자동화 : 개발 민첩성 이점을 완전히 실현하려면 배포를 자동화 

# 쿠버네티스와 오브젝트 모델 
- 쿠버네티스 생태계(CNCF : Cloud Native Interactive Landscape)
- 쿠버네티스 개념
  - ![image](https://user-images.githubusercontent.com/47103479/182861132-3adf76d9-f54e-4205-93af-b3892e2f37fe.png)
  - 클러스터 전체를 관리하는 컨트롤러로써 마스터
  - 컨테이너가 배포되는 머신(가상머신이나 물리적인 서버머신)인 노드 
- 쿠버네티스 오브젝트
  - 쿠버네티스는 상태를 관리하기 위한 대상을 오브젝트로 정의
  - 쿠버네티스 시스템에서 영속성을 가지는 개체
  - 클러스터 상태를 나타내기 위해 이 개체를 이용
  - 쿠버네티스 객체
    - 어떤 컨테이너화된 애플리케이션이 동작 중인지(그리고 어느 노드에서 동작 중인지)
    - 그 애플케이션이 이용할 수 있는 리소스
    - 그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성과 같은 것에 동작해야 하는지에 대한 정책
  - 기본 오브젝트(Basic Object), 컨트롤러(Controller), 오브젝트 스펙 및 메타 정보로 구성 
- 쿠버네티스 기본 오브젝트
  - 컨테이너화되어 배포되는 애플리케이션의 워크로드를 기술하는 오브젝트
  - 오브젝트는 사용자가 쿠버네티스에 바라는 상태(desired state)를 의미하고 컨트롤러는 객체가 원래 설정된 상태를 잘 유지할수 있게 관리하는 역할
  - Pod : 컨테이너화된 애플리케이션
    - 하나의 컨테이너를 개별적으로 배포하는 것이 아닌 Pod 단위로 배포
    - 가장 기본적인 배포 단위로 하나 이상의 컨테이너를 포함하는 단위
    - 일반적으로 1 Pod 1 Container
    - Pod 내의 컨테이너들은 IP, Port를 공유
    - Pod가 재시작되면 IP가 변경되며 Pod내의 컨테이너들의 로컬디스크의 내용이 사라짐
    - Pod 내에 배포된 컨테이너간에는 디스크 볼륨을 공유 가능 
  - Service : 로드밸런서
    - Label Selector로 Pod를 선택하여 하나의 Endpoint로 노출
    - 프리버전을 사용하게 되면 WorkerNode의 NodePort로 밖에 접근할 방법이 없음
    - 종류: ClusterIP, NodePort, LoadBalancer, ExternalName
    - Pod와 Volume을 이용하여 컨테이너들을 정의한 후에 Pod를 서비스로써 제공할 때 일반적으로 하나의 Pod로 서비스를 하는 경우는 드물고 여러개의 Pod를 서비스하며 이를 로드밸런서를 이용해 하나의 IP와 포트로 묶어서 서비스를 제공
    - Label Selector : 서비스를 정의할 때 어떤 Pod들을 Serviece로 묶을 것인지를 정의함
    - 각 Pod를 생성할 때 Object Spec의 metadata 부분에 Pod에서 사용할 라벨(Label)을 정의 
  - Volume : 디스크
    - Pod가 기동될 때 디폴트로 컨테이너마다 로컬 디스크를 생성해서 기동되는데, 이 로컬 디스크의 경우에는 영구적이지 못함 
    - 데이타 베이스와 같이 영구적으로 파일을 저장해야 하는 경우에는 컨테이너 재시작과 상관 없이 파일을 영속적으로 저장해야 하는데, 이러한 형태의 스토리지를 볼륨
    - Pod와 lifecycle이 같음
    - 컨테이너의 외장 디스크와 유사하며 Pod가 기동될때 컨테이너에 마운트하여 사용
    - iSCSI나 NFS와 같은 Onpremiss기반의 외장 스토리지 이외에 클라우드 외장 스토리지인 AWS EBS, Google PD 그리고 github, 등의 오픈소스 기반 외장스토리 서비스를 지원 
  - Namespace : 패키지명 
    - 한 쿠버네티스 클러스터내의 논리적인 분리단위
    - Pod,Service 등은 네임 스페이스 별로 생성이나 관리가 될 수 있고, 사용자의 권한 역시 이 네임 스페이스 별로 나눠서 부여 가능 
    - 네임스페이스로 할 수 있는 거은 사용자별로 네임스페이스별 접근 권한을 다르게 운영 가능하고, 네임스페이스별로 리소스의 쿼타(할당량)을 지정 가능하고 네임 스페이스별로 리소스를 나눠서 관리 할 수 있음(Pod, Service 등)
    - 네임 스페이스는 논리적인 분리 단위이지 물리적이나 기타 장치를 통해서 환경을 분리(Isolation)한 것이 아니며 다른 네임 스페이스간의 Pod 라도 통신은 가능 
