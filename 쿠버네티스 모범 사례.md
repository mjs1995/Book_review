# 서평
- 이 책은 쿠버네티스에 애플리케이션을 배포하거나 쿠버네티스 기반 애플리케이션에 적용할 수 있는 패턴과 사례를 배우려는 실무자를 대상으로 하고 있습니다.

# 기본 서비스 설치
- 설정 파일 관리
  - 쿠버네티스에서는 모든 것을 선언적(declarative)으로 표현함. 즉 클러스터 내에서 애플리케이션의 의도한 상태(desired state)를 작성하며(일반적으로 YAML이나 JSON 파일) 애플리케이션의 모든 구성 요소에 대해 상태를 정의함.
  - 클러스터의 상태를 일련의 변경의 합으로 보는 명령적(imperative) 접근방법도 있지만, 쿠버네티스는 선언적 방법을 선호함
  - 쿠버네티스는 YAML과 JSON을 지원함. 일반적으로 애플리케이션의 상태를 선언할 때는 JSON 보다 YAML을 선호함. YAML이 JSON보다 좀 더 간결하고 수정이 쉽기 때문. 대신 YAML은 들여쓰기에 민감함. YAML에서 들여쓰기를 잘못한 탓에 종종 쿠버네티스 설정 오류가 발생함
- 디플로이먼트를 이용한 복제 서비스 생성
  - 이미지 관리 모범 사례
    - 컨테이너 이미지를 구축하고 관리하는 것. 이미지 구축 과정은 공급망 공격(supply chain attack)에 취약함. 공급망 공격이란 신뢰할 수 있는 소스의 의존 이미지에 악의적인 사용자가 코드나 바이너리를 삽입해서, 결국 독자의 애플리케이션에 이를 내장시키는 것 
    - 네이밍(naming)과 관련된 모범 사례도 있음. 이론적으로는 이미지 레지스트리에 존재하는 컨테이너 이미지 버전을 변경할 수 있음. 하지만 실제로는 버전 태그를 변경하지 않는 것이 좋음. 그래서 의미론적 버전과, 이미지가 빌드된 커밋의 SHA 해시(hash)와 결합해 네이밍하는 것을 권장함(예를 들어 v1.0.1-bfeda01f). 만약 이미지 버전 태그를 명시하지 않는다면 latest를 기본으로 사용함
  - 애플리케이션 레플리카 생성
    - 쿠버네티스에서 레플리카셋(ReplicaSet)은 컨테이너화된 애플리케이션의 레플리카를 관리하는 리소스. 하지만 레플리카셋을 사용하는 대신 디플로이먼트(Deployment) 리소스를 사용하는 것을 권장함. 
    - 디플로이먼트는 레플리카셋의 복제 기술과 더불어 버전 과리, 단계적 롤아웃도 지원함. 디플로이먼트를 사용하면 쿠버네티스에 내장된 도구를 이용해 애플리케이션 버전을 변경할 수 있음 
    - 컨테이너의 리소스 요청(request)와 제한(limit)에도 주목해야 함.
      - 요청은 애플리케이션을 실행하는 호스트 장비가 보장해주는 리소스 크기이고 제한은 컨테이너가 사용할 수 있는 최대 리소스 크기
      - 요청과 제한을 동일한 값으로 설정하면 애플리케이션은 대부분 예상대로 동작함. 대신 리소스 이용률을 높일 수 없다는 단점이 있음
      - 애플리케이션이 과도하게 스케줄링되거나 유휴 리소스를 과소비하는 것을 방지한다는 장점은 있지만, 세밀하게 튜닝하지 않으면 리소스를 최대로 사용할 수 없음 
    - 클러스터 항목과 소스 관리 항목이 정확히 일치해야 함. 가장 좋은 방안은 깃옵스(GitOps)로 지속적 통합(CI)과 지속적 배포(CD)를 자동화하여 특정 브랜치만 운영에 배포하는 것. 이 방식으로 소스 관리와 운영을 일치시킬 수 있음 
- HTTP 트래픽을 처리하는 외부 인그레스 설정
  - 외부에 노출하려면 실제로 두 개의 쿠버네티스 리소스를 사용함. 
    - 첫 번째는 전송 제어 프로토콜(TCP, Transmission Control Protocol) 또는 사용자 데이터그램 프로토콜(UDP, User Datagram Protocol) 트래픽을 로드 밸런싱하는 서비스
    - 인그레스 리소스는 HTTP 경로와 호스트 기반의 요청을 지능적으로 라우팅(routing) 할 수 있는 HTTP (S) 로드 밸런싱을 지원함
- 컨피그맵으로 애플리케이션 설정
  - 설정을 사용하면 사용자의 요구사항 변경이나 애플리케이션 코드가 실패했을 때 빠르게(그리고 동적으로) 기능을 활성화하고 비활성화할 수 있음. 하나의 기능 단위로 롤아웃이나 롤백할 수 있음
  - 쿠버네티스에서는 컨피그맵 리소스로 설정을 정의함. 컨피그맵은 설정 정보나 파일을 나타내는 다중 키/값 쌍을 가짐. 이 설정 정보는 파드 내의 컨테이너에 파일이나 환경 변수 형태로 전달됨
- 시크릿 인증 관리
  - 볼륨은 사용자가 지정한 위치에 존재하는 하나의 파일이나 디렉터리로, 실행 중인 컨테이너에 마운트될 수 있음. 시크릿은 tmpfs 램 기반의 파일 시스템으로 볼륨을 생성해 컨테이너에 마운트됨. 따라서 장비가 물리적인 피해를 입더라도(클라우드가 아닌 데이터 센터라면 가능) 공격자가 시크릿을 취득하기 어려움 
- 간단한 스테이트풀 데이터베이스 배포
  - 쿠버네티스에서는 노드 상태, 업그레이드, 리밸런싱 등 여러 이유로 파드가 다시 스케줄링됨. 이러한 일이 발생하면 파드는 다른 서버로 옮겨짐. 이때 레디스 인스턴스와 연관된 데이터가 특정 장비나 컨테이너 자체에 존재하는 경우, 컨테이너가 이관되거나 재시작될 때 해당 데이터가 손실됨. 이를 방지하려면 스테이트풀 작업을 실행할 때, 원격 퍼시스턴트볼륨(PersistentVolume)을 사용하여 애플리케이션 상태를 처리해야 함 
  - 시크릿과는 달리 퍼시스턴트볼륨은 일반적으로 원격 스토리지에 존재하며, 파일 기반의 네트워크 파일 시스템(Network File System,NFS), 서버 메시지 블록(Server Message Block, SMB), 블록 기반의 iSCSI, 클라우드 기반 디스크 등 다양한 네트워크 프로토콜을 통해 마운트됨.
  - 일반적으로 데이터베이스와 같은 애플리케이션의 경우 성능이 더 좋은 블록 기반 디스크를 선호하지만, 성능이 주요 고려 대상이 아니라면 유연성이 높은 파일 기반 디스크가 낫음
  - 퍼시스턴트볼륨클레임(PersistentVolumeClaim), 클레임은 리소스 요청을 생각하면 됨. 레디스가 50GB가 필요하다고 추상적으로 선언하면 쿠버네티스 클러스터는 적절한 퍼시스턴트볼륨을 제공할 방법을 결정함
    - 디스크 명세(specification)가 다를 수 있는 여러 클라우드나 온프레미스 사이에서 이식할 수 있도록 스테이트풀셋을 작성할 수 있음
    - 퍼시스턴트볼륨 타입은 오직 하나의 파드에 마운트될 수 있지만, 볼륨클레임을 사용해 작성한 템플릿은 복제가 가능하며 따라서 각 파드는 자신만의 퍼시스턴트볼륨을 할당받을 수 있음 
- 인그레스를 이용해 트래픽을 정적 파일 서버로 전달
  - 정적 파일 서버는 HTML, CSS, 자바스크립트, 그림 파일을 제공하는 역할을 함 
- 서비스 배포 모범 사례
  - 대부분의 서비스는 디플로이먼트 리소스로 배포되어야 함. 디플로이먼트는 중복과 확장을 위해 레플리카를 생성함
  - 디플로이먼트는 로드 밸런서인 서비스를 통해 노출됨. 서비스는 클러스터 내부(기본값) 혹은 외부에 노출될 수 있음. HTTP 애플리케이션을 노출하려면 인그레스 컨트롤러를 사용할 수 있으며 요청 라우팅과 SSL도 추가할 수 있음 
  - 애플리케이션의 설정을 다양한 환경에서 재사용하려면 애플리케이션을 파라미터화해야 함. 헬름과 같은 패키징 도구는 이러한 파라미터화를 위한 최고의 선택 

# 개발자 워크플로
- 쿠버네티스는 소프트웨어를 안정적으로 운영하기 위해 만들어졌음. 애플리케이션 지향 API, 자체 복구 속성, 소프트웨어의 다운타임 없이 롤아웃할 수 있는 디플로이먼트 등 유용한 도구를 제공함
- 목표
  - 개발자와 클러스터 사이의 상호작용 단계
    - 온보딩
      - 개발자에게 계정을 생성해주고 첫 배포까지 지원해줌. 개발자가 최대한 이른 시일 안에 적응하도록 돕는게 목표.
      - 핵심 성과 지표(KPI, key performance indicator)도 세워야함. 
      - 빈손으로 시작한 사용자가 30분 내에 애플리케이션의 최신 버전을 실행하도록 만들기가 좋은 예
    - 개발
      - 개발자는 매일 개발을 함. 이 단계의 목표는 빠른 반복과 디버그
      - 개발자는 클러스터에 코드를 빠르고 반복적으로 푸시함. 문제가 발생했을때는 쉽게 코드를 테스트하고 디버그하길 원함
