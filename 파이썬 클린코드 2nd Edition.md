# 서평
- 이 책의 독자는 이미 객체지향 소프트웨어 디자인 원리에 어느 정도 익숙하고 코드를 작성해본 경험이 있는 것으로 가정합니다.

# 코드 포매팅과 도구
- 클린 코드란 무엇이고, 그것이 왜 중요한지, 왜 포매팅과 문서화가 중요한지, 이 과정을 어떻게 자동화하는지 알게 될 것
- 서론
  - 클린 코드의 의미
    - 체커(checker)를 사용해 문법을 체크하거나, 린터(linter)를 사용해 취약한 부분을 찾아내거나, 정적 분석기를 실행해 코드를 분석할 수는 있음. 클린 코드는 기계나 스크립트가 판단할 수 있는 것이 아니라 전문가가 판단할 수 있는 것
    - 클린 코드인지 아닌지는 다른 엔지니어가 코드를 읽고 유지 관리할 수 있는지 여부에 달려 있음
  - 클린 코드의 중요성
    - 클린 코드가 중요한 이유는 유지보수성 향상, 기술 부채의 감소, 애자일 개발을 통한 효과적인 작업 진행, 성공적인 프로젝트 관리로 이어진다는 것들. 민첩한 개발과 지속적인 배포가 가능하다는 것 
- 클린 코드에서 코드 포매팅의 역할
  - PEP란 Python Enhancement Proposal의 약자로 파이썬 개선을 위한 제안서를 의미함. 각 제안서는 고유한 번호를 갖게 되는 PEP 8번 Style Guide for Python Code에서 코딩 컨벤션에 대한 내용을 다룸
  - PEP-8은 가장 잘 알려진 표준이며 띄어쓰기, 네이밍 컨벤션, 줄 길이 제한 등의 가이드라인을 제공함
  - 클린 코드는 코딩 표준, 포매팅, 린팅 도구나 다른 검사 도구를 사용한 코드 레이아웃 설정과 같은 것 그 이상을 뜻함. 클린 코드는 품질 좋은 소프트웨어를 개발하고, 견고하고 유지보수가 쉬운 시스템을 만들고, 기술 부채를 피하는 것을 말함
  - 프로젝트 코딩 스타일 가이드 준수
    - 좋은 코드 레이아웃에서 가장 필요한 특성은 일관성. 코드가 일관되게 구조화되어 있으면 가독성이 높아지고 이해하기 쉬워짐
    - 한 줄의 최대 길이 등의 옵션은 프로젝트에 맞게 수정할 수 있음
    - PEP-8의 특징
      - 검색 효율성(Searchability) : 코드에서 원하는 부분을 빠르게 검색할 수 있도록 도와주는 성질. 변수의 값을 할당하는 경우와 함수의 키워드 파라미터에 값을 할당하는 경우를 구분한다는 것
      - 일관성 : 코드가 일정한 포맷을 가지면 훨씬 쉽게 읽을 수 있음. 코드 레이아웃, 문서화, 이름 작명 규칙 등이 모든 저장소에서 동일하다면 훨씬 쉽게 익숙해질 것
      - 더 나은 오류 처리 : PEP-8에서 제안한 것 중 하나는 try/except 블록 내부의 코드를 최소화하자는 것. 실수로 예외를 숨기는 것을 방지하기 위한 것
      - 코드 품질 : 코드를 구조화하여 살펴보면 한 눈에 코드를 이해하고 버그와 실수를 쉽게 찾을 수 있음
- 문서화
  - 코드를 문서화하는 것은 코드에 주석을 추가하는 것(adding comments)과 다르다는 점
  - docstring과 어노테이션을 살펴봄
  - 코드 문서화는 파이썬에서 중요한 부분. 왜냐하면 변수의 타입이 동적이어서 변수나 객체의 값이 무엇인지 잃어버리기 쉽기 때문. 이러한 이유로 타입 정보를 명시해두는 것이 좋음
  - 어노테이션을 사용하는 특별한 이유 중의 하나는 어노테이션의 mypy 또는 pytype과 같은 도구를 사용해 변수 타입 힌트와 같은 자동화에 도움을 주기 때문
  - 코드 주석
    - 가능한 한 적은 주석을 갖는 것을 목표로 해야 함
    - 좋은 코드는 코드 자체가 문서화되어 있기 때문. 의미 있는 함수나 객체를 통해 책임을 분리하는 것과 같은 올바른 추상화를 했고 명확하게 이름을 지정했다면 주석이 필요하지 않아야 한다는 것을 의미함
    - 어떤식으로도 정당화하기 어려운 나쁜 주석도 있음. 바로 주석 처리된 코드. 이러한 코드는 무자비하게 바로 삭제되어야 함. 코드는 개발자 간의 대화 수단이며 전체 디자인을 반영하는 궁극적인 표현 수단이라는 점을 기억하자. 코드는 지식의 표현이다. 주석 처리된 코드는 해당 지식을 오염시킬 뿐만 아니라 대부분의 경우에 혼란을 가져옴
    - 특히 최신 버전 제어 시스템에서는 간단히 삭제하거나 다른 곳에 옮길 수 있는(stash) 기능이 있기 때문에 주석 처리된 코드를 남겨둘 이유가 없음
    - 문서화는 코드의 설계 방식이나 아키텍처를 명확하게 설명하는 것을 의미하며 이는 긍정적인 효과를 가져옴
  - Docstring
    - docstring은 소스 코드에 포함된 문서라고 말할 수 있음. docstring은 기본적으로 리터럴 문자열이며, 로직의 일부분을 문서화하기 위해 코드 어딘가에 배치됨. 문서라는 단어에 주목하자. 즉 이유가 아니라 설명임
    - Docstring은 모듈, 클래스, 메서드 또는 함수에 대해 문서를 제공하기 위한 것. 내가 작성한 컴포넌트를 다른 엔지니어가 사용하려고 할 때 docstring을 보고 동작방식과 입출력 정보 등을 확인할 수 있어야 함. 최대한 docstring을 추가하려고 노력하는 것은 좋은 습관
    - Docstring을 가진 코드가 좋은 (또는 프로젝트 표준에 필수이기도 한) 이유는 파이썬이 동적인 데이터 타입을 갖기 때문. 파이썬의 함수는 파라미터 값으로 어떤 데이터 타입도 취할 수 있음 
    - Sphinx(스핑크스)를 실행하면 프로젝트 문서화를 위한 기본 골격을 만들어줌. 특히 autodoc 익스텐션(sphinx.ext.autodoc)을 사용하면 코드에서 docstring을 가져와 문서화된 페이지를 만들어줌
    - 문서화 도구를 사용할 준비가 되었으면 문서가 프로젝트와 하나가 되도록 해당 도구를 오픈해야 함. 오픈소스 프로젝트라면 read the docs와 같은 도구를 사용하여 브랜치나 버전별 문서를 자동으로 생성할 수 있음
    - docstring의 한 가지 단점은 지속적으로 수작업을 해야 한다는 것. 코드가 변경되면 업데이트를 해야 함.
    - docstring이 정말 유용하게 사용되려면 여러 줄에 걸쳐 상세하게 작성해야 한다는 것. 이러한 점에 비춰볼 때 만약 함수가 너무 간단하고 자명한 코드라면 중복된 의미를 가진 docstring을 피하는 것이 더 나은 선택일 수 있음. 나중에 불필요한 유지 보수를 하지 않아도 되기 때문
  - 어노테이션
    - 기본 아이디어는 코드 사용자에게 함수 인자로 어떤 값이 와야 하는지 힌트를 주자는 것
    - 어노테이션을 사용해 변수의 예상 타입을 지정할 수 있음
    - > locate.__annotations__
    - 문자 생성, 유효성 검증 또는 타입 체크
    - 타입 힌트는 인터프리터와 별개로 데이터 타입이 바르게 사용되었는지 확인하는 도구를 제공하고, 사용자에게 호환되지 않는 데이터 타입을 사용한 경우 무엇이 잘못되었는지 힌트를 주기 위한 것
    - 린터(linter : 정적 코드 분석 도구) 이러한 도구를 사용하면 테스트 중에 바로 버그를 찾을 수 있으므로 다른 정적 분석 도구와 함께 mypy나 pytype을 함께 사용하는 것이 좋음 
    - ```python
      from typing import Tuple
      Client = Tuple[int, str]
      def process_clients(clients: list[Client]):
      ```
    - docstring에 포함된 정보의 일부는 어노테이션으로 이동시킬 수 있는 것이 사실임. docstring을 통해 보다 나은 문서화를 위한 여지를 남겨두어야 함. 동적 데이터 타입과 중첩 데이터 타입의 경우 예상 데이터의 예제를 제공하여 어떤 형태의 데이터를 다루는지 제공하는 것이 좋음
    - ```python
      def data_from_response(response: dics) -> dict:
        """response의 HTTP status가 200이라면 response의 payload를 반환
        
        - response 사전의 예제 ::
        {
            "status"; 200, # <int>
            "timestamp": "....", # 현재 시간의 ISO 포맷 문자열
            "payload": { ... } # 반환하려는 사전 데이터 
        }
        - 반환 사전 값의 예제::
        {"data": { .. } }
        - 발생 가능한 예외:
        - HTTP status가 200이 아닌 경우 ValueError 발생 
        """
        if response["status"] != 200:
            raise ValueError
        return {"data" : response["payload"]}
      ```
    - docstring을 사용했을 때의 이슈는 코드가 좀 더 커지게 되고, 실제 효과적인 문서가 되려면 보다 상세한 정보가 필요하다는 것
- 도구 설정
  - 도구를 사용한다는 것은 특정 검사를 반복적으로 그리고 자동화하여 한다는 것을 의미함. 즉, 로컬 개발 환경에서 검사한 결과가 다른 곳에서 검사한 결과와 항상 일치해야 함. 이러한 도구는 CI 빌드의 일부분으로 포함되어야 함
  - 데이터 타입 일관성 검사
    - mypy는 프로젝트에 선택적으로 사용할 수 있는 정적 타입 검증 도구로서 프로젝트에서 사용되는 모든 파일에 대해서 데이터 타입의 유효성을 검사함. 대부분은 버그를 잘 찾아주지만 때로는 잘못된 탐지 결과를 내는 경우도 있음
    - mypy는 다음과 같이 pip로 쉽게 설치할 수 있으며, 프로젝트의 의존성 목록에 포함하는 것을 추천함
    - 가상 환경에 mypy를 설치하고 mypy {파일명}과 같은 명령어를 실행하면 의심이 되는 오류들을 보고함. 일반적으로 오류를 방지하는 데 도움이 되는 것들이므로 보고서에서 발견된 문제를 해결하는 것이 좋음
    - mypy나 기타 타입 검사 도구가 유용하게 쓰이려면 먼저 어노테이션을 정확하게 작성해야 함
    - mypy와 pytype의 한 가지 큰 차이점은 오류를 확인하는 시점. pytype에서는 일시적으로 지정된 데이터 타입과 다른 타입을 사용하여도 최종 결과가 선언된 유형을 준수하는한 문제로 간주되지 않음
  - 일반적인 코드 검증
    - pycodestyle (예전 이름은 pep8), flake8과 같은 도구가 있음. 이것들은 모두 설정 가능한 구조로 되어 있고, 제공하는 커맨드라인 명령어를 사용해서 쉽게 실행이 가능함
    - 여러 파이썬 파일에 대해서 실행할 수 있으며, 실행 결과로 PEP-8 표준을 위반한 모든 라인과 에러 유형을 출력함
    - PEP-8은 일반적인 코드의 스타일이나 구조에 관한 것을 검사할 뿐 모든 메서드, 클래스, 모듈에 docstring을 넣도록 강제하지 않음. 너무 많은 파라미터를 사용하는 함수에 대해서는 아무런 불평을 하지 않음. 이러한 추가 검증이 가능한 도구 중의 하나가 바로 pylint. pylint는 가장 엄격한 수준의 검증을 하는 도구이며 기타 다른 여러 기능들도 포함하고 있음
    - pylint는 pylintrc 설정 파일이 있어서 개별적인 규칙에 대해서 활성/비활성 여부를 결정할 수도 있고, 해당 규칙의 변수 값 (예: 한 라인에서 허용 가능한 최대 길이)을 설정할 수도 있음
    - Coala는 파이썬뿐만 아니라 다른 여러 언어를 지원하는데, 기본 컨셉은 비슷함. 설정 파일이 있고, 커맨드 라인 도구가 있음. 파일을 검사하고 에러를 발견하면 (가능한 경우) 자동으로 수정 가능한 코드도 제안함
    - pylin와 Coala는 모두 확장이 가능함. pylint의 경우 여러 플러그인을 제공하고 있으며 직접 플러그인을 만들 수도 있음. Coala의 경우 일반적인 검사 항목과 함께 실행 가능한 검증 모듈을 직접 만들 수 있음 
  - 자동 포매팅
    - PR 시 불필요한 논쟁을 줄이고 코드의 핵심에 집중할 수 있도록 사전에 팀에서 논의된 코딩 컨벤션을 만들어 두는 것이 좋음.
    - 도구를 사용하여 표준 준수 여부를 확인하는 것 외에 자동으로 코드 형식을 지정하게 하는 것도 유용한 방법
    - 파이썬 코드를 자동으로 포매팅 하는 다양한 도구가 있음. flake8 같은 도구는 PEP-8 준수 여부를 검사할 뿐만 아니라 자동으로 PEP-8 표준을 준수하는 코드로 변환하는 기능도 있음.
    - black : 설정 가능하고 유연함을 가진 도구와 정반대 되는 개념을 가진 도구, 라인 길이 제외와 같은 옵션을 허용하지 않으면서 고유하고 결정적인 방식으로 코드 형식을 지정하는 특징이 있음
      - 따옴표는 항상 큰따옴표만 사용해야 하고, 파라미터의 순서는 항상 동일한 구조를 따라야 함. 이렇게 한느 것이 너무 엄격하다고 생각될 수도 있지만 코드의 차이를 최소화활 수 있는 유일한 방법
      - black 커맨드는 기본적으로 코드를 포맷하지만 검사만 해볼 수도 있음. '--check' 옵션을 사용하면 코드가 표준을 준수하는지 검사만 하고 실제 변경은 하지 않음. 이 기능은 특히 CI 프로세스에 통합하여 유용하게 사용할 수 있음 
      - black은 다른 도구들과 다르게 부분적인 포매팅을 지원하지 않고 파일을 완벽하게 포맷한다는 점을 다시 한번 기억할 필요가 있음. 기존 프로젝트에 black을 사용하려는 경우 다음 두 가지 시나리오를 생각할 수 있음
        - 저장소에 있는 파일을 포매팅한 마일스톤을 생성함. 이것은 많은 노이즈를 추가하고 기존 이력을 오염시키는 단점이 있음. 팀에서 git 이력을 얼마나 의존하는지에 따라 위험한 결정이 될 수도 있음
        - 또는 black이 적용된 버전으로 이력을 덮어쓰기 할 수 있음. git에서는 각각의 커밋에 몇 가지 명령을 적용하여 이력을 다시 작성하는 기능이 있음. 이렇게 하면 프로젝트가 처음부터 새로운 포맷으로 잘 작성된 것처럼 보이지만 몇 가지 주의 사항이 있음. 먼저 프로젝트의 기록이 다시 작성되었으므로 모든 사람이 저장소의 로컬 복사본을 새로고침 해야 함. 그리고 저장소의 이력이 많을 경우 시간이 오래 걸릴 수 있음
    - black처럼 all or nothing 방식으로 포매팅하는 것이 어렵다면 또 다른 도구인 yapf를 생각해볼 수 있음
      - yapf는 사용자 정의가 가능하면서도 코드의 일부분만 포매팅하는 것도 가능함
      - yapf는 포매팅을 적용할 줄의 범위를 지정할 수 있음. 이 기능을 사용하면 방금 변경된 영역에 대해서만 코드의 포맷을 변경하도록 IDE를 구성할 수 있음 
  - 자동 검사 설정
    - 리눅스 개발환경에서 빌드를 자동화하는 가장 일반적인 방법은 Makefile을 사용하는 것
    - Makefile은 프로젝트를 컴파일하고 실행하기 위한 설정을 도와주는 강력한 도구. 빌드 외에도 포매팅 검사나 코딩 컨벤션 검사를 자동화하기 위해 사용할 수도 있음
    - 편리한점
      - 가장 많이 사용하는 반복적인 작업을 간단하게 표준화할 수 있음. 새로운 구성원은 기존에 어떤 도구를 사용하는지에 상관없이 그저 make format 명령어를 입력하면 됨
      - Makefile은 프로젝트의 여러 작업을 한꺼번에 실행하는 표준화된 방법을 제공함. CI 도구에서 Makefile의 명령어를 호출하도록 하고, Makefile 안에서 실제 작업을 실행하도록 하면 CI 도구에서는 가능한 한 적은 설정 옵션을 갖게 됨 

# 파이썬스러운 코드
- 인덱스와 슬라이스
  - 자체 시퀀스 생성
    - 매젝 메서드 : 매직 메서드는 파이썬에서 특수한 동작을 수행하기 위해 예약한 메서드로 이중 밑줄로 둘러싸여 있음
    - 클래스가 표준 라이브러리 객체를 감싸는 래퍼(wrapper)인 경우 기본 객체에 가능한 만흔 동작을 위임할 수 있음. 클래스가 리스트의 래퍼인 경우 리스트의 동일한 메서드를 호출하여 호환성을 유지할 수 있음 
- 컨텍스트 관리자
  - 컨텍스트 관리자는 파이썬이 제공하는 유용한 기능. 이것이 특별히 유용한 이유는 패턴에 잘 대응하기 때문
  - ```python
    with open(filename) as fd:
      process_file(fd)
    ```
  - with 문(PEP-343)은 컨텍스트 관리자로 진입하게 함. 이 경우 open 함수는 컨텍스트 관리자 프로토콜을 구현함. 즉 예외가 발생한 경우에도 블록이 완료되면 파일이 자동으로 닫힘.
  - 프컨텍스트 관리자는 __enter__와 __exit__ 두 개의 매직 메서드로 구성됨. 첫 번째 줄에서 with 문은 __enter__ 메서드를 호출하고 이 메서드가 무엇을 반환하든 as 이후에 지정된 변수에 할당됨.
  - 해당 블록에 대한 마지막 문장이 끝나면 컨텍스트가 종료되며 이는 파이썬이 처음 호출한 원래 컨텍스트 관리자 객체의 __exit__ 메서드를 호출함을 의미함
  - 컨텍스트 관리자 구현
    - 함수에 contextlib.contextmanager 데코레이터를 적용하면 해당 함수의 코드를 컨텍스트를 관리자로 변환함
    - ```python
      import contextlib

      @contextlib.contextmanager
      def db_handler():
        try:
          stop_database()
          yield
        finally:
          start_database()

      with db_handler():
        db_backup()
      ```
    - 제너레이터 함수를 정의하고 @contextlib.contextmanager 데코레이터를 적용했음. 이 함수는 yield 문을 사용했으므로 제너레이터 함수가 됨
    - 데코레이터를 적용하면 yield 문 앞의 모든 것은 __enter__ 메서드의 일부처럼 취급된다는 것
    - 다른 도우미 클래스는 contextlib.ContextDecorator. 이 클래스는 컨텍스트 관리자 안에서 실행될 함수에 데코레이터를 적용하기 위한 로직을 제공하는 믹스인 클래스(다른 클래스에서 필요한 기능만 섞어서 사용할 수 있도록 메서드만을 제공하는 유틸리티 형태의 클래스)
    - 데코레이터를 사용하면 로직을 한 번만 정의하면 된다는 장점이 있음. 변하지 않는 동일한 로직을 필요한 곳에 원하는 만큼 재사용할 수 있음
    - contextlib.supress 함수. 안전하다고 확신하는 경우 해당 예외를 무시하는 기능. try/except 블록에서 코드를 실행하고 예외를 전달하거나 로그를 남기는 것과 비슷하지만 차이점은 suppress 메서드를 호출하면 로직에서 자체적으로 처리하고 있는 예외임을 명시한다는 점
- 컴프리헨션(Comprehension)과 할당 표현식
  - 컴프리헨션을 사용하면 코드를 보다 간결하게 작성할 수 있고, 일반적으로 가독성도 높아지기 때문
  - 컴프리헨션의 가독성을 생각해야 하며, 정말로 이해하기 쉬운 코드가 되는 것이 아니라면, 한 줄 코드를 만들기 위해 노력하지 않도록 유의하자
  - 할당 표현식을 사용하는 또 다른 이유는 성능 때문. 어떤 변환 작업을 위해 호출하는 경우 필요 이상으로 호출되기를 원하지 않을 것. 뿐만 아니라 할당 표현식에서 함수의 결과를 임시 식별자에 할당하는 것은 코드의 가독성을 높이는 좋은 최적화 기술 중 하나
- 프로퍼티, 속성(Attribute)과 객체 메서드의 다른 타입들
  - 파이썬에서의 밑줄
    - ```python
      class Connector:
        def __init__(self, source):
          self.source = source
          self._timeout = 60

      conn = Connector("postgresql://localhost")
      conn.source # 'postgresql://localhost'
      conn._timeout # 60
      conn.__dict__ # {'source': 'postgresql://localhost', '_timeout': 60}
      ```
    - timeout은 connector 자체에서만 사용되고 호출자는 이 속성에 접근하지 않아야 함. timeout 속성은 내부에서만 사용하고 바깥에서는 호출하지 않을 것이므로 외부 인터페이스를 고려하지 않고 언제든 안전하게 리팩토링할 수 있음
    - 클래스는 외부 호출 객체와 관련된 속성과 메서드만을 노출해야 함. 즉 객체의 인터페이스로 공개하는 용도가 아니라면 모든 멤버는 접두사로 하나의 밑줄을 사용하는 것이 좋음
    - 밑줄로 시작하는 속성은 private 처럼 취급되어야 하고 외부에서 호출하면 안 됨. 예외적으로 단위 테스트에서 직접 내부 속성에 접근하는 것이 편리하다면 허용될 수도 있음
    - 맹글링(name manging) : 밑줄 두 개를 사용하면 파이썬은 다른 이름을 만듬. 이중 밑줄을 사용한 변수의 이름을 "_<class_name>__<attribute-name>"형태로 변경하는 것 
    - 파이썬에서 이중 밑줄을 사용하는 것은 완전히 다른 경우를 위한 것. 여러 번 확장되는 클래스의 메서드를 이름 충돌 없이 오버라이드하기 위해 만들어졌음
    - 속성을 private으로 정의하려는 경우 하나의 밑줄을 사용하고 파이썬 스로운 관습을 지키도록 해야 함
    - 객체의 일부 속성을 public으로 공개 하고 싶은 경우 프로퍼티를 사용함
  - 프로퍼티
    - 일반적으로 객체 지향 설계에서는 도메인 엔티티를 추상화하는 객체를 만듬. 이러한 객체는 어떤 동작이나 데이터를 캡슐화할 수 있음
    - 종종 데이터의 정확성이 객체를 생성할 수 있는지 여부를 결정함. 일부 엔터티는 데이터가 특정 값을 가질 경우에만 존재할 수 있고, 잘못된 값을 가진 경우에는 존재할 수 없음
    - ```python
      class Coordinate:
        def __init__(self, lat: float, long: float) -> None:
          self._latitude = self._longitude = None
          self.latitude = lat
          self.longitude = long

        @proerty
        def latitude(self) -> float:
          return self._latitude

        @latitude.setter
        def latitude(self, lat_value: float) -> None:
          if lat_value not in range(-90, 90 + 1):
            raise ValueError(f"유효하지 않은 위도 값: {lat_value}")
          self._latitude = lat_value

        @property
        def longtitude(self) -> float:
          return self._longtitude

        @longitude.setter
        def longitude(self, long_value: float) -> None:
          if long_value not in range(-180, 180 + 1):
            raise ValueError(f"유효하지 않은 경도 값: {long_value}")
          self._longitude = long_value
      ```
    - @latitude.setter 데코레이터로 선언된 유효성 검사 로직이 자동으로 호출되며 명령문의 오른쪽에 있는 값 <new-latitude-value>이 파라미터로 전달됨(위에서는 lat_value 파라미터)
    - 객체의 상태나 내부 데이터에 따라 어떤 계산을 하고 싶은 경우가 있을 수도 있음. 이런 경우에도 프로퍼티가 좋은 선택
    - 프로퍼티는 명령-쿼리 분리 원칙(command and query separation - CC08)을 따르기 위한 좋은 방법. 명령-쿼리 분리 원칙은 객체의 메서드가 무언가의 상태를 변경하는 커맨드이거나 무언가의 값을 반환한느 쿼리이거나 둘 중에 하나만 수행해야지 둘 다 동시에 수행하면 안된다는 것
    - @property 데코레이터는 무언가에 응답하기 위한 쿼리이고, @<property_name>.setter는 무언가를 하기 위한 커맨드
    - 게으른 프로퍼티(lazy property)는 사전에 어떤 값을 미리 계산한 다음에 그 계산된 값을 사용하는 것. 그 외의 경우라면 프로퍼티가 멱등성(idempotent - 연산을 여러번 반복하더라도 결과가 동일한 성질)을 유지하도록 하고, 내부 표현을 변경하는 메서드를 따로 만들어야 함
  - 보다 간결한 구문으로 클래스 만들기
    - 파이썬에는 객체의 값을 초기화하는 일반적인 보일러플레이트(boilerplate code, boilerplate - 모든 프로젝트에서 공통적으로 반복해서 사용하는 코드) 코드가 있음
    - __init__ 메서드에 객체에서 필요한 모든 속성을 파라미터로 받은 다음 내부 변수에 할당하는 것
    - ```python
      def __init__(self, x, y, ...):
        self.x = x
        self.y = y
      ```
    - 파이썬 3.7 부터는 dataclasses 모듈을 사용하여 위 코드를 훨씬 단순화할 수 있음
    - dataclasses 모듈은 @dataclass 데코레이터를 제공함. 이 데코레이터를 클래스에 적용하면 모든 클래스의 속성에 대해서 마치 __init__ 메서드에서 정의한 것처럼 인스턴스 속성으로 처리함. @dataclass 데코레이터를 사용하면 __init__ 메서드를 자동으로 생성하므로 또 다시 __init__ 메서드를 구현할 필요가 없음
    - dataclassess 모듈은 field라는 객체도 제공함. 이 field 객체는 해당 속성에 특별한 특징이 있음을 표시함
    - ```python
      from typing import List
      from dataclasses import dataclass, field

      R = 26

      @dataclass
      class RTrieNode:
        size = R
        value: int
        next_: List["RTrieNode"] = field(default_factory = lambda: [None] * R)

        def __post_init__(self):
          if len(self.next_) != self.size:
            raise ValueError(f"리스트(next_)의 길이가 유효하지 않음)
      ```
    - @dataclass 데코레이터를 사용하면 __init__ 메서드에서 모든 변수의 이름을 반복해서 작성하는 번거로움 없이 간편하게 데이터 클래스를 만들 수 있음
    - 어노테이션이 데이터 변환을 해주지 않는다는 점을 명심. 예를 들어 float 타입이거나 integer 타입이어야만 한다면 __init__ 메서드 안에서 이 변환을 해야함
    - __init__메서드 안에서 별도의 처리를 하거나, 유효성 검사가 엄격하게 필요하지 않은 경우에 데이터 클래스를 사용하는 것이 적합함
    - 데이터 컨테이너나 래퍼(wrapper) 클래스의 용도로 사용되는 모든 경우에 데이터 클래스가 유용할 것
  - 이터러블 객체 만들기
    - 객체를 반복하려고 하면 파이썬은 해당 객체의 iter() 함수를 호출함. 이 함수가 처음으로 하는 것은 해당 객체에 __iter__ 메서드가 있는지를 확인하는 것. 만약 있으면 __iter__ 메서드를 실행함
  - 시퀀스 만들기
    - iter() 함수는 객체에 __iter__가 정의되어 있지 않으면 __getitem__을 찾고 없으면 TypeError를 발생시킴. 시퀀스는 __len__과 __getitem__을 구현하고 첫 번째 인덱스 0부터 시작하여 포함된 요소를 한 번에 하나씩 차례로 가져올 수 있어야 함
    - 컨테이너 객체
      - 컨테이너는 __contains__ 메서드를 구현한 객체로 __contains__ 메서드는 일반적으로 Boolean 값을 반환함
    - 객체의 동적인 속성
      - __getattr__ 매직 메서드를 사용하면 객체가 속성에 접근하는 방법을 제어할 수 있음
      - __getattr__ 메서드는 존재하지 않는 속성에 접근하려고 할 때 호출됨. __getattr__ 처럼 동적으로 변하는 속성에 대한 메서드를 작성하는 경우, 존재하지 않는 속성에 접근하려고 하면 AttributeError 오류를 발생시키도록 하자
    - 호출형 객체(callable)
      - 파이썬은 object(*args, **kwargs) 같은 구문으로 생성한 객체를 object.__call__ (*args, **kwargs) 형태로 변환함. 이 메서드는 객체를 파라미터가 있는 함수처럼 사용하거나 정보를 기억하는 함수처럼 사용하는 경우 유용함 
    - 매직 메서드 요약 
      - 파이썬에서의 매직 메서드
      - |사용 예|매직 메서드|비고|
        |:---:|:---:|:---:|
        |obj[key],obj[i:j],obj[i:j:k]|__getitem__(key)|첨자형(subscriptable) 객체|
        |with obj: ...|__enter__/__exit__|컨텍스트 관리자
        |for i in obj: ...|__iter__/__next__/__len__/__getitem__|이터러블 객체, 시퀀스
        |obj.<attribute>|__getattr__|동적 속성 조회
        |obj(*args, **kwargs)|__call(*args, **kwargs), 호출형 (callable) 객체
- 파이썬에서 유의할점
  - 사용자 정의 사전을 만들려는 경우 dict를 직접 상속하지 말고 collections.UserDict를 상속받자. 마찬가지로 리스트는 collections.UserList, 문자열이라면 collections.UserString을 상속받자
- 비동기 코드(asynchronous code)에 대한 간략한 소개
  - 비동기식 프로그래밍의 기본 아이디어는 중지(suspend) 가능한 코드가 있다면 그동안 다른 코드를 실행하자는 것
  - 비동기 프로그래밍의 장점은 I/O 작업 진행되는 동안 프로그램을 멈추지 않는다는 것. 다만, 이것이 I/O 작업을 하는 동안 다른 코드를 실행할 수 있다는 뜻이지만 동시에 여러 프로세스가 실행된다는 의미는 아님. 코드의 실행은 여전히 단일 스레드에서 이뤄짐
  - 비동기 프로그래밍을 위한 코루틴이 일반 함수와 다른 점은 이름 앞에 async def가 추가된다는 점. 코루틴 안에서 다른 코루틴을 호출하려는 경우 호출 전에 await 키워드를 사용함
  - await가 호출되면 이벤트 루프가 제어권을 되찾아 옴. 이벤트 루프는 해당 코루틴이 종료되기를 기다리는 동안 다른 코드를 실행함. 원래의 코루틴 작업이 완료되면 이벤트 루프는 중단지점 바로 다음 (await 문장 바로 다음 줄)에서부터 작업을 다시 시작함
  - ```python
    async def mycoro(*args, **kwargs):
      # ... logic
      await third_party.coroutine( ... )
      # ... more of our logic
    ```
  - asyncio의 경우는 해당 코루틴이 완료될 때까지 대기하는 내장 함수도 제공함 

# 좋은 코드의 일반적인 특징 
- 계약에 의한 디자인
  - 컴포넌트는 기능을 숨겨 캡슐화하고 함수를 사용할 클라이언트에게는 애플리케이션 프로그래밍 인터페이스(Application Programming Interface - API)를 노출해야 함 
- 방어적(defensive) 프로그래밍
  - 에러 처리 방법
    - 값 대체(value substitution)
      - 일부 시나리오에서는 오류가 있어 소프트웨어가 잘못된 값을 생성하거나 전체가 종료될 위험이 있을 경우 결과 값을 안전한 다른 값으로 대체할 수 있음 
    - 에러 로깅
    - 예외 처리
      - 예외적인 상황을 명확하게 알려주고 원래의 비즈니스 로직에 따라 흐름을 유지하는 것이 중요함
      - 파이썬의 예외와 관련된 몇 가지 권장 사항
        - 올바른 수준의 추상화 단계에서의 예외 처리 
          - 예외는 오직 한 가지 일을 하는 함수의 한 부분이어야 함. 함수가 처리하는 (또는 발생시키는) 예외는 함수가 캡슐화하고 있는 로직에 대한 것이어야 함
          - ```python
            def deliver_event(self, event: Event):
              try:
                self.connect()
                data = event.decode()
                self.send(data)
              except ConnectionError as e:
                logger.info("커넥션 오류 발견: %s", e)
              except ValueError as e:
                logger.error("%r 이벤트에 잘못된 데이터 포함: %s", event, e)
                raise
            ```
          - ConnectionError는 connect 메서드 내에서 처리되어야 함. 이렇게 하면 행동을 명확하게 분리할 수 있음. 예를 들어 메서드가 재시도를 지원하는 경우 그 안에서 예외 처리를 할 수 있음. 반대로 ValueError는 event의 decode 메서드에 속한 에러. 이렇게 구현을 수정하면 deliver_event에서는 예외를 catch할 필요가 없음
        - 엔드 유저에게 Traceback 노출 금지
          - 특정 문제를 나타내는 예외가 발생한 경우 문제를 효율적으로 해결할 수 있도록 traceback 정보, 메시지 및 기타 수집 가능한 정보를 최대한 로그로 남기는 것이 중요함. 이러한 세부사항은 절대 사용자에게 보여서는 안됨
        - 비어있는 except 블록 지양
          - 특히 너무 방어적이어서 아무것도 하지 않은 채로 조용히 지나쳐버리는 비어있는 except 블록은 가장 안 좋은 예
          - 심지어 심각한 오류가 발생한 경우에도.. 에러는 결코 조용히 전달되어서는 안된다는 파이썬의 철학(The Zen of Python)을 떠올리면 이는 파이썬스러운 코드가 아님
        - 원본 예외 포함
          - raise <e> from <original_exception> 구문을 사용하면 여러 예외를 연결할 수 있음. traceback 정보가 새로운 exception에 포함되고, 원본 오류는 새로운 오류의 원인으로 분류되어 __cause__ 속성에 할당됨 
  - 파이썬에서 어설션(assertion) 사용하기
    - 어설션은 잘못된 시나리오에 도달할 경우 프로그램이 더 큰 피해를 입지 않도록 하는 것. 때로는 잘못된 가정 하에 처리를 계속하기보다는 프로그램을 중단시키는 것이 더 좋음
    - AssertionError는 더 이상 처리가 불가능한 상황을 의미하므로 catch 후에 프로그램을 계속 실행하면 안됨. 특정 조건에 대한 검사가 필요하다면 보다 구체적인 오류를 발생시키도록 하자
    - if 문과 raise exception 구문을 사용하면 되는데, 어설션을 사용하는 이유는 뭘까?
      - Assert 구문은 항상 변하지 않는 고정된 조건에 대해서 검증할 때 사용됨. 이 조건이 깨진다면 무엇인가 잘못 구현되었거나 문제가 발생했음을 의미함 
- 관심사의 분리
  - 소프트웨어 디자인에서 관심사의 분리의 목표는 파급 효과의 최소화하여 유지보수성을 향상시키는 것. 파급(ripple) 효과는 어느 지점에서의 변화가 전체로 전파되는 것을 의미함
  - 응집력(cohesion)과 결합력(coupling)
    - 응집력이란 객체가 작고 잘 정의된 목적을 가져야 하며 가능하면 작아야 한다는 것을 의미함
    - 결합력이란 두 개 이상의 객체가 서로 어떻게 의존하는지를 나타냄
- 함수와 메서드의 인자
  - 이중 별표(**)를 키워드 안에서 사용할 수 있음. 사전에 이중 별표를 사용하여 함수에 전달하면 사전의 키를 파라미터 이름으로 사용하고, 사전의 값ㅇ르 파라미터 값으로 사용함
  - > function(**{"key": "value"}) = function(key="value")
  - 함수의 정의에 이중 별표 인자를 사용한다는 것은 임의의 키워드 인자(keyword argument)를 허용한다는 것이고, 이런 경우 파이썬은 우리가 임의로 접근할 수 있는 사전을 만들어줌
  - 키워드 전용(keyword-only) 인자
    - 함수 호출 시 키워드 인자를 사욯아면 그 의미를 명확히 알 수 있다는 점에서 키워드 사용을 강제하는 것은 일리가 있음
    - 키워드 전용 인자는 *를 사용하여 그 시작을 알림. 함수 서명에서 * 뒤에 오는 것들은 키워드 전용 인자가 됨. 예에서 *args 다음에 오는 kw1, kw2가 키워드 전용 인자
    - ```python
      def my_function(x, y, *args, kw1, kw2=0):
        print(f"{x=}, {y=}, {kw1=}, {kw2}")

      my_function(1, 2, kw1=3, kw2=4)
      # x=1, y=2, kw1=3, kw2=4
      ```
    - 하위 호환을 유지하면서 기존 함수의 확장을 할 수 있기 때문에 유용함
  - 많은 인자를 가진 함수의 서명 간소화
    - *args와 **kwargs로 함수를 정의하면 매우 유연하고 적응력이 뛰어난 코드를 만들 수 있지만, 단점은 함수 서명으로서의 기능을 잃어버린다는 것과 가독성이 완전히 떨어진다는 것
    - 가장 일반화된 인자(*args, **kwargs)는 super()를 통해 파라미터를 그대로 부모에 전달해야 하는 래퍼(wrapper) 클래스나 파라미터에 독립적으로 동작해야 하는 데코레이터와 같은 경우에만 사용하자

# SOLID 원칙 
- S : 단일 책임 원칙(Single responsibility principle)
  - 소프트웨어 컴포넌트(일반적으로 클래스)가 단 하나의 책임을 져야한다는 원칙
  - 클래스가 유일한 책임이 있다는 것은 하나의 구체적인 일을 담당한다는 것을 의미하며 따라서 변경이 필요한 이유도 단 하나만 있어야 함 
- O : 개방/폐쇄의 원칙(Open/closed principle)
  - 개방/폐쇄의 원칙(OCP)은 모듈이 개방되어 있으면서도 폐쇄되어야 한다느 원칙
  - 클래스를 디자인할 때는 유지보수가 수비도록 로직을 캡슐화화여 확장에는 개방되고 수정에는 폐쇄되도록 해야 함
  - 간단히 말해서 확장 가능하고, 새로운 요구사항이나 도메인 변화에 잘 적응하는 코드를 작성해야 한다는 뜻. 새로운 문제가 발생할 경우 새로운 것을 추가만 할 뿐 기존 코드는 그대로 유지해야 한다는 뜻 
- L : 리스코프(Liskov) 치환 원칙(Liskov's substitution principle)
  - 설계의 안정성을 높이기 위해 객체가 가져야 하는 일련의 특성을 말함
  - LSP의 요지는 클라이언트가 특별한 주의를 기울이지 않고도 부모 클래스를 대신하여 하위 클래스를 그대로 사용할 수 있어야 한다는 것. 클라이언트는 부모 타입 대신에 어떠한 하위 타입을 사용해도 정상적으로 동작해야 함
  - pylint로 호환되지 않는 서명 검사
    - mypy나 pylint와 같은 정적 코드 분석기를 사용해 초기에 오류를 잡을 수 있음
    - mypy로 오류를 잡고 pylint를 실행해 더 많은 통찰력을 얻는 것도 좋음 
- I : 인터페이스 분리 원칙(Interface segregation principle)
  - 이미 반복적으로 재검토했던 작은 인터페이스에 대한 가이드라인을 제공함
  - 객체 지향적인 용어로 인터페이스는 객체가 노출하는 메서드의 집함. 객체가 수신하거나 해석할 수 있는 모든 메시지가 인터페이스를 구성하며, 클라이언트는 이것들을 호출할 수 있음
  - 파이썬에서 인터페이스는 메서드의 형태를 보고 암시적으로 정의됨. 이것은 파이썬이 소위 말하는 덕 타이핑(duck typing) 원리를 따르기 때문
  - 덕 타이핑은 모든 객체가 자신이 가지고 있는 메서드와 자신이 할 수 있는 일에 의해서 표현된다는 점에서 출발함. 클래스의 타입, 이름, docstring, 클래스 속성 또는 인스턴스 속성에 관계없이 객체의 본질을 정의하는 것은 궁극적으로 메서드의 형태
- D : 의존성 역전 원칙(Dependency inversion principle)
  - 코드가 깨지거나 손상되는 취약점으로부터 보호해주는 흥미로운 디자인 원칙을 제시함. 의존성을 역전시킨다는 것은 코드가 세부 사항이나 구체적인 구현에 적응하도록 하지 않고, 대신에 API 같은 것에 적응하도록 하는 것
  - 추상화를 통해 세부 사항에 의존하지 않도록 해야 하지만, 반대로 세부 사항 (구체적인 구현)은 추상화에 의존해야 함

# 데코레이터를 사용한 코드 개선
- 파이썬의 데코레이터
  - 파이썬에서 데코레이터는 오래전에 PEP-318에서 기존 함수와 메서드의 기능을 쉽게 수정하기 위한 수단으로 소개되었음
  - ```python
    def original(...):
      ...
    original = modifer(original)

    # 함수를 동일한 이름으로 다시 할당하는 것에 주의하자.
    # 이것은 혼란스럽고 오류가 발생하기 쉽고 번거로움(함수를 재할당하는 것을 잊어버리거나 함수 정의가 멀리 떨어져 있는 경우)
    @modifier
    def original(...):
      ...
    ```
  - 즉 데코레이터는 데코레이터 이후에 나오는 것을 데코레이터의 첫 번째 파라미터로 하고 데코레이터의 결과 값을 반화하게 하는 문법적 설탕(syntax sugar, 어떤 언어에서 동일한 기능이지만 타이핑의 수고를 덜어주기 위해 또는 읽기 쉽게 하기 위해 다른 표현으로 코딩할 수 있게 해주는 기능)
  - 데코레이터 구문은 가독성을 크게 향상시킴. 왜냐하면 이제 독자는 한 곳에서 함수의 전체 정의를 찾을 수 있기 때문
  - 일반적으로 데코레이터 구문을 사용하지 않고 기존 함수를 다시 할당하는 방식은 피하도록 하자. 특히, 함수를 재할당하는 코드가 원래 함수가 정의된 곳에서 멀리 떨어진 경우 코드를 읽기가 어려워짐
  - modifier는 파이썬 용어로 데코레이터라 하고, original을 데코레이팅된 함수 또는 래핑된(wrapped) 객체
  - 함수 데코레이터
    - 함수에 데코레이터를 사용하면 어떤 종류의 로직이라도 적용할 수 있음. 파라미터의 유효성을 검사하거나 사전조건을 검사하거나, 기능 전체를 새롭게 정의할 수도 있고, 서명을 변경할 수도 있고, 원래 함수의 결과를 캐시하는 등의 작업을 모두 할 수 있음
  - 클래스 데코레이터
    - 장점
      - 클래스 데코레이터는 코드 재사용과 DRY 원칙의 모든 이점을 공유함. 클래스 데코레이터를 사용하면 여러 클래스가 특정 인터페이스나 기준을 따르도록 강제할 수 있음. 여러 클래스에 적용할 검사를 데코레이터에서 한 번만 하면 됨
      - 당장은 작고 간단한 클래스를 생성하고 나중에 데코레이터로 기능을 보강할 수 있음
      - 어떤 클래스에 대해서는 유지보수 시 데코레이터를 사용해 기존 로직을 훨씬 쉽게 변경할 수 있음. 메타클래스와 같은 방법을 사용해 보다 복잡하게 만드는 것은 일반적으로 권장되지 않음
- 고급 데코레이터
  - 데코레이터에 인자 전달
    - 간접 참조(indirection)를 통해 새로운 레벨의 중첩 함수를 만들어 데코레이터의 모든 것을 한 단계 더 깊게 만든느 것, 데코레이터를 위한 클래스를 만드는 것
    - 중첩 함수를 사용한 데코레이터
      - 크게 보면 데코레이터는 함수를 파라미터로 받아서 함수를 반환하는 함수. 함수형 프로그래밍(functional programming)에서 함수를 받아서 함수를 반환하는 함수를 고차 함수(higher-order function)라고 부름
    - 코루틴(coroutin)을 위한 데코레이터
      - 코루틴에 대한 데코레이터를 작성하려면 새로운 구문을 사용핟면 됨(래핑할 객체는 def가 아니라 async def로 선언해야 하고, 래핑된 코루틴은 await해야 한다는 것을 기억)
- 데코레이터 활용 우수 사례
  - 파라미터 변환: 파라미터가 어떻게 처리되는지 세부사항을 숨기면서 함수의 서명을 변경하는 경우에 사용함
  - 코드 추적 : 파라미터와 함께 함수의 실행 결로를 로깅하려는 경우
  - 파라미터 유효성 검사 : 데코레이터는 파라미터의 값이나 데이터 타입이 유효한지 투명하게 검사하는 데 사용될 수 있음
  - 재시도 로직 구현
  - 일부 반복 작ㅇ버을 데코레이터로 이동하여 클래스 단순화
- 좋은 데코레이터 분석
  - 캡슐화와 관심사의 분리 : 좋은 데코레이터는 실제로 하는 일과 데코레이팅하는 일의 책임을 명확히 구분해야 함
  - 독립성 : 데코레이터가 하는 일은 독립적이어야 하며 데코리이팅되는 객체와 최대한 분리되어야 함
  - 재사용성 : 데코레이터 하나는 함수 인스턴스에만 적용되는 것이 아니라 여러 유형에 적용 가능한 형태가 바람직함. 왜냐하면 함수에만 적용된다면 데코레이터가 아니라 함수로 대신할 수도 있기 때문. 충분히 범용적이어야 함
- 데코레이터는 코드를 재사용 하고 DRY 원칙을 따르는 데 매우 유용한 도구. 그러나 비용 또한 발생하므로 현명하게 사용하지 않으면 복잡성이 이익보다 커질 수 있음. 때문에 3번 이상 여러 번 적용될 때에만 데코레이터를 사용해야 함. DRY 원칙과 마찬가지로 관심사를 분리하기 위해 가능한 작게 데코레이터를 유지해야 함
