# 서평
- 이 책의 독자는 이미 객체지향 소프트웨어 디자인 원리에 어느 정도 익숙하고 코드를 작성해본 경험이 있는 것으로 가정합니다.

# 코드 포매팅과 도구
- 클린 코드란 무엇이고, 그것이 왜 중요한지, 왜 포매팅과 문서화가 중요한지, 이 과정을 어떻게 자동화하는지 알게 될 것
- 서론
  - 클린 코드의 의미
    - 체커(checker)를 사용해 문법을 체크하거나, 린터(linter)를 사용해 취약한 부분을 찾아내거나, 정적 분석기를 실행해 코드를 분석할 수는 있음. 클린 코드는 기계나 스크립트가 판단할 수 있는 것이 아니라 전문가가 판단할 수 있는 것
    - 클린 코드인지 아닌지는 다른 엔지니어가 코드를 읽고 유지 관리할 수 있는지 여부에 달려 있음
  - 클린 코드의 중요성
    - 클린 코드가 중요한 이유는 유지보수성 향상, 기술 부채의 감소, 애자일 개발을 통한 효과적인 작업 진행, 성공적인 프로젝트 관리로 이어진다는 것들. 민첩한 개발과 지속적인 배포가 가능하다는 것 
- 클린 코드에서 코드 포매팅의 역할
  - PEP란 Python Enhancement Proposal의 약자로 파이썬 개선을 위한 제안서를 의미함. 각 제안서는 고유한 번호를 갖게 되는 PEP 8번 Style Guide for Python Code에서 코딩 컨벤션에 대한 내용을 다룸
  - PEP-8은 가장 잘 알려진 표준이며 띄어쓰기, 네이밍 컨벤션, 줄 길이 제한 등의 가이드라인을 제공함
  - 클린 코드는 코딩 표준, 포매팅, 린팅 도구나 다른 검사 도구를 사용한 코드 레이아웃 설정과 같은 것 그 이상을 뜻함. 클린 코드는 품질 좋은 소프트웨어를 개발하고, 견고하고 유지보수가 쉬운 시스템을 만들고, 기술 부채를 피하는 것을 말함
  - 프로젝트 코딩 스타일 가이드 준수
    - 좋은 코드 레이아웃에서 가장 필요한 특성은 일관성. 코드가 일관되게 구조화되어 있으면 가독성이 높아지고 이해하기 쉬워짐
    - 한 줄의 최대 길이 등의 옵션은 프로젝트에 맞게 수정할 수 있음
    - PEP-8의 특징
      - 검색 효율성(Searchability) : 코드에서 원하는 부분을 빠르게 검색할 수 있도록 도와주는 성질. 변수의 값을 할당하는 경우와 함수의 키워드 파라미터에 값을 할당하는 경우를 구분한다는 것
      - 일관성 : 코드가 일정한 포맷을 가지면 훨씬 쉽게 읽을 수 있음. 코드 레이아웃, 문서화, 이름 작명 규칙 등이 모든 저장소에서 동일하다면 훨씬 쉽게 익숙해질 것
      - 더 나은 오류 처리 : PEP-8에서 제안한 것 중 하나는 try/except 블록 내부의 코드를 최소화하자는 것. 실수로 예외를 숨기는 것을 방지하기 위한 것
      - 코드 품질 : 코드를 구조화하여 살펴보면 한 눈에 코드를 이해하고 버그와 실수를 쉽게 찾을 수 있음
- 문서화
  - 코드를 문서화하는 것은 코드에 주석을 추가하는 것(adding comments)과 다르다는 점
  - docstring과 어노테이션을 살펴봄
  - 코드 문서화는 파이썬에서 중요한 부분. 왜냐하면 변수의 타입이 동적이어서 변수나 객체의 값이 무엇인지 잃어버리기 쉽기 때문. 이러한 이유로 타입 정보를 명시해두는 것이 좋음
  - 어노테이션을 사용하는 특별한 이유 중의 하나는 어노테이션의 mypy 또는 pytype과 같은 도구를 사용해 변수 타입 힌트와 같은 자동화에 도움을 주기 때문
  - 코드 주석
    - 가능한 한 적은 주석을 갖는 것을 목표로 해야 함
    - 좋은 코드는 코드 자체가 문서화되어 있기 때문. 의미 있는 함수나 객체를 통해 책임을 분리하는 것과 같은 올바른 추상화를 했고 명확하게 이름을 지정했다면 주석이 필요하지 않아야 한다는 것을 의미함
    - 어떤식으로도 정당화하기 어려운 나쁜 주석도 있음. 바로 주석 처리된 코드. 이러한 코드는 무자비하게 바로 삭제되어야 함. 코드는 개발자 간의 대화 수단이며 전체 디자인을 반영하는 궁극적인 표현 수단이라는 점을 기억하자. 코드는 지식의 표현이다. 주석 처리된 코드는 해당 지식을 오염시킬 뿐만 아니라 대부분의 경우에 혼란을 가져옴
    - 특히 최신 버전 제어 시스템에서는 간단히 삭제하거나 다른 곳에 옮길 수 있는(stash) 기능이 있기 때문에 주석 처리된 코드를 남겨둘 이유가 없음
    - 문서화는 코드의 설계 방식이나 아키텍처를 명확하게 설명하는 것을 의미하며 이는 긍정적인 효과를 가져옴
  - Docstring
    - docstring은 소스 코드에 포함된 문서라고 말할 수 있음. docstring은 기본적으로 리터럴 문자열이며, 로직의 일부분을 문서화하기 위해 코드 어딘가에 배치됨. 문서라는 단어에 주목하자. 즉 이유가 아니라 설명임
    - Docstring은 모듈, 클래스, 메서드 또는 함수에 대해 문서를 제공하기 위한 것. 내가 작성한 컴포넌트를 다른 엔지니어가 사용하려고 할 때 docstring을 보고 동작방식과 입출력 정보 등을 확인할 수 있어야 함. 최대한 docstring을 추가하려고 노력하는 것은 좋은 습관
    - Docstring을 가진 코드가 좋은 (또는 프로젝트 표준에 필수이기도 한) 이유는 파이썬이 동적인 데이터 타입을 갖기 때문. 파이썬의 함수는 파라미터 값으로 어떤 데이터 타입도 취할 수 있음 
    - Sphinx(스핑크스)를 실행하면 프로젝트 문서화를 위한 기본 골격을 만들어줌. 특히 autodoc 익스텐션(sphinx.ext.autodoc)을 사용하면 코드에서 docstring을 가져와 문서화된 페이지를 만들어줌
    - 문서화 도구를 사용할 준비가 되었으면 문서가 프로젝트와 하나가 되도록 해당 도구를 오픈해야 함. 오픈소스 프로젝트라면 read the docs와 같은 도구를 사용하여 브랜치나 버전별 문서를 자동으로 생성할 수 있음
    - docstring의 한 가지 단점은 지속적으로 수작업을 해야 한다는 것. 코드가 변경되면 업데이트를 해야 함.
    - docstring이 정말 유용하게 사용되려면 여러 줄에 걸쳐 상세하게 작성해야 한다는 것. 이러한 점에 비춰볼 때 만약 함수가 너무 간단하고 자명한 코드라면 중복된 의미를 가진 docstring을 피하는 것이 더 나은 선택일 수 있음. 나중에 불필요한 유지 보수를 하지 않아도 되기 때문
  - 어노테이션
    - 기본 아이디어는 코드 사용자에게 함수 인자로 어떤 값이 와야 하는지 힌트를 주자는 것
    - 어노테이션을 사용해 변수의 예상 타입을 지정할 수 있음
    - > locate.__annotations__
    - 문자 생성, 유효성 검증 또는 타입 체크
    - 타입 힌트는 인터프리터와 별개로 데이터 타입이 바르게 사용되었는지 확인하는 도구를 제공하고, 사용자에게 호환되지 않는 데이터 타입을 사용한 경우 무엇이 잘못되었는지 힌트를 주기 위한 것
    - 린터(linter : 정적 코드 분석 도구) 이러한 도구를 사용하면 테스트 중에 바로 버그를 찾을 수 있으므로 다른 정적 분석 도구와 함께 mypy나 pytype을 함께 사용하는 것이 좋음 
    - ```python
      from typing import Tuple
      Client = Tuple[int, str]
      def process_clients(clients: list[Client]):
      ```
    - docstring에 포함된 정보의 일부는 어노테이션으로 이동시킬 수 있는 것이 사실임. docstring을 통해 보다 나은 문서화를 위한 여지를 남겨두어야 함. 동적 데이터 타입과 중첩 데이터 타입의 경우 예상 데이터의 예제를 제공하여 어떤 형태의 데이터를 다루는지 제공하는 것이 좋음
    - ```python
      def data_from_response(response: dics) -> dict:
        """response의 HTTP status가 200이라면 response의 payload를 반환
        
        - response 사전의 예제 ::
        {
            "status"; 200, # <int>
            "timestamp": "....", # 현재 시간의 ISO 포맷 문자열
            "payload": { ... } # 반환하려는 사전 데이터 
        }
        - 반환 사전 값의 예제::
        {"data": { .. } }
        - 발생 가능한 예외:
        - HTTP status가 200이 아닌 경우 ValueError 발생 
        """
        if response["status"] != 200:
            raise ValueError
        return {"data" : response["payload"]}
      ```
