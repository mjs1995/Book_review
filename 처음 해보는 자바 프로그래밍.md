# 서평

# 자바
- 프로그램 언어
  - 프로그램 언어 : 컴퓨터상에서 어떤 일을 처리하기 위해 기술하는 언어
  - 종류 : C, C++, C#, java, JavaScript, Python 등등
- 자바의 역사
  - 1995년에 최초로 발표 됨
  - 2000년대 중반 이후 세계에서 가장 많이 사용되는 프로그래밍 언어
  - 2009년 오라클로 인수 합병 되었음
- 프로그램 개발 순서
  - 소스 파일
    - 사람이 사용하기 편리한 언어로 사용하여 처리 방법을 기술한 파일
    - 확장자 Java
  - 컴파일 : 소스 파일로 표현된 언어를 0과 1로 변환함
  - 실행 파일
    - 소스파일을 컴파일하여 생성된 파일
    - 확장자 class
    - 바이트 코드로서 실행을 하기 위해서는 기계어 코드를 반환해야 함
  - JVM(Java Virtual Machine) : 바이트 코드를 기계어 코드로 변환하는 작업과 자바 실행에 관한 모든 일을 처리하는 프로그램
  - 개발환경 구축
    - JRE(Java Runtime Environment)
      - 자바 프로그램을 실행하기 위한 JVM과 실행에 필요한 파일들을 포함함
    - JDK(Java Development Kit)
      - JRE와 프로그램 개발에 필요한 Tool을 포함함
    - 환경 변수 path에 %JAVA_HOME%\bin; 폴더경로를 추가하면 자바 프로그램 개발 Tool을 어떤 위치에서나 사용할 수 있음
    - 자바 컴파일 명령문(확장자 포함) - javac 소스파일명.java
    - 자바 실행 명령문(확장자 제외) - java 실행파일명
    - 자바 실행 시 public static void main(String[] args)의 {} 부분이 자동으로 실행됨

# 기본문법 활용하기 
- 데이터 활용
  - 변수 기본  
    - 변수는 데이터가 저장된 메모리의 일정 공간을 의미함
    - 변수 선언이란 메모리에 데이터를 저장하기 위해 일정한 공간을 확보하고 이름을 지정하는 것을 의미함
    - 변수 선언 문법 - 데이터 타입 변수이름;
    - 변수의 이름은 영문자로 시작하며 한단어로 표현함
    - 선언된 변수에 값을 저장하는 문법 - 변수 이름 = 값;
    - 자바의 변수의 타입 - 기본 데이터 타입, 참조 데이터 타입
  - 데이터 종류
    - 논리 타입 : true와 false의 값만 가질 수 있으며 boolean으로 선언함
    - 문자 타입 : 문자 한글자를 저장할 수 있으며, char으로 선언함
    - 정수 타입 : byte, short, int, long으로 선언함
    - 실수 타입 : float, double 으로 선언함
    - 8가지 기본 타입을 제외한 타입은 모두 참조타입으로서 메모리 주소 값이 저장됨
- 실행순서 제어
  - switch문 : 괄호 안의 변수값과 case의 데이터를 비교하여 일치하는 경우 실행문을 실행
  - do while문 : do의 블록 {}을 실행 한 후 조건식 검사
- 배열 활용
  - 배열 개요
    - 배열의 장점
      - 배열이란 동일한 타입의 변수들을 순차적으로 메모리에 저장한 후, 첫 번째 변수의 메모리 주소 값만 이용해 인접한 변수를 접근하는 구조
      - 배열의 장점 : 순차적인 접근으로 인해 접근 속도가 빠름
    - 배열의 구현
      - 배열을 메모리에 생성함
      - 생성된 배열의 시작 주소 값을 변수에 저장함
      - 인덱스를 이용해 배열 안의 값에 접근함
  - 명령형 매개 변수
    - main 메소드의 인자로 전달되는 배열로서 실행할 때 배열 값을 지정함
    - java test apple banana peach
    - static void main(String[] args)
- 객체 지향
  - 클래스 객체
    - 객체 : 속성과 행동으로 이루어졌으며 객체 지향 프로그램의 기본 작업 단위
    - 객체 모델링 : 속성과 행동으로 구성된 하나의 단위로 추출하는 작업
  - 클래스 다이어그램
    - 객체 모델링에서 표현된 구조를 프로그램 언어로 표현하기 쉽게 작성된 다이어그램
    - 클래스 다이어그램을 기반으로 자바 소스 파일을 작성함
  - 클래스 개요
    - 접근 제어자 : 접근하여 사용할 수 있는 권한
    - private : 같은 클래스 일 경우
    - (default) : 같은 패키지 일 경우
    - protected : 같은 패키지 혹은 상속관계일 경우
    - public : 조건 없음
  - 클래스 구성 요소
    - 자바 소스 파일의 레이아웃
    - ```java
      package 패키지 이름
      import 패키지 이름.객체 이름
      <제어자> class <클래스 이름>  
      {
        <변수 선언>
        <생성자 선언>
        <메소드 선언>
      }
      ```
    - 패키지 : 클래스 파일들을 분리하여 저장하는 디렉터리로서 하위 패키지로 분리 될수록 세분화됨
    - 자바 소스의 첫 번째 코드는 클래스가 소속된 패키지 경로를 package문으로 선언함
    - 다른 패키지에 있는 클래스를 사용할 때는 import문으로 사용하는 클래스의 이름을 패키지명과 함께 선언해야 함
    - 변수를 선언하는 문법 : <제어자> <데이터 타입> <변수 이름>;
    - 메소드
      - 객체의 행동을 프로그램으로 표현할 때 사용하는 용어
      - <제어자> <리턴 타입> <이름>([<변수 이름>]){
      - [<실행문<]
      - }
    - return문 : 메소드를 종료하는 명령문이며 메소드를 호출하는 곳에 돌려주는 값이 있는 경우는 return문 다음에 값을 지정함
    - 매개 변수
      - 메소드를 호출하는 곳에서 전달하는 값을 저장하는 변수
      - 메소드를 호출하면서 전달하는 값을 인자 값이라고 하며, 매개 변수는 인자 값 수만큼 인자 값의 타입으로 선언해야 함
    - 메소드 오버로딩
      - 하나의 클래스에서 동일한 이름의 메소드를 중복해서 선언하는 것
      - 메소드 실행 시 다양한 인자 값을 받아 처리하기 위해 사용함

# 언어특성 활용하기
- 객체 지향 구현
  - 인스턴스
    - 클래스 생성
      - 클래스 선언이 완료된 후 객체를 사용하기 위해서는 메모리에 객체를 생성해야 함
      - 메모리에 객체를 생성하는 명령문
      - new 클래스 이름()
      - 인스턴스 : new 명령문에 의해 생성된 객체   
    - 자바의 메모리 : JVM 메모리구조는 코드영역, 힙영역, 스택영역으로 구성됨
    - 코드 영역: 실행 코드들이 사용하는 영역
    - 힙 영역 : 멤버변수들이 사용하는 영역
    - 스택영역 : 지역변수들이 사용하는 영역
    - 참조 변수 : 힙에 생성된 인스턴스의 주소 값을 가지는 변수
    - static
      - static으로 선언된 변수는 프로그램 시작 시 코드 영역에 자동 생성됨
      - static으로 선언된 메소드는 프로그램 시작 시 메소드를 사용할 수 있는 준비가 완료됨
      - static으로 선언된 블록은 프로그램 시작 시 자동으로 실행됨
  - 생성자
    - 객체 생성 시 자동으로 호출되는 메소드로서 리턴 값을 가지지 않으며 메소드 이름이 클래스 이름과 동일함
    - 생성자 오버로딩 : 매개 변수의 타입과 개수를 다르게 선언하여 동일한 이름으로 생성자를 여러 개 선언하는 것
    - 기본 생성자 : 인자 값을 받지 않는 생성자를 의미하며 생서자 선언이 없는 경우에 컴파일시 자동으로 선언됨
    - this
      - 현재 객체 자신의 주소를 가지는 키워드
      - 멤버변수와 지역변수 이름이 동일할 때는 멤버 변수를 나타날 때는 this. 변수 이름으로 표현함
      - 생성자 안에서 this() 형태로 자신의 다른 생성자를 호출할 수 있음 
- 상속과 인터페이스
  - 상속
    - 클래스들의 중복적인 내용을 별도의 클래스에 정의한 후 사용하는 것
    - 클래스 간에 is a 관계가 성립하는 경우 상속이 가능함
  - 상속의 구현
    - extends 키워드는 다른 클래스를 상속할 때 사용함
    - 부모 클래스 : 상속해 주는 클래스
    - 자식 클래스 : 상속 받는 클래스
  - 상속 활용
    - 메소드 오버라이딩
      - 상속 받은 메소드의 내용을 재정의하는 것
      - 규칙
        - 상속 받은 메소드 바디만 변경 가능
        - 상속 받은 메소드 선언부는 변경 불가능
        - 접근 제어자는 동일 또는 큰 범위로 변경 가능
    - super
      - 상속해주는 클래스를 나타내는 키워드
      - super.변수 또는 super.메소드() 형태로 부모 클래스의 멤버에 접근 가능
      - 부모 클래스의 생성자 호출 : super();
    - final
      - final로 선언된 클래스는 상속 불가능
      - final로 선언된 변수의 값 변경 불가능
      - final로 선언된 메소드는 오버라이딩 불가능
  - 추상개념
    - 추상 메소드 : 메소드의 바디를 구현하지 않고 abstract로 선언된 메소드
    - 추상 클래스 : 추상 메소드를 하나라도 가지고 있는 클래스를 의미하며, abstract로 선언해야 함
  - 인터페이스
    - 추상 메소드만을 갖는 객체이며, 선언되는 메소드는 모두 public abstract로 인식됨
    - 인터페이스에 선언된 모든 변수는 public static final로 인식됨
    - default 메소드는 인터페이스를 상속하는 모든 클래스에서 공통으로 갖는 기능을 구현함
    - static 메소드는 프로그램 시작 시 사용준비가 완료되는 메소드임
    - 인터페이스를 상속할 때 implements 키워드를 사용함
    - 인터페이스는 다중 상속이 가능함 
- 다형성과 내부 클래스
  - 다형성
    - 다형성은 참조 변수의 타입을 자신 또는 상속받는 상위 타입으로 선언하는 것을 의미함
    - 다형성의 원리
      - 다형성이 가능한 이유는 객체 생성 시 실제 상속받는 객체가 메모리에 생성되기 때문
      - java.lang.Object 객체는 모든 자바 클래스의 상위 객체이며 자바의 모든 참조 변수는 Object 타입으로 선언될 수 있음
    - 다형성의 필요성
      - 다형성을 적용하여 매개변수의 타입을 선언한 메소드는 자신뿐만 아니라 모든 하위 객체를 인자로 전달 받아 실행할 수 있기 때문에 하나의 메소드로 기능구현이 가능함
    - 다형성의 활용
      - 다형성이 적용된 참조 변수의 타입을 판별하기 위해 instaceof 연산자를 사용함
      - 상위 타입으로 선언된 참조 변수는 상위 객체의 내용만 접근이 가능하기 때문에 원래의 타입으로 변경한 후 사용해야 함
  - 내부 클래스
    - 클래스 선언 시 멤버로서 변수, 메소드뿐만 아니라 클래스를 정의하는 것
    - 내부 클래스를 갖는 클래스는 외부 클래스라고 함
    - 내부 클래스는 주로 외부 클래스에서만 사용이 됨
    - 내부 클래스의 종류
      - instance class는 static 없이 선언된 내부 클래스이며 외부 클래스 생성 후 내부 클래스를 생성해야 사용할 수 있음 
      - static class는 static으로 선언된 내부 클래스로 외부 클래스 생성 없이 외부 클래스명.내부 클래스명.메소드() 형태로 사용함
      - local class는 메소드 안에서 선언된 클래스로서 메소드 내부에서만 사용됨
      - 익면 클래스
        - 인스턴스를 한번만 생성하여 사용을 하고 더 이상 사용할 일이 없는 경우 사용함
        - 부모 이름으로 인스턴스를 생성하면서 동시에 클래스의 바디{}를 선언
- 기본 API 활용
  - API 문서
    - 라이브러리 : 특정 기능을 구현하여 제공하는 파일 들
    - 자바 API : 자바의 라이브러리를 자바 API라고 함
  - 기본 API
    - Object: 모든 자바 클래스의 최상위 클래스
      - 인스턴스의 고유한 해쉬 코드를 추출 : hashCode()
      - 클래스 이름과 16진수 해쉬 값을 리턴 : toString()
      - 참조 값이 동일한 경우 true를 리턴 : equals()
    - String : 문자열을 처리하는 객체이며 원본이 변경되지 않음
      - 문자열 비교 : equals() / equalsignoreCase()
      - 문자열의 길이값 리턴 : length()
      - 양끝의 공백 제거 : trim()
      - null 문자열인지 판단 : isEmpty()
      - 문자열 검색 : indexOf / LastindexOf / startsWith() / endsWith()
      - 문자열 수정 : concat() / replace() / toLowerCase() / toUpperCase()
      - 문자열 추출 : split() / substring()
    - StringBuffer / StringBuilder
      - string처럼 문자열에 관한 메소드를 제공하지만 원본이 변경된다는 차이점이 있음 
      - StringBuffer : 동시접근에 대한 처리가 된 객체
      - StringBuilder : 동시접근에 대한 처리가 되지 않은 객체
      - Math : 수학적인 계산에 관한 기능을 제공하는 메소드를 가지는 객체
      - Wrapper 클래스 : 기본 데이터 타입에 대한 처리를 하기 위해 만들어진 객체
  - 유틸 API
    - StringTokenizer : 문자열을 분리하는 기능을 가진 객체
    - Random : 난수를 발생시키는 메소드를 제공하는 객체
    - Arrays : 배열에 관한 여러가지 기능들을 제공하는 객체
    - Date/Calendar : 날짜/시간에 관련된 기능을 제공하는 객체
    - SimpleDateFormat : 날짜의 출력 형식에 관해 지원을 하는 객체
    - MessageFormat : 문자열의 출력 형식에 관해 지원을 하는 객체
    - DecimalFormat : 숫자의 출력 형식에 관해 지원을 하는 객체 
- Collection API 활용
  - Collection 개요
    - 배열의 특성
      - 배열은 초기에 정해진 크기를 변경할 수 없음
      - 배열에 저장된 데이터를 삽입, 삭제할 때는 데이터들의 이동이 발생함
    - Collection Framework
      - Collection Framework의 객체들은 자료 구조적인 특성대로 알고리즘(실행)들이 구현되어 별도의 구현작업 없이 바로 사용이 가능
      - 데이터를 그룹으로 처리할 때 크기가 유동적으로 변경될 수 있음
      - 메모리의 효울성, 데이터 처리 작업의 효율성을 고려하여 다양한 기법을 제공함
  - List 계열
    - ArrayList
      - 배열의 구조처럼 순차적으로 데이터들이 저장되며 인덱스를 사용함
      - 저장되는 데이터의 순서가 유지되며 중복된 데이터 저장 가능
      - Iterator는 Collection에 저장된 모든 데이터를 순차적으로 접근할 때 빠른 처리속도를 제공함
    - Vector
      - ArrayList와 동일한 클래스이며 차이점은 동시 접근에 대한 처리가 됨
    - LinkedList
      - 데이터가 저장될 때 데이터와 다음 또는 이전 데이터의 위치 정보가 함께 저장됨
      - 저장되는 정보의 단위 : 노드
  - MAP 계열
    - Map.Entry
      - Map은 Key와 Value 단위로 저장되며 Map.Entry 내부 클래스에서 Key와 Value 정보를 갖음
    - HashMap
      - 여러 개의 Map.Entry를 갖는 Collection 객체
      - null 값으로 Key와 Value 저장이 가능함
    - Hashtable
      - 여러 개의 Map.Entry를 갖는 Collection 객체
      - null 값으로 key와 Value 저장이 불가능함
      - 동기화 처리가 되어 있음
    - TreeMap
      - TreeMap은 Tree 구조로 데이터의 저장, 삽입, 삭제, 검색 작업함
      - 작업의 시작위치는 항상 루트임
      - 저장 시 자동 정렬이 이루어짐
  - Set 계열
    - HashSet
      - 저장되는 데이터의 순서를 유지하지 않음
      - 중복된 데이터를 저장할 수 없음
      - Collection 중에서 가장 빠른 검색 속도를 가짐
    - TreeSet
      - Set과 Tree의 특성을 동시에 갖는 객체
      - 저장되는 데이터의 순서가 유지되지 않고 중복된 값을 저장할 수 없음
      - 데이터 저장 시 tree 구조 형태를 사용하기 때문에 자동 정렬됨 
      - Enumeration은 Iterator처럼 순차적으로 모든 데이터를 접근할 때 빠른 처리속도를 제공하며 동기화 처리가 된 객체임 
- 예외 처리
  - 자바 예외 API
    - 예외 처리 객체 구조
      - Throwable : 예외 객체의 최상위 객체
      - 모든 프로그램적인 오류 객체들은 Exception을 상속받음
    - 예외 발생 원리
      - 오류가 발생하면 JVM은 해당하는 예외 객체(~Exception)를 생성함
      - 오류 처리를 별도로 하지 않은 상태에서 오류가 발생하면 프로그램이 강제로 종료됨
  - 예외 처리 방법
    - try-catch문
      - try{} 괄호 안에 예외 처리 대상 코드를 작성함
      - catch문은 try 블록에서 오류가 발생했을 경우 처리할 내용을 구현함
      - catch문은 매개 변수 타입은 처리할 오류의 예외 객체 타입으로 선언함 
    - 예외 처리 메소드
      - Exception의 getMessage()는 오류 메시지를 리턴함
      - Exception의 printStackTrace()는 오류가 발생하기 까지의 과정을 역순으로 보여줌
    - finally
      - finally 블록은 try-catch문을 종료할 때 항상 수행됨
      - finally 블록은 일반적으로 자원 해제 작업을 구현함
    - try-with-resources
      - finally 블록에 구현하던 자원 해제 작업을 자동으로 하기 위한 구조
      - 문법 : try(자동으로 자원 해제할 객체 생성){ 실행문 }
  - throws 선언문
    - throws 필요성 : 메소드 실행 시 발생하는 오류에 대하여 동적으로 오류 처리를 하기 위해 사용함 
    - throws 선언 메소드 사용
      - throws 메소드 선언부에 선언하며 throws 다음에는 콤마(,)를 구분자로 예외 객체 이름을 나열함
      - throws가 선언된 메소드를 호출하는 곳에서는 throws하는 예외 객체를 처리해주어야 함
      - 처리하지 않은 경우 throws 선언을 해야 함
  - 사용자 정의 예외 객체
    - 객체 선언 : 사용자 정의 예외 객체를 생성하기 위해서는 Exception을 상속받아야 함
    - 객체 사용 : 사용자 정의 예외 객체를 발생하기 위해서 사용하는 명령문은 throw임 
- 입출력 작업
  - 입출력 원리
    - 자바는 외부 데이터와 입출력 작업을 할 때 스트림을 사용함
    - 입력 스트림 : 외부 데이터를 읽어오는 기능
    - 출력 스트림 : 외부로 데이터를 출력하는 기능 
  - 입출력 API
    - 자바 API는 java.io 패키지에 외부 데이터를 입출력할 수 있는 API들을 제공함
    - ~InputStream 또는 ~Reader 이름의 객체는 입력 스트림 객체
    - ~OutputStream 또는 ~Writer 이름의 객체는 출력 스트림 객체
  - 기본 입출력 작업
    - 파일 입출력
      - FileInputStream : 파일로부터 데이터를 입력 받기 위한 입력 스트림
      - FileOutputStream : 파일로 데이터를 출력하기 위한 출력 스트림
    - 표준 입출력
      - System.in : 표준 입력 스트림
      - System.out : 표준 출력 스트림
    - 필터 스트림 활용
      - 입출력 작업 시 부가적인 기능을 사용하기 위한 객체
      - BufferedReader는 줄단위로 읽기가 가능한 readLine() 메소드를 제공함
  - 다양한 입출력 방식
    - 바이트 배열
      - 입력 스트림의 read(바이트 배열)를 사용하여 바이트 배열의 데이터를 읽을 수 있음
      - ByteArrayOutputStream은 바이트 배열로 데이터를 출력하는 출력 스트림
    - File : 파일 또는 디렉터리에 관련된 기능을 지원하는 객체
    - RandomAccesFile : 파일의 임의의 위치에 데이터를 읽고 쓰기 위한 객체
    - 프로퍼티 파일
      - 확장자가 property인 파일은 텍스트 파일로서 데이터가 name=value 형태로 저장됨
      - Properties는 프로퍼티 파일에 데이터를 읽고 쓰기 위한 객체
    - FileChannel
      - 고속으로 파일의 데이터를 읽고 쓸 수 있도록 지원하는 객체
    - 압축 파일
      - ZipOutputStream : 파일들을 압축하여 압축 파일을 생성하는 객체
      - ZipInputStream : 압축된 파일들을 해제하는 객체
  - 객체 직렬화 
    - Serializable : 인터페이스를 상속받은 자바 객체는 입출력 작업을 할 수 있음
    - serialVersionUID 필드
      - 객체를 직렬화하여 입출력 작업을 할 때는 객체의 고유한 인식번호를 부여할 수 있음
      - 객체의 고유한 인식번호를 저장하는 필드 
- 스레드
  - 스레드는 경량 프로세스로서 동시에 여러 개의 명령문들을 실행할 수 있음 
  - 스레드 생성
    - Thread 클래스
      - 스레드 형태로 실행할 객체를 구현할 때 상속받는 객체
      - 스레드로 동작할 실행문은 run() 메소드에 구현함
      - run() 메소드 실행 : 객체 생성 후 start() 메소드를 호출
    - Runnable 인터페이스
      - 스레드 형태로 실행할 객체를 구현할 때 상속받는 객체
      - 스레드로서 동작할 실행문은 run() 메소드에 구현함
      - run() 메소드를 실행하기 위해 Thread 클래스를 생성해야 함
      - Thread 클래스 생성 시 인자값으로 Runable 상속하는 객체를 전달함
      - run() 메소드 실행 : 생성된 Thread 클래스의 start() 메소드를 호출
    - Thread 설정
      - 스레드를 제어하기 위해 스레드에 setName()으로 이름을 지정할 수 있음
      - 동시에 실행되는 여러 스레드는 setPriority()로 실행되는 우선 순위를 지정할 수 있음
  - 동기화
    - 동기화는 하나의 자원을 여러 스레드가 동시에 사용할 때 자원의 안전성을 확보하기 위해 처리하는 기능임
    - 특정 객체 : synchronized(객체 이름)로 특정 객체에 대하여 동기화를 지정할 수 있음
    - 메소드 : 메서드 선언부에 synchronized를 선언하여 메소드 단위로 동기화를 지정할 수 있음
    - 스레드 상태
      - Runnable 상태 : 실행하기 위한 대기 상태
      - Running 상태 : 현재 실행 중인 상태
      - Terminated 상태 : 실행을 종료한 상태
  - 스레드 제어
    - wait() : 스레드 대기 상태
    - notify()/notifyAll() : 스레드 대기상태 해제
    - join() : 특정 스레드의 실행 종료를 기대라는 메소드
    - sleep() : 인자로 지정된 시간동안 스레드의 실행을 잠시 멈춤
    - interrup() :스레드의 상태를 종료시킴
    - ThreadPool : 스레드를 효율적으로 사용할 수 있도록 관리하는 기술
    - Semaphore : 제한된 자원을 효율적으로 활용하기 위한 기술, 실행할 수 있는 스레드 수를 제어하기 위한 카운터 제공 
