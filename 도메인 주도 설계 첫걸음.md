# 서평
- 이 책은 전략적 설계, 전술적 설계, DDD 실무, DDD와 다른 방법론 및 패턴과의 관계로 크게 네 개의 패턴으로 나뉘어 집니다. 대형 소프트웨어 설계 의사결정에 필요한 도구와 기법에 대해 배우며 시스템의 비즈니스 로직을 구현하는 다양한 방법에 대해 코드를 중심으로 배웁니다. 또한 실제 프로젝트에 DDD를 적용하는 전략과 기법을 논의하며 도메인 주도 설계에 대해 논의하고 다른 방법론과 패턴 맥락에서 DDD에 대해 배웁니다. 

# 전략적 설계
- 도메인 주도 설계(DDD: Domain-Driven Design)는 크게 2가지로 나눌 수 있다. 전략적 설계(strategic design) 단계에서 개발자와 비즈니스 전문가는 초기부터 협력하여 비즈니스 문제, 즉 도메인을 이해하고 문제를 서로 연결된 풀기 쉬운 작은 크기로 쪼갠다. 전술적 설계(tactical design)로서, 앞서 발견한 전략적 설계를 소프트웨어 아키텍처와 구현으로 전환시키는 단계다. DDD는 도메인을 잘 구성해 복잡성을 회피할 수 있는 가이드와 패턴을 제공한다. 
- DDD의 전략적인 측면은 무엇?과 왜?라는 질문에 대한 정답을 찾는 것. 우리가 어떤 소프트웨어를 만드는지, 그리고 왜 그 소프트웨어를 만드는지에 대한 해답을 찾는 것. 
- 전술적 측면은 어떻게?라는 방법에 대한 것으로 소프트웨어 각각의 구성요소가 구현되는 방법을 찾는 것

## 비즈니스 도메인 분석하기 
- 비즈니스 도메인은 기업의 주요 활동 영역으로 회사가 고객에게 제공하는 서비스를 말함
- 하위 도메인
  - 하위 도메인은 비즈니스 활동의 세분화된 영역
  - 핵심 하위 도메인은 회사가 경쟁업체와 다르게 수행하고 있는 것 
  - 일반 하위 도메인
    - 모든 회사가 같은 방식으로 수행하는 비즈니스 활동
    - 일반 하위 도메인은 회사에 경쟁력을 제공하지 않음. 이미 실무에서 검증된 솔루션으로 널리 이용 가능하며, 모든 회사에서 사용하고 있어서 더 이상 혁신이나 최적화가 필요 없음 
  - 지원 하위 도메인
    - 회사의 비즈니스를 지원하는 활동
    - 핵심 하위 도메인과 달리 지원 하위 도메인은 어떠한 경쟁 우위도 제공하지 않음 
- 도메인 분석 예제
  - BusVNext
    - 대중교통 회사. 고객에게 택시를 잡는 것처럼 쉽게 버스를 타는 경험을 제공하는 것이 목표
    - 핵심 하위 도메인
      - 라우팅
      - 분석
      - 모바일 앱 사용자 경험
      - 차량 관리
    - 일반 하위 도메인
      - 교통 상황
      - 회계
      - 청구
      - 권한 부여 
    - 지원 하위 도메인, 프로모션과 관리 모듈은 회사의 핵심 비즈니스를 지원함 
    - 설계 의사결정
      - 몇 가지 전략적인 설계 의사결정
        - 라우팅 알고리즘, 데이터 분석, 차량 관리, 앱 사용성은 가장 정교한 기술 도구와 패턴을 사용해서 사내에서 개발해야 함 
        - 판촉 관리 모듈의 구현은 외부에 위탁할 수 있음 
        - 교통 상황 식별, 사용자 권한 관리, 재무 및 거래 기록 관리는 외부 서비스 제공 업체에 맡길 수 있음 
- 도메인 전문가(domain expert) : 우리가 모델링하고 코드로 구현할 비즈니스의 모든 복잡성을 알고 있는 주제 전문가로 도메인 전문가는 소프트웨어의 비즈니스 도메인에 대한 권위자 

## 도메인 지식 찾아내기
- 비즈니스 문제
  - 우리가 개발하는 소프트웨어 시스템은 비즈니스 문제를 해결하는 솔루션 
  - 비즈니스 문제는 워크플로와 프로세스 최적화, 수작업 최소화, 자원 관리, 의사결정 지원, 데이터 관리 등과 관련된 과제일 수 있음 
  - 비즈니스 문제는 비즈니스 도메인과 하위 도메인의 모든 수준에서 발생할 수 있음 
- 도메인 지식 찾아내기
  - 효과적인 소프트웨어는 도메인 전문가가 문제를 생각하는 방식, 즉 멘탈 모델을 모방해야 함 
- 커뮤니케이션
  - 거의 모든 소프트웨어 프로젝트에는 도메인 전문가, 프로젝트 소유자, 엔지니어, UI와 UX 디자이너, 프로젝트 매니저, 테스터, 분석가 등 다양한 역할의 이해관계자의 협업이 필요하다고 할 수 있음 
  - 전형적인 소프트웨어 개발 생애주기에서 도메인 지식은 분석 모델(analysis model)로 알려진 엔지니어 친화적인 형태로 변환됨. 분석 모델은 도메인 지식 이면에 존재하는 비즈니스 도메인에 기반하기보다는 시스템 요구사항을 설명한 것에 지나지 않음 
- 유비쿼터스 언어
  - 참가자들이 효과적으로 소통하기 위해 변환에 의존하지 말고 같은 언어를 사용하는 것 
  - 전통적인 소프트웨어 개발 생애주기에서 변환이 어떻게 일어나는지 정리
    - 도메인 지식이 분석 모델로
    - 분석 모델이 요구사항으로 
    - 요구사항은 시스템 설계로
    - 시스템 설계는 소스코드로 
  - 도메인 주도 설계에서 이같이 도메인 지식을 계속해서 변환하는 대신, 비즈니스 도메인을 설명하기 위한 단일화된 언어 체계를 세우고자 하는데, 이것이 바로 유비쿼터스 언어 
- 비즈니스 언어
  - 유비쿼터스 언어는 도메인 전문가의 이해와 비즈니스 도메인에 대한 멘탈 모델을 쉽게 이해할 수 있는 관점으로 표현하는 것을 목표로 함
  - 시나리오
    - 광고 캠페인 관리 시스템 만들시 가정 
      - 광고 캠페인은 다양한 창의적인자료를 전시할 수 있다
      - 캠페인은 최소한 하나의 광고 할당이 활성화되어야 게시된다
      - 판매 커미션은 거래가 승인된 후에 회계 처리된다
    - 모든 문장은 비즈니스 언어로 작성됐음. 문장은 비즈니스 도메인을 바라보는 도메인 전문가의 시각을 반영함. 
    - 철저하게 기술적이어서 유비쿼터스 언어의 개념에 맞지 않은 문장
      - 광고의 아이프레임(iframe)은 HTML 파일을 표시함
      - 캠페인은 활성-할당(active-placement) 테이블에 하나의 연관 레코드가 있어야 게시됨
      - 판매 커미션은 거래(transaction) 테이블과 판매-승인(approved-sales) 테이블의 연관 레코드에 근거하여 처리됨 
    - 일관성
      - 가정할 필요가 없어야 하고 비즈니스 도메인의 로직을 명료하게 표현해야 함 
    - 모호한 용어 
    - 동의어 : 유비쿼터스 언어에서 두 용어는 서로 바꿔 사용할 수 없음 
- 비즈니스 도메인 모델
  - 효과적인 모델링
    - 모든 모델에는 목적이 있고 효과적인 모델은 그 목적을 달성하는 데 필요한 세부사항만 포함함
    - 유용한 모델은 실세계의 복사본이 아니라 문제를 해결하려는 의도가 있으며, 그 목적에 필요한 정보만 제공해야 함 
  - 도구
    - 위키는 유비쿼터스 언어를 수집하고 관리하는 용어집(glossary)으로 사용될 수 있음. 이런 용어집은 비즈니스 도메인의 용어에 대한 정보를 얻을 수 있는 거점 역할을 하므로 새로운 팀원이 쉽게 적응하게 해줌 

## 도메인 복잡성 관리
- 바운디드 컨텍스트 
  - 유비쿼터스 언어를 여러 개의 작은 언어로 나눈 다음 각 언어를 적용할 수 있는 명시적인 바운디드 컨텍스트(bounded context)에 할당
  - 모델의 경계(바운디드 컨텍스트)를 정의하는 것은 모델링 프로세스의 본질적인 부분 
- 실생활의 바운디드 컨텍스트
  - 시맨틱 도메인(semantic domain)
    - 의미 영역과 해당 의미를 전달하기 위해 사용하는 단어 영역으로 구분함 

## 바운디드 컨텍스트 연동
- 컨트랙트(contract) : 바운디드 컨텍스트 사이에는 항상 접점이 있는데 이것을 의미함 
- 각 컨트랙트는 하나 이상의 당사자에 영향을 끼치므로 서로 조율해서 컨트랙트를 정의해야 함 
- 협력형 패턴 그룹
  - 단일 팀에 의해 구현된 바운디드 컨텍스트
  - 한 팀의 성공이 다른 팀의 성공에 달려있고, 그 반대도 마찬가지인 의존적 목표가 있는 팀에 해당됨 
  - 파트너십 패턴
    - 파트너십 모델에서 바운디드 컨텍스트 간의 연동은 애드혹(ad-hoc) 방식으로 조정함. 한 팀은 다른 팀에게 API의 변경을 알리고 다른 팀은 충돌 없이 이를 받아들임 
- 사용자-제공자 패턴 그룹
  - 제공자는 사용자에게 서비스를 제공함. 서비스 제공자는 업스트림이고 고객 또는 사용자는 다운스트림이다 
  - 양 팀(업스트림과 다운스트림)은 서로 독립적으로 성공할 수 있음. 업스트림 또는 다운스트림의 팀이 연동 컨트랙트를 주도하는 권력의 불균형이 존재함. 
  - 힘의 차이를 보여주는 세 가지 패턴
    - 순응주의자 패턴
      - 힘의 균형이 서비스를 제공하는 업스트림 팀에 있는 경우가 있음. 사용자의 요구를 지원할 동기가 없는 경우가 그렇다.
      - 다운스트림 팀이 업스트림 팀의 모델을 받아들이는 바운디드 컨텍스트의 관계를 순응주의자(conformist) 패턴 
    - 충돌 방지 계층 패턴
      - 순응주의자 패턴에서 힘의 균형은 업스트림 서비스에 치우쳐 있음
      - 다운스트림 바운디드 컨텍스트가 이에 순응하지 않는 경우 표현한 충돌 방지 계층을 통해 업스트림 바운디드 컨텍스트의 모델을 스스로의 필요에 맞게 가공할 수 있음 
      - 다운스트림 바운디드 컨텍스트가 핵심 하위 도메인을 포함할 경우
        - 핵심 하위 도메인은 각별한 주의가 필요함. 제공자의 모델이 자칫 문제 도메인에 대한 모델링을 방해할 수 있음 
      - 업스트림 모델이 사용자의 요건에 비효율적이거나 불편한 경우
        - 바운디드 컨텍스트가 혼란에 순응하면 그 자체로 위험에 빠지게 됨. 이런 경우는 레거시 시스템과 연동할 때 종종 발생함 
      - 제공자가 컨트랙트를 자주 변경하는 경우
        - 사용자는 잦은 변경으로부터 모델을 보호하기를 원함. 충돌 방지 계층이 있으면 제공 모델의 변경은 변환 장치에만 영향을 미침 
    - 오픈 호스트 서비스 패턴
      - 힘이 사용자 측에 있을 경우를 처리함. 제공자는 사용자를 보호하고 가능한 최고의 서비스를 제공하는 데 관심이 있음 
      - 오픈 호스트 서비스(OHS: open-host service) 패턴은 충돌 방지 계층 패턴의 반대. 사용자 대신 제공자가 내부 모델 번역을 구현함 
- 분리형 노션(separated ways)
  - 분리형 노션 패턴에는 팀에 협업 의지가 없거나 협업할 수 없는 경우와 같이 다양한 이유가 있음 
  - 커뮤니케이션 이슈
  - 일반 하위 도메인
    - 중복된 하위 도메인의 특성도 협업 없이 분리된 길을 가야 하는 이유가 될 수 있음 
  - 모델의 차이
    - 바운디드 컨텍스트의 모델 간의 차이 
- 컨텍스트 맵
  - 컨텍스트 맵은 시스템의 바운디드 컨텍스트와의 연동을 시각적으로 표현함 
  - 거시적 설계 관점
    - 컨텍스트 맵은 시스템의 구성요소와 구현하는 모델의 개요를 제공함 
  - 커뮤니케이션 패턴
    - 컨텍스트 맵은 시스템의 구성요소 간의 커뮤니케이션 패턴을 묘사함. 예를 들어 어떤 팀이 협력하고, 충돌 방지 계층과 분리형 노선 패턴과 같은 덜 친밀한 연동 패턴을 선호하는지 보여줌
  - 조직적 문제
    - 컨텍스트 맵은 조직적 문제에 대한 통찰력을 제공함. 가령 특정 업스트림 팀의 다운스트림 사용자가 모두 충돌 방지 계층을 구현하는 데 의존하거나 분리형 노선 패턴의 모든 구현이 한 팀에 집중된다면 이는 무엇을 의미할까? 
- 바운디드 컨텍스트가 연동하는 다양한 방법
  - 파트너십 : 바운디드 컨텍스트는 애드혹 방식으로 연동됨
  - 공유 커널 : 두 개 이상의 바운디드 컨텍스트가 참여하는 모든 바운디드 컨텍스트가 공유하는 제한적으로 겹치는 모델을 공유해서 연동함
  - 순응주의자 : 사용자는 서비스 제공자의 모델에 순응함
  - 충돌 방지 계층 : 사용자는 서비스 제공자의 모델을 사용자의 요건에 맞게 번역함
  - 오픈 호스트 서비스 : 서비스 제공자는 사용자의 요건에 최적화된 모델인 공표된 언어를 구현함
  - 분리형 노선 : 협력과 연동보다는 특정 기능을 중복으로 두는 것이 더 저렴한 경우 

# 전술적 설계
## 간단한 비즈니스 로직 구현
- 트랜잭션 스크립트
  - 이 패턴은 시스템 작업을 간단하고 쉬운 절차지향 스크립트로 구성함. 이 절차는 작업에 트랜잭션을 적용해서 작업이 성공하거나 실패하도록 보장함. 트랜잭션 스크립트 패턴은 ETL처럼 단순한 비즈니스 로직을 가진 지원 하위 도메인에 적합함 
  - 트랜잭션 스크립트 패턴은 프로시저를 기반으로 시스템의 비즈니스 로직을 구성하며, 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현함 
  - 구현
    - 각 프로시저는 간단하고 쉬운 절차지향 스크립트(procedural script, 객체지향 언어와 대비되는 개념으로 ,절차지향은 순차적인 처리가 중요시되는 스크립트)로 구현함
    - 가장 곤란한 순간에 트랜잭션 스크립트 실행이 실패하더라도 시스템은 오류가 발생할 때까지 변경사항을 롤백하거나 보상조치를 실행하여 일관성을 유지해야 함 
  - 트랜잭션 동작 구현 실패
    - 트랜잭션 동작 구현에 실패한 간단한 예는 전체를 아우르는 트랜잭션 없이 여러 업데이트를 하는 경우
    - 만약 Users 테이블에 레코드가 업데이트되고 나서 로그 레코드를 성공적으로 추가하기 전에 문제가 발생한다면 시스템이 일관되지 않은 상태가 됨. Users 테이블은 업데이트되지만 VisitLog 테이블에는 해당 레코드가 기록되지 않음. 이 문제는 네트워크 중단, 데이터베이스 시간 초과 또는 교착 상태, 프로세스를 실행하는 서버의 충돌로도 발생할 수 있음 
  - 분산 트랜잭션
    - 최신 분산 시스템에서는 데이터베이스의 데이터를 변경한 다음 메시지 버스에 메시지를 발행하여 시스템의 다른 컴포넌트에 변경사항을 알리는 것이 일반적 
    - 여러 저장 장치에 걸쳐 있는 분산 트랜잭션은 복잡하고 확장하기 어렵고 오류가 발생하기 쉬우므로 일반적으로 피하는 방식 
    - 트랜잭션 동작을 보장하는 한 가지 방법은 작업을 멱등성(idempotent)으로 만드는 것. 같은 요청을 여러 번 반복하더라도 그 결과는 매번 동일하게 만드는 것 
    - 낙관적 동시성 제어(optimistic concurrency control)를 사용하는 것 
  - 트랜잭션 스크립트를 사용하는 경우
    - 트랜잭션 스크립트 패턴은 비즈니스 로직이 단순한 절차적 작업처럼 매우 간단한 문제 도메인에 효과적 
    - 트랜잭션 스크립트 패턴의 주요 장점은 단순함. 최소한의 추상화를 도입하여 런타임 성능을 최적화하고, 비즈니스 로직을 이해하기 위한 시간을 최소화함 
    - 비즈니스 로직이 복잡할수록 트랜잭션 간에 비즈니스 로직이 중복되기 쉽고 결과적으로 중복된 코드가 동기화되지 않을 때 일관성 없는 동작이 발생함. 결과적으로 핵심 하위 도메인에는 트랜잭션 스크립트를 사용하면 안됨 
- 액티브 레코드
  - 비즈니스 로직이 단순하지만 복잡한 자료구조에서 작동하는 경우 해당 자료구조를 액티브 레코드로 구현할 수 있음. 액티브 레코드 객체는 간단한 CRUD 데이터 접근 방법을 제공하는 자료구조 
  - 트랜잭션 스크립트 패턴과 마찬가지로 액티브 레코드는 비즈니스 로직이 단순한 경우 사용함. 액티브 레코드는 좀 더 복잡한 자료구조에서도 비즈니스 로직이 작동할 수 있음 
  - 구현
    - 액티브 레코드 객체는 객체 관계 매핑(ORM:object-relational mapping) 또는 다른 데이터 접근 프레임워크와도 관련이 있음. 각 자료구조가 액티브(active)하다는 점에서 패턴의 이름이 만들어졌음. 액티브 레코드는 데이터 접근 로직을 구현함 
    - 액티브 레코드의 경우 데이터베이스에 직접 접근하는 대신 트랜잭션 스크립트가 액티브 레코드 객체를 조작한다는 것. 작업이 완료되면 트랜잭션의 원자성(atmoic)으로 인해 작업이 성공하거나 실패함 
  - 액티브 레코드를 사용하는 경우
    - 액티브 레코드는 본질적으로 데이터베이스에 대한 접근을 최적화하는 트랜잭션 스크립트이기 때문에 사용자 입력의 유효성을 검사하는 CRUD 작업과 같은 비교적 간단한 비즈니스 로직만 지원할 수 있음 
    - 트랜잭션 스크립트 패턴과 마찬가지로 액티브 레코드 패턴은 지원 하위 도메인, 일반 하위 도메인과 외부 솔루션의 연동, 모델 변환 작업에 적함함. 두 패턴의 차이점은 액티브 레코드의 경우 복잡한 자료구조를 데이터베이스 스키마에 매핑하는 복잡성을 해소한다는 것 
    - 빈약한 도메인 모델 안티패턴(anemic domain model antipattern). 부적절하게 설계된 도메인 모델 

## 복잡한 비즈니스 로직 다루기
- 도메인 모델
  - 도메인 모델 패턴은 복잡한 비즈니스 로직을 다루기 위한 것. CRUD 인터페이스 대신 복잡한 상태 전환, 항상 보호해야 하는 규칙인 비즈니스 규칙과 불변성을 다룸 
  - SLA(응답 제한 시간)
  - 구현 
    - 도메인 모델은 행동과 데이터 모두를 포함하는 도메인의 객체 모델. DDD의 전술 패턴인 애그리게이트, 밸류 오브젝트, 도메인 이벤트, 도메인 서비스는 모두 객체 모델의 구성요소 
  - 밸류 오브젝트
    - 값만으로 식별되는 비즈니스 도메인의 개념이기 때문에 명시적인 ID 필드가 필요없음. 필드 중 하나가 변경되면 의미상 새로운 값을 생성하므로 밸류 오브젝트는 불변임
    - 색처럼 복합적인 값에 의해 식별되는 객체
    - 필드 중 하나의 값이 바뀌면 새로운 색이 탄생함. 같은 값을 갖는 두 개 이상의 색은 존재하지 않음. 같은 색의 두 인스턴스는 반드시 같은 값을 갖음 
    - 밸류 오브젝트를 사용하는 경우
      - 밸류 오브젝트는 가능한 모든 경우에 사용하는 게 좋음. 밸류 오브젝트는 코드의 표현력을 높여주고 분산되기 쉬운 비즈니스 로직을 한데 묶어줄 뿐만 아니라 코드를 더욱 안전하게 해줌. 밸류 오브젝트는 불변이기 때문에 내포된 동작은 부작용과 동시성 문제가 없음 
      - 경험상 비즈니스 도메인 관점에서 유용한 법칙은 다른 객체의 속성을 표현하는 도메인의 요소에 밸류 오브젝트를 사용하는 것 
  - 엔티티
    - 엔티티는 다른 엔티티 인스턴스와 구별하기 위해 명시적인 식별 필드가 필요함 
    - 밸류 오브젝트와는 반대로, 엔티티는 불변이 아니고 변할 것으로 예상됨. 밸류 오브젝트는 엔티티의 속성을 설명한다는 것 
    - 엔티티는 모든 비즈니스 도메인의 필수 구성 요소 
  - 애그리게이트
    - 트랜잭션 경계를 공유하는 엔티티의 계층. 애그리게이트의 경계에 속하는 모든 데이터는 비즈니스 로직의 구현을 통해 강력한 일관성을 유지해야 함 
    - 애그리게이트는 엔티티. 명시적인 식별 필드가 필요하고 인스턴스의 생애주기 동안 상태가 변할 것으로 예상됨 
  - 도메인 이벤트
    - 도메인 이벤트는 비즈니스 도메인에서 일어나는 중요한 이벤트를 설명하는 메시지 
      - 티켓이 할당됨 
      - 티켓이 상부에 보고됨
      - 메시지가 수신됨 
  - 유비쿼터스 언어
    - 애그리게이트는 유비쿼터스 언어를 사용해야 함. 애그리게이트의 이름, 데이터 멤버, 동작 그리고 도메인 이벤트에 사용된 모든 용어는 모두 바운디드 컨텍스트의 유비쿼터스 언어로 명명돼야 함 
  - 도메인 서비스
    - 도메인 모델에서 애그리게이트 또는 밸류 오브젝트에 속하지 않는 비즈니스 로직을 담는 상태가 없는 객체
    - 비즈니스 로직을 구현할 상태가 없는 객체(stateless object)
    - 이런 로직은 어떤 계산이나 분석을 수행하기 위한 다양한 시스템 구성요소의 호출을 조율함 

## 시간 차원의 모델링
- 이벤트 소싱
  - 이벤트 소싱 패턴은 데이터 모델에 시간 차원을 도입함. 애그리게이트의 현재 상태를 반영하는 스키마 대신 이벤트 소싱 기반 시스템은 애그리게이트의 수명주기의 모든 변경사항을 문서화하는 이벤트를 유지함 
  - 프로젝션 - 이벤트 소싱 패턴에서 쓰기 모델을 통해 이벤트 소싱 시스템에 이력 형태로 저장된 데이터를 다양한 읽기 모델을 적용해 원하는 시점의 데이터를 추출하는 기법 
- 원천 데이터
  - 이벤트 소싱 패턴이 작동하려면 객체 상태에 ㄷ대한 모든 변경사항이 이벤트로 표현되고 저장되어야 함 
  - 이벤트는 시스템의 원천 데이터가 됨 
  - 시스템의 이벤트를 저장하는 데이터베이스는 유일하고 강력하게 일관된 저장소인 시스템의 원천 데이터. 이벤트를 저장하는 데 사용되는 데이터베이스를 지칭하는 이름이 이벤트 스토어(event store)
  - 리하이드레이션 : 데이터 또는 파일 등에 액세스할 수 있게 재구성 또는 복원하는 작업 
  - 이벤트 스토어
    - 이벤트 스토어는 추가만 가능한 저장소이므로 이벤트를 수정하거나 삭제할 수 없음 
    - 특정 비즈니스 엔티티에 속한 모든 이벤트를 가져오고 이벤트를 추가하는 것 
- 이벤트 소싱 도메인 모델
  - 이벤트 소싱 애그리게이트에 대한 각 작업의 단계
    - 애그리게이트의 도메인 이벤트를 로드함
    - 이벤트를 비즈니스 의사결정을 내리는 데 사용할 수 있는 상태로 프로젝션해서 상태 표현을 재구성함
    - 애그리게이트의 명령을 실행하여 비즈니스 로직을 실행하고 결과적으로 새로운 도메인 이벤트를 생성함
    - 새 도메인 이벤트를 이벤트 스토어에 커밋함 
  - 이벤트 소싱 애그리게이트로 구현하는 방법
    - 관련 티켓의 이벤트를 로드하고, 애그리게이트 인스턴스를 리하이드레이션하고, 관련 명령을 호출하고, 변경사항을 데이터베이스에 다시 저장함 
  - 장점
    - 시간 여행
      - 도메인 이벤트를 사용하여 애그리게이트의 현재 상태를 재구성할 수 있는 것처럼 도메인 이벤트는 애그리게이트의 모든 과거 상태를 복원하는 데도 사용할 수 잇음. 애그리게이트의 모든 과거 상태를 필요할 때 언제든 재구성할 수 있음 
      - 시간 여행은 시스템의 동작을 분석하고, 시스템의 의사결정을 검사하고, 비즈니스 로직을 최적화할 때 종종 필요함 
    - 심오한 통찰력
      - 이벤트 소싱은 시스템의 상태와 동작에 대한 깊은 통찰력을 제공함 
    - 감사 로그
      - 영속적인 도메인 이벤트는 애그리게이트 상태에 발생한 모든 것에 대한 강력하게 일관된 감사 로그(audit log)를 나타냄. 법률에 따라 일부 비즈니스 도메인은 이러한 감사 로그를 반드시 구현해야 하며 이벤트 소싱은 이를 즉시 제공함 
      - 이 모델은 화폐 또는 금전 거래를 관리하는 시스템에 잘 이용됨. 이를 통해 시스템의 의사결정과 계정 간의 자금 흐름을 쉽게 추적할 수 있음 
    - 고급 낙관적 동시서 제어
      - 고급 낙관적 동시성 모델은 읽기 데이터가 기록되는 동안 다른 프로세스의 의해 덮여 쓰여지는 경우 예외를 발생시킴
      - 이벤트 소싱을 사용할 때 기존 이벤트를 읽고 새 이벤트를 작성하는 사이에 정확히 무슨 일이 일어났는지 더 깊은 통찰력을 얻을 수 있음 
  - 단점
    - 학습 곡선
      - 패턴인 데이터를 관리하는 기존 기술과 엄청난 차이가 있다는 것은 명백한 단점 
    - 모델의 진화
      - 이벤트 소싱 모델을 발전시키는 것은 어려울 수 있음. 이벤트 소싱의 정의를 엄밀하게 따지면 이벤트는 변경할 수 없음 
    - 아키텍처 복잡성
      - 이벤트 소싱을 구현하면 수많은 아키텍처의 유동적인 부분이 도입되어 전체 설계가 더 복잡해짐 
- 샤딩 : 대량의 데이터를 처리하기 위해 데이터베이스 테이블을 분할하여 물리적으로 서로 다른 곳에 분산 저장 및 조회하는 것 

## 아키텍처 패턴 
- 비즈니스 로직과 아키텍처 패턴 
  - 아키텍처 패턴은 코드베이스의 다양한 측면에 대한 구성 원칙을 도입하고 이들 사이의 명확한 경계를 제시함. 비즈니스 로직이 어떻게 시스템의 입력과 출력, 그리고 다른 기반 구성요소와 연결되는가와 같은 것이 코드베이스의 다양한 측면 중 하나 
- 계층형 아키텍처(layered architecture)
  - 가장 일반적인 아키텍처 패턴 중 하나. 코드베이스를 수평 계층으로 조직하고, 각 계층은 사용자와 상호작용, 비즈니스 로직의 구현, 그리고 데이터의 저장과 같은 기술적 관심사 중 하나를 다룸 
