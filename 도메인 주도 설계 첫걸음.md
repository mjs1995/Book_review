# 서평
- 이 책은 전략적 설계, 전술적 설계, DDD 실무, DDD와 다른 방법론 및 패턴과의 관계로 크게 네 개의 패턴으로 나뉘어 집니다. 대형 소프트웨어 설계 의사결정에 필요한 도구와 기법에 대해 배우며 시스템의 비즈니스 로직을 구현하는 다양한 방법에 대해 코드를 중심으로 배웁니다. 또한 실제 프로젝트에 DDD를 적용하는 전략과 기법을 논의하며 도메인 주도 설계에 대해 논의하고 다른 방법론과 패턴 맥락에서 DDD에 대해 배웁니다. 

# 전략적 설계
- 도메인 주도 설계(DDD: Domain-Driven Design)는 크게 2가지로 나눌 수 있다. 전략적 설계(strategic design) 단계에서 개발자와 비즈니스 전문가는 초기부터 협력하여 비즈니스 문제, 즉 도메인을 이해하고 문제를 서로 연결된 풀기 쉬운 작은 크기로 쪼갠다. 전술적 설계(tactical design)로서, 앞서 발견한 전략적 설계를 소프트웨어 아키텍처와 구현으로 전환시키는 단계다. DDD는 도메인을 잘 구성해 복잡성을 회피할 수 있는 가이드와 패턴을 제공한다. 
- DDD의 전략적인 측면은 무엇?과 왜?라는 질문에 대한 정답을 찾는 것. 우리가 어떤 소프트웨어를 만드는지, 그리고 왜 그 소프트웨어를 만드는지에 대한 해답을 찾는 것. 
- 전술적 측면은 어떻게?라는 방법에 대한 것으로 소프트웨어 각각의 구성요소가 구현되는 방법을 찾는 것

## 비즈니스 도메인 분석하기 
- 비즈니스 도메인은 기업의 주요 활동 영역으로 회사가 고객에게 제공하는 서비스를 말함
- 하위 도메인
  - 하위 도메인은 비즈니스 활동의 세분화된 영역
  - 핵심 하위 도메인은 회사가 경쟁업체와 다르게 수행하고 있는 것 
  - 일반 하위 도메인
    - 모든 회사가 같은 방식으로 수행하는 비즈니스 활동
    - 일반 하위 도메인은 회사에 경쟁력을 제공하지 않음. 이미 실무에서 검증된 솔루션으로 널리 이용 가능하며, 모든 회사에서 사용하고 있어서 더 이상 혁신이나 최적화가 필요 없음 
  - 지원 하위 도메인
    - 회사의 비즈니스를 지원하는 활동
    - 핵심 하위 도메인과 달리 지원 하위 도메인은 어떠한 경쟁 우위도 제공하지 않음 
- 도메인 분석 예제
  - BusVNext
    - 대중교통 회사. 고객에게 택시를 잡는 것처럼 쉽게 버스를 타는 경험을 제공하는 것이 목표
    - 핵심 하위 도메인
      - 라우팅
      - 분석
      - 모바일 앱 사용자 경험
      - 차량 관리
    - 일반 하위 도메인
      - 교통 상황
      - 회계
      - 청구
      - 권한 부여 
    - 지원 하위 도메인, 프로모션과 관리 모듈은 회사의 핵심 비즈니스를 지원함 
    - 설계 의사결정
      - 몇 가지 전략적인 설계 의사결정
        - 라우팅 알고리즘, 데이터 분석, 차량 관리, 앱 사용성은 가장 정교한 기술 도구와 패턴을 사용해서 사내에서 개발해야 함 
        - 판촉 관리 모듈의 구현은 외부에 위탁할 수 있음 
        - 교통 상황 식별, 사용자 권한 관리, 재무 및 거래 기록 관리는 외부 서비스 제공 업체에 맡길 수 있음 
- 도메인 전문가(domain expert) : 우리가 모델링하고 코드로 구현할 비즈니스의 모든 복잡성을 알고 있는 주제 전문가로 도메인 전문가는 소프트웨어의 비즈니스 도메인에 대한 권위자 

## 도메인 지식 찾아내기
- 비즈니스 문제
  - 우리가 개발하는 소프트웨어 시스템은 비즈니스 문제를 해결하는 솔루션 
  - 비즈니스 문제는 워크플로와 프로세스 최적화, 수작업 최소화, 자원 관리, 의사결정 지원, 데이터 관리 등과 관련된 과제일 수 있음 
  - 비즈니스 문제는 비즈니스 도메인과 하위 도메인의 모든 수준에서 발생할 수 있음 
- 도메인 지식 찾아내기
  - 효과적인 소프트웨어는 도메인 전문가가 문제를 생각하는 방식, 즉 멘탈 모델을 모방해야 함 
- 커뮤니케이션
  - 거의 모든 소프트웨어 프로젝트에는 도메인 전문가, 프로젝트 소유자, 엔지니어, UI와 UX 디자이너, 프로젝트 매니저, 테스터, 분석가 등 다양한 역할의 이해관계자의 협업이 필요하다고 할 수 있음 
  - 전형적인 소프트웨어 개발 생애주기에서 도메인 지식은 분석 모델(analysis model)로 알려진 엔지니어 친화적인 형태로 변환됨. 분석 모델은 도메인 지식 이면에 존재하는 비즈니스 도메인에 기반하기보다는 시스템 요구사항을 설명한 것에 지나지 않음 
- 유비쿼터스 언어
  - 참가자들이 효과적으로 소통하기 위해 변환에 의존하지 말고 같은 언어를 사용하는 것 
  - 전통적인 소프트웨어 개발 생애주기에서 변환이 어떻게 일어나는지 정리
    - 도메인 지식이 분석 모델로
    - 분석 모델이 요구사항으로 
    - 요구사항은 시스템 설계로
    - 시스템 설계는 소스코드로 
  - 도메인 주도 설계에서 이같이 도메인 지식을 계속해서 변환하는 대신, 비즈니스 도메인을 설명하기 위한 단일화된 언어 체계를 세우고자 하는데, 이것이 바로 유비쿼터스 언어 
- 비즈니스 언어
  - 유비쿼터스 언어는 도메인 전문가의 이해와 비즈니스 도메인에 대한 멘탈 모델을 쉽게 이해할 수 있는 관점으로 표현하는 것을 목표로 함
  - 시나리오
    - 광고 캠페인 관리 시스템 만들시 가정 
      - 광고 캠페인은 다양한 창의적인자료를 전시할 수 있다
      - 캠페인은 최소한 하나의 광고 할당이 활성화되어야 게시된다
      - 판매 커미션은 거래가 승인된 후에 회계 처리된다
    - 모든 문장은 비즈니스 언어로 작성됐음. 문장은 비즈니스 도메인을 바라보는 도메인 전문가의 시각을 반영함. 
    - 철저하게 기술적이어서 유비쿼터스 언어의 개념에 맞지 않은 문장
      - 광고의 아이프레임(iframe)은 HTML 파일을 표시함
      - 캠페인은 활성-할당(active-placement) 테이블에 하나의 연관 레코드가 있어야 게시됨
      - 판매 커미션은 거래(transaction) 테이블과 판매-승인(approved-sales) 테이블의 연관 레코드에 근거하여 처리됨 
    - 일관성
      - 가정할 필요가 없어야 하고 비즈니스 도메인의 로직을 명료하게 표현해야 함 
    - 모호한 용어 
    - 동의어 : 유비쿼터스 언어에서 두 용어는 서로 바꿔 사용할 수 없음 
- 비즈니스 도메인 모델
  - 효과적인 모델링
    - 모든 모델에는 목적이 있고 효과적인 모델은 그 목적을 달성하는 데 필요한 세부사항만 포함함
    - 유용한 모델은 실세계의 복사본이 아니라 문제를 해결하려는 의도가 있으며, 그 목적에 필요한 정보만 제공해야 함 
  - 도구
    - 위키는 유비쿼터스 언어를 수집하고 관리하는 용어집(glossary)으로 사용될 수 있음. 이런 용어집은 비즈니스 도메인의 용어에 대한 정보를 얻을 수 있는 거점 역할을 하므로 새로운 팀원이 쉽게 적응하게 해줌 

## 도메인 복잡성 관리
- 바운디드 컨텍스트 
  - 유비쿼터스 언어를 여러 개의 작은 언어로 나눈 다음 각 언어를 적용할 수 있는 명시적인 바운디드 컨텍스트(bounded context)에 할당
  - 모델의 경계(바운디드 컨텍스트)를 정의하는 것은 모델링 프로세스의 본질적인 부분 
- 실생활의 바운디드 컨텍스트
  - 시맨틱 도메인(semantic domain)
    - 의미 영역과 해당 의미를 전달하기 위해 사용하는 단어 영역으로 구분함 

## 바운디드 컨텍스트 연동
- 컨트랙트(contract) : 바운디드 컨텍스트 사이에는 항상 접점이 있는데 이것을 의미함 
- 각 컨트랙트는 하나 이상의 당사자에 영향을 끼치므로 서로 조율해서 컨트랙트를 정의해야 함 
- 협력형 패턴 그룹
  - 단일 팀에 의해 구현된 바운디드 컨텍스트
  - 한 팀의 성공이 다른 팀의 성공에 달려있고, 그 반대도 마찬가지인 의존적 목표가 있는 팀에 해당됨 
  - 파트너십 패턴
    - 파트너십 모델에서 바운디드 컨텍스트 간의 연동은 애드혹(ad-hoc) 방식으로 조정함. 한 팀은 다른 팀에게 API의 변경을 알리고 다른 팀은 충돌 없이 이를 받아들임 
- 사용자-제공자 패턴 그룹
  - 제공자는 사용자에게 서비스를 제공함. 서비스 제공자는 업스트림이고 고객 또는 사용자는 다운스트림이다 
  - 양 팀(업스트림과 다운스트림)은 서로 독립적으로 성공할 수 있음. 업스트림 또는 다운스트림의 팀이 연동 컨트랙트를 주도하는 권력의 불균형이 존재함. 
  - 힘의 차이를 보여주는 세 가지 패턴
    - 순응주의자 패턴
      - 힘의 균형이 서비스를 제공하는 업스트림 팀에 있는 경우가 있음. 사용자의 요구를 지원할 동기가 없는 경우가 그렇다.
      - 다운스트림 팀이 업스트림 팀의 모델을 받아들이는 바운디드 컨텍스트의 관계를 순응주의자(conformist) 패턴 
    - 충돌 방지 계층 패턴
      - 순응주의자 패턴에서 힘의 균형은 업스트림 서비스에 치우쳐 있음
      - 다운스트림 바운디드 컨텍스트가 이에 순응하지 않는 경우 표현한 충돌 방지 계층을 통해 업스트림 바운디드 컨텍스트의 모델을 스스로의 필요에 맞게 가공할 수 있음 
      - 다운스트림 바운디드 컨텍스트가 핵심 하위 도메인을 포함할 경우
        - 핵심 하위 도메인은 각별한 주의가 필요함. 제공자의 모델이 자칫 문제 도메인에 대한 모델링을 방해할 수 있음 
      - 업스트림 모델이 사용자의 요건에 비효율적이거나 불편한 경우
        - 바운디드 컨텍스트가 혼란에 순응하면 그 자체로 위험에 빠지게 됨. 이런 경우는 레거시 시스템과 연동할 때 종종 발생함 
      - 제공자가 컨트랙트를 자주 변경하는 경우
        - 사용자는 잦은 변경으로부터 모델을 보호하기를 원함. 충돌 방지 계층이 있으면 제공 모델의 변경은 변환 장치에만 영향을 미침 
    - 오픈 호스트 서비스 패턴
      - 힘이 사용자 측에 있을 경우를 처리함. 제공자는 사용자를 보호하고 가능한 최고의 서비스를 제공하는 데 관심이 있음 
      - 오픈 호스트 서비스(OHS: open-host service) 패턴은 충돌 방지 계층 패턴의 반대. 사용자 대신 제공자가 내부 모델 번역을 구현함 
- 분리형 노션(separated ways)
  - 분리형 노션 패턴에는 팀에 협업 의지가 없거나 협업할 수 없는 경우와 같이 다양한 이유가 있음 
  - 커뮤니케이션 이슈
  - 일반 하위 도메인
    - 중복된 하위 도메인의 특성도 협업 없이 분리된 길을 가야 하는 이유가 될 수 있음 
  - 모델의 차이
    - 바운디드 컨텍스트의 모델 간의 차이 
- 컨텍스트 맵
  - 컨텍스트 맵은 시스템의 바운디드 컨텍스트와의 연동을 시각적으로 표현함 
  - 거시적 설계 관점
    - 컨텍스트 맵은 시스템의 구성요소와 구현하는 모델의 개요를 제공함 
  - 커뮤니케이션 패턴
    - 컨텍스트 맵은 시스템의 구성요소 간의 커뮤니케이션 패턴을 묘사함. 예를 들어 어떤 팀이 협력하고, 충돌 방지 계층과 분리형 노선 패턴과 같은 덜 친밀한 연동 패턴을 선호하는지 보여줌
  - 조직적 문제
    - 컨텍스트 맵은 조직적 문제에 대한 통찰력을 제공함. 가령 특정 업스트림 팀의 다운스트림 사용자가 모두 충돌 방지 계층을 구현하는 데 의존하거나 분리형 노선 패턴의 모든 구현이 한 팀에 집중된다면 이는 무엇을 의미할까? 
- 바운디드 컨텍스트가 연동하는 다양한 방법
  - 파트너십 : 바운디드 컨텍스트는 애드혹 방식으로 연동됨
  - 공유 커널 : 두 개 이상의 바운디드 컨텍스트가 참여하는 모든 바운디드 컨텍스트가 공유하는 제한적으로 겹치는 모델을 공유해서 연동함
  - 순응주의자 : 사용자는 서비스 제공자의 모델에 순응함
  - 충돌 방지 계층 : 사용자는 서비스 제공자의 모델을 사용자의 요건에 맞게 번역함
  - 오픈 호스트 서비스 : 서비스 제공자는 사용자의 요건에 최적화된 모델인 공표된 언어를 구현함
  - 분리형 노선 : 협력과 연동보다는 특정 기능을 중복으로 두는 것이 더 저렴한 경우 

# 전술적 설계
## 간단한 비즈니스 로직 구현
- 트랜잭션 스크립트
  - 트랜잭션 스크립트 패턴은 프로시저를 기반으로 시스템의 비즈니스 로직을 구성하며, 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현함 
  - 구현
    - 각 프로시저는 간단하고 쉬운 절차지향 스크립트(procedural script, 객체지향 언어와 대비되는 개념으로 ,절차지향은 순차적인 처리가 중요시되는 스크립트)로 구현함
    - 가장 곤란한 순간에 트랜잭션 스크립트 실행이 실패하더라도 시스템은 오류가 발생할 때까지 변경사항을 롤백하거나 보상조치를 실행하여 일관성을 유지해야 함 
  - 트랜잭션 동작 구현 실패
    - 트랜잭션 동작 구현에 실패한 간단한 예는 전체를 아우르는 트랜잭션 없이 여러 업데이트를 하는 경우
    - 만약 Users 테이블에 레코드가 업데이트되고 나서 로그 레코드를 성공적으로 추가하기 전에 문제가 발생한다면 시스템이 일관되지 않은 상태가 됨. Users 테이블은 업데이트되지만 VisitLog 테이블에는 해당 레코드가 기록되지 않음. 이 문제는 네트워크 중단, 데이터베이스 시간 초과 또는 교착 상태, 프로세스를 실행하는 서버의 충돌로도 발생할 수 있음 
