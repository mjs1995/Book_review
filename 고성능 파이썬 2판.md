# 서평
- 이 책은 고성능 코드를 작성할 때 필요한 이론과 실무에 한 걸음 다가가고 싶은 분, 성능 좋은 시스템을 만드는 방법을 이해하고 싶은 모든 개발자, 파이썬을 충분히 사용해보았고 특정 부분이 왜 느린지 생각해본 적이 있으며, 이를 위한 해법으로 거론되는 사이썬(Cython), 넘파이, PyPy 같은 기술을 들어본 독자를 대상으로 하고있습니다. 또, 다른 언어로 프로그래밍해본 경험이 있어서 성능을 개선하는 방법이 여러가지임을 아는 독자분들에게 추천드립니다. 
- 책의 서평에서 책에서 다루는 전반적인 내용에 대해서 미리 알려줘서 전반적인 구조를 이해하는데 많은 도움이 되었습니다. 또한 이 책은 효율적이고, 이해하기 쉽고, 성능 좋은 시스템을 모두 달성하려는 사람을 위한 안내서입니다.
- 고성능 파이썬의 저자인 이안 오스발트는 다음과 같은 말을 서술하였습니다. 축하할만한 일의 로그를 작성하라는 것입니다. 성취했던 일을 잊고 일상에 묻혀 지내기 쉽습니다. 사람들은 쉴 새 없이 달리기 때문에 번아웃되는 게 아니라, 자신이 얼마나 발전했는지 잊어버려서 번아웃된다. 축하할만한 일의 목록을 만들고, 각각 어떻게 축하할지 적어보아라. 이런 의미에서 회고를 하면서 한 해를 돌아보는 과정이 새로운 해에 번아웃은 없이 기술을 갈고닦는데 도움이 된다고 생각합니다. 개인적인 삶의 우선순위를 더 높여서 컴퓨터와 일에서 며칠 떨어져 기술적이지 않은 일을 하면서 축하할만한 일의 로그를 작성하려고 합니다. 

# 들어가며 
- 파이썬은 고수준 언어이면서 배터리 포함이라는 개념하에 다양한 도구를 기본 제공하므로 누구나 쉽게 데이터 전처리나 데이터 분석에 사용할 수 있음, 파이썬은 너무 고수준 언어라서 이를 실행해주는 운영체제나 컴퓨터 시스템 전반을 충분히 이해하지 못할 때가 많음 
- 대용량 자료구조를 처리하는 과정에서 병렬 처리의 어려움이나 메모리 장벽, 성능 저하 등으로 문제가 있을때 저수준의 최적화 기법이나 시스템을 이해하면 도움이 됨 
- 책에서 다루는 내용
  - 컴퓨터의 저수준 동작 방식 : 내부적으로 어떤 일이 일어나는지 이해하기 
  - 리스트와 튜플 : 기본 자료구조인 리스트와 튜플의 미묘한 의미 차이와 속도 차이
  - 사전과 셋 : 중요한 자료구조인 사전과 셋의 메모리 할당 전략과 접근 알고리즘
  - 이터레이터 : 이터레이터를 통해 데이터를 스트리밍 하는 방법과 더 파이썬다운 코드를 작성하는 방법
  - 순수 파이썬 방식의 접근 : 파이썬과 모듈을 효율적으로 사용하는 방법
  - 행렬과 넘파이 : numpy 라이브러리를 고수처럼 사용하는 방법
  - 컴파일과 JIT 컴퓨팅 : 기계어로 컴파일해 더 빠르게 처리하기, 프로파일링 결과에 따라 성능 개선 방향 정하기
  - 동시성 : 데이터를 효과적으로 옮기는 방법
  - 다중 처리 : 병렬 컴퓨팅과 numpy 행렬을 효율적으로 공유하기 위해 기본 라이브러리인 multiprocessing 모듈을 이용하는 방법, 프로세스 간 통신(IPC)의 비용과 장점
  - 클러스터 컴퓨팅 : 연구나 프로덕션 시스템에서 다중 처리를 사용한 코드를 수정하여 로컬 또는 리모트 클러스터에서 실행하는 방법
  - 메모리 아껴 쓰기 : 크고 비싼 컴퓨터를 구입하지 않고 대용량 문제를 해결하는 접근법
  - 현업에서 얻은 교훈 : 현업에서 고군분투했던 문제에서 얻은 교훈을 통해 같은 문제를 겪지 않도록 예방하기 

# 고성능 파이썬 이해하기 
- 컴퓨터 프로그래밍이란 특별한 방법으로 데이터를 가공해서 주고받으며 어떤 결과를 얻는 과정 
- 고성능 프로그래밍은 이런 과정 중에 발생하는 부가비용을 줄이고(효과적인 코드 작성 등) 각 과정을 더 의미 있는 방법(더 적합한 알고리즘 등)으로 변경하여 시간 비용을 줄이는 행위 
- 기본 컴퓨터 시스템
  - 컴퓨터를 구성하는 요소는 크게 연산 장치, 메모리 장치, 장치들을 이어주는 연결 장치로 구성되어 있음
  - 연산 장치는 초당 얼마나 많이 계산할 수 있는지, 메모리 장치는 데이터를 얼마나 많이 저장할 수 있으며 얼마나 빠르게 읽고 쓸 수 있는지, 연결 장치에는 장치 간에 데이터를 얼마나 빠르게 옮길 수 있는지 알려주는 속성이 있음 
  - 일반적인 워크스테이션은 CPU라는 연산 장치, 용량과 접근 속도가 서로 다른 RAM과 하드 드라이브라는 저장 장치, 그리고 이들을 포함한 모든 부품을 연결하는 장치인 버스(bus)로 생각해볼 수 있음 
  - 연산 장치
    - 컴퓨터를 사용하는 데 가장 핵심적인 장치, 입력된 Bit를 다른 Bit로 변환하거나 프로세스의 상태를 변경하는 기능을 제공함 
    - 가장 널리 쓰이는 연산 장치는 CPU지만 최근에는 GPU(graphics processing units)가 보조 연산 장치로 인기를 끌음, 원래 GPU는 그래픽 처리에 사용되었으나 고유의 병렬적인 특성 때문에 많은 계싼을 동시에 처리할 수 있으므로 계산 애플리케이션에서도 유용함 
    - 연산 장치는 종류에 관계없이 여러 Bit(예를 들면 수를 나타내는 Bit)를 입력받아 다른 Bit 조합(예를 들면 각 수의 합)으로 변환함 
    - CPU 제조사는 더 빠른 속도를 얻으려고 동시적인 다중 스레딩(multithreading - 여러 스레드를 병렬로 동시에 실행), 비순차적 명령어 처리(out-of-order execution), 멀티 코어 아키텍처 같은 다른 방법을 모색함 
    - 하이퍼스레딩(hyperthreading)은 운영체제에 가상의 두 번째 CPU를 인식시킨 다음, 똑똑한 하드웨어 로직이 단일 CPU의 실행 유닛에 두 스레드를 번갈아 가며 실행하도록 하는 기법, 잘만 작동하면 단일 스레드 대비 30% 까지 성능을 끌어 올릴 수 있음 
    - 비순차적 명령어 처리는 프로그램 실행 과정에서 이전 작업의 결과에 영향을 받지 않는 부분을 찾아내서 두 작업을 순서와 관계없이 실행하거나 동시에 실행하는 기법
    - 멀티 코어 아키텍처는 실행 유닛 하나에 CPU를 여러 개 두어 전체적인 처리량이 단일 CPU의 처리량을 능가하도록 함 
    - 암달의 법칙 : 단순히 CPU에 코어를 더 넣는다고 해서 프로그램의 실행 시간이 무조건 단축되지는 않음, 멀티 코어에서 작동하도록 설계된 프로그램일지라도 하나의 코어에서 실행해야 하는 루틴이 존재하고, 이 루틴이 코어를 더 투입했을 때 기대할 수 있는 최대 성능 향상치의 병목으로 적용한다는 법칙
- 메모리 장치
  - 메모리 장치에는 메인보드의 레지스터나 RAM, 하드 드라이브도 포함됨
  - 메모리 장치는 대부분 데이터를 조금씩 자주 읽을 때(임의 접근 random access)보다 한꺼번에 많이 읽을 때 훨 씬 빠르게 작동함(순차 접근 sequential access)
  - 레이턴시(latency) : 장치가 데이터를 찾기까지 걸리는 시간을 의미함
  - 하드디스크
    - 컴퓨터의 전원이 꺼진 상태에서도 데이터를 오래 보관할 수 있는 저장 장치, 물리적으로 헤드를 움직여야 하므로 읽기/쓰기 속도가 느림, 임의 접근 성능이 떨어지지만 10TB 수준의 대용량 데이터를 저장할 수 있음 
  - 솔리드 스테이트 드라이브(SSD) 
    - 하드디스크와 비슷함, 하드디스크보다 읽기/쓰기 속도가 빠르지만, 용량은 작음
  - RAM
    - 애플리케이션 코드나 사용 중인 변수 같은 데이터를 저장하는 데 쓴다, 읽기/쓰기 속도가 빠르며 임의 접근에도 성능 하락이 적으나, 일반적으로 용량이 64GB 단위로 제한적임 
  - L1/L2 캐시
    - 읽기/쓰기 속도가 매우 빠름, CPU로 전달하는 데이터는 항상 이 캐시를 거쳐 감, MB 단위로 용량이 아주 작음 
    - 읽기/쓰기 속도와 용량은 반비례하는 경향이 뚜렷함, 빠른 속도를 원한다면 줄어드는 용량을 감수해야 함
- 통신 계층
  - FSB는 RAM과 L1/L2 캐시를 연결함, FSB는 처리할 준비가 된 데이터를 옮겨서 프로세서가 계산할 수 있도록 하며, 계산이 완료되면 다시 돌려줌 
- 무거운 데이터(heavy data) : 데이터를 옮기는 데 시간과 노력이 필요하다는 뜻 

- 파이썬 개선점
  - 내부적으로 잘 최적화된 명령어 집합을 실행하지만, 명령어 집합을 올바른 순서로 실행하도록 하면 성능이 더 좋아짐 
  - 글로벌 인터프리틱 락(Global Interpreter Lock - GIL) 때문에 코어를 여러 개 활용하기가 쉽지 않음, GIL을 현재 사용중인 코어가 몇 개든, 한 번에 명령 하나만 실행하도록 강제함. 파이썬에서 동시에 여러 개의 코어에 접근하더라도 한 번에 파이썬 명령 하나만 실행됨
    - 다른 표준 라이브러리인 multiprocessing 모듈을 사용하거나, numpy나 numexpr, 사이썬 같은 기술을 이용하거나, 분산 컴퓨팅 모델을 사용하는 방법으로 해결할 수 있음 
  - 파이썬이 메모리를 자동으로 할당하고 해제하는 가비지 컬렉터(garbage collector GC)를 사용하기 때문, CPU 캐시에 데이터를 전송하는 데 영향을 미치는 메모리 단편화를 일으킴, 게다가 어디에서도 메모리에 저장되는 자료구조를 직접 변경할 수 없으므로 버스 폭이 아주 넓더라도 한 번의 계산에 필요한 정보를 한 번에 전송할 수 없음
  - 파이썬이 동적 타입을 사용하며 컴파일되지 않는다는 점
    - 정적인 코드를 컴파일 할 때, 컴파일러는 CPU가 특정 명령을 실행하는 방식을 포함한 많은 부분을 변경해서 최적화 할 수 있음, 파이썬은 컴파일되지 않는 데다가 코드의 기능이 런타임에 변경되는 동적 타입 언어라 최적화 알고리즘이 제 기능을 발휘하기 어렵다, 이 문제를 극복하는 여러 방법 중 사이썬(Cython)이 가장 대표적, 사이썬은 파이썬 코드를 컴파일하고 컴파일러에게 동적인 코드가 실제로 어떻게 동작하는지 힌트를 줄 수 있음 
- 파이썬을 쓰는 이유
  - 표현력이 좋고 배우기 쉽다는 장점
  - 많은 파이썬 라이브러리는 타 언어로 작성된 도구를 감싸서 다른 시스템을 쉽게 호출함
  - 주된 강점 하나는 빠른 프로토타이핑, 비록 처음부터 그럴싸하지는 않더라도 다양한 라이브러리를 활용해서 실현 가능한 아이디어인지 빠르게 검증해볼 수 있음 
  - 기본 라이브러리
    - unicode와 bytes : 언어 핵심에 녹아 있음
    - array : 메모리를 효율적으로 사용하는 배열
    - math : 간단한 통계를 포함한, 기본적인 수학 연산 모듈
    - sqlite3 : 널리 사용되는 파일 기반 데이터베이스인 SQLite3의 래퍼
    - collections : 데크(deque), 카운터, 여러 가지 사전을 포함하는 다양한 객체 집합
    - asyncio : async와 await 구문을 사용해 I/O 위주 작업의 동시 처리 지원, 기본적으로 지원하지는 않지만, 다양성을 더해주는 다음과 같은 외부 라이브러리가 있음 
    - Numpy : 파이썬 수학 라이브러리(행렬을 사용할 때 필수 라이브러리)
    - scipy : 높은 평가를 받는 C와 포트란 라이브러리를 감싼 계산 라이브러리 모음
    - Pandas : R의 dataframe이나 엑셀 스프레드시트와 유사한 데이터 분석 라이브러리, scipy와 numpy를 사용 
    - 사이킷런 : 빠르게 머신 러닝의 기본 모듈이 되고 있음, scipy를 사용
    - tornado : 웹 프레임워크이자 비동기 네트워크 라이브러리
    - PyTorch와 TensorFlow : 페이스북과 구글이 만든 딥러닝 프레임워크, 파이썬과 GPU를 강력히 지원
    - NLTK, SpaCy, Gensim : 파이썬을 잘 지원하는 자연어 처리 라이브러리
    - 데이터베이스 바인딩 : 레디스, 몽고DB, HDF5, SQL 등 실질적으로 대부분의 데이터베이스를 지원
    - 웹 프레임워크 : 웹 사이트 개발을 지원하는 aiohttp, flask, django, pyramid, tornado 등
    - OpenCV : 컴퓨터 비전을 위한 바인딩
    - API 바인딩 : 구글, 트위터, 링크드인 등 인기 서비스에 제공하는 웹 API를 위한 바인딩
    - 파이썬 배포판과 셸
      - 간단하고 가벼우며 이식성 좋은 파이썬 환경을 제공하는 pipenv, pyenv, virtualenv
      - 배포(deploy)와 프로덕션(production)에서 시작과 재현이 간편한 환경을 만들어주는 도커
      - 과학 계산에 초점을 맞춘 아나콘다사의 아나콘다 환경
      - IDE를 포함하며 매트랩과 유사한 환경을 제공하는 Sage
      - 개발자와 과학자들이 많이 쓰는 대화형 파이썬 셸인 IPython
      - 브라우저에서 돌아가는 IPython인 주피터 노트북, 교육과 데모용으로 많이 쓰임
- 뛰어난 성과를 거두는 파이썬 프로그래머가 되는 방법
  - 일반적인 접근 방법
    - 작동하게 만들라
      - 먼저 충분히 좋은 해법을 만들어야 함, 프로토타입 해법으로 사용되는 폐기한다는 가정하에 일단 만들어 보기를 적용하고 두 번째 버전에서 더 나은 구조를 사용할 수 있을 것이라 생각하자
      - 두 번 측정하고, 한 번만 잘라라(measure twice, cut once)
    - 재대로 만들라
      - 강력한 테스트 스위트를 만들고 코드와 테스트를 문서로 뒷받침해야 함, 다른 팀원이 사용할 수 있도록 명확한 재현 방법도 문서로 남김
    - 빠르게 만들라
      - 프로파일링, 컴파일링, 병렬화 등에 초점을 맞추고, 기존 테스트 스위트를 사용해 새로운 빠른 해법이 여전히 예상대로 작동하는지 확인해야 함 
- 모범적인 작업 절차
  - 문서화, 좋은 구조, 테스트가 핵심 요소
  - 최상위 수준에 README 파일을 작성하는 작업이 좋은 출발점임
  - 프로젝트 목적, 폴더 내용, 데이터 출처, 중요한 파일 목록, 프로그램과 파일의 실행 방법, 테스트 실행 방법 등을 적어라
  - 최상위 Dockerfile은 차후 이 프로젝트를 성공적으로 실행하는 데 운영체제에서 필요한 라이브러리를 정확히 알려줌, 그리고 다른 컴퓨터나 클라우드 환경에 프로젝트를 배포할 때도 어려움 없이 프로젝트를 실행할 수 있게 해줌 
  - tests/ 폴더를 추가하고 단위 테스트를 만들어라, 최신 테스트 도구로 pytest를 추천함, pytest는 파이썬 내장 unittest 모듈을 사용해 만들어졌음, 먼저 테스트를 한두 개 작성하고 점점 발전시켜라
  - 프로젝트 전체 흐름을 검사하면서 특정 입력에 대해 여러분이 지정한 출력이 나오는지를 체크하는 통합 테스트(integration test)가 있어야 함, 나중에 코드를 변경할 때 코드의 일관성을 유지하는 데 도움이 됨 
  - 코드의 모든 함수, 클래스, 모듈에 독스트링(docstring)을 추가하면 큰 도움이 됨, 함수가 달성하려는 내용을 제대로 설명하려 노력하라, 가능하면 예상 출력을 보여주는 간단한 예제도 추가하자 
  - 코드가 너무 길어지면(예컨대 한 화면에 다 보이지 않는 함수) 리팩터링해 코드를 짧게 만들어라, 짧은 코드는 테스트하기 쉽고 지원하기도 쉽다
  - 항상 소스 관리(source control)를 사용하라, 중요한 시기에 필수적인 코드를 덮어썼다면 소스 관리를 사용한 자기 자신에게 감사하게 됨, 커밋(commit)을 자주(매일 아니면 10분마다) 하고 매일 리포지터리(repository)에 작업을 푸시하라
  - PEP8 코딩 표준을 지켜라. black(원하는 대로 설정할 수 있는 코드 정리기formatter)을 소스 컨트롤의 커밋 전 훅(pre-commit hook)에 추가해서 코드를 표준 형식으로 자동 정리하면 더 좋음, flake8을 적용해 소스 코드를 린트(lint)해서 다른 실수를 방지하라
  - 운영체제와 분리된 환경을 만들면 더 코딩이 쉬워짐, 아나콘다, pipenv와 도커를 함께 쓰는 쪽을 선호함
  - 자동화는 여러분의 친구라는 사실을 기억하라, 수동 작업을 덜 하면 오류가 끼어들 가능성도 줄어듬, 자동 빌드 시스템, 자동 테스트 스위트 실행기(runner)를 사용한 지속적 통합(continuous integration), 자동 배포(automated deployment)는 지겹고 실수하기 쉬운 작업을 누구든 실행하고 지원할 수 있는 표준 절차로 바꿔줌
  - 가독성이 더 중요하다는 사실을 기억하라, 짧지만 복잡하고 읽기 어려운 코드는 유지보수하기 어렵다. 더 길더라도 읽기 편한 함수를 작성하고 함수에 관한 유용한 문서를 작성하는 편이 바람직하다. 함수가 실제로 원하는 대로 작동하는지 확인하는 테스트로 이 모든 내용을 보완하라 
- 주피터 노트북 잘 다루기
  - 코드를 IPython이나 QTConsole에서 프로토타이핑하라. 이런 콘솔에서 테스트한 코드들을 노트북 함수로 분리하고, 노트북 함수 중에 자주 쓰거나 복잡한 부분은 노트북에서 추출해서 모듈로 만들면서 테스트를 보완하라. 데이터 은닉(data hiding)이나 캡슐화(encapsulation)가 유용한 경우에는 코드를 클래스로 감싸라
  - assert 문을 노트북 여기저기에 자유롭게 넣어서 함수가 여러분 생각대로 작동하는지 검증하라
  - 함수가 예상하지 못한 입력값을 만났을 때 던질 수 있는 일반적인 예외로는 ValueError, Bulwark 라이브러리는 데이터가 정해진 제약 조건을 만족하는지 검사해주는 팬더스에 초점을 맞춘 테스트 프레임워크의 예다 
  - 노트북의 끝에 데이터 무결성 검사를 추가하라, 무결성 검사는 노트북에서 방금 생성한 데이터가 여러분에 피룡한 데이터인지 검사하는 논리 검사와 raise, print 문을 혼합한 코드 조각
  - nbdime은 성장 중인 새로운 도구로, 노트북 사이의 차이를 알려줘서 동료들과 협업할 때 큰 도움이 됨 
- 일하는 즐거움 되찾기
  - 새로운 활동을 하면서 계속 기쁨을 찾아라, 왜 이런 결정을 내렸지?, 내가 하면 어떻게 다르게 할 수있을까? 같은 질문을 할 수 있고, 갑자기 상황이 어떻게 더 나아지거나 바뀌었는지에 관한 이야기를 시작하게 될 것이다.
- 프로그래밍은 (특히 성능이나 성취에 초점을 맞추면) 기술적인 세부 사항을 깊이 파고들려는 자발성과 호기심이 있어야 번창함, 천천히 시간을 두고 여러분의 여정을 즐기며 호기심과 즐거움을 계속 유지하라 
