# 서평
- 데이터 처리의 기본기를 다지기에 좋은 참고서로 데이터 모델 설계, 질의 언어 , 복제, 트랜잭션, 일괄 처리, 스트림 처리 등 데이터 처리의 다양한 측면을 다루고있다. 이 책의 목적은 다양하고 빠르게 변하는 데이터 저장과 처리 기술 분야를 탐험하는데 도움을 준다. 책의 서문에는 다음과 같은 독자에게 추천하고 있다.
	- 데이터 시스템을 확장성 있게 만드는 방법을 알고 싶은 사람(웹 또는 모바일 앱이 수백만 명의 사용자를 감당할 수 있게 하고 싶다)
	- 애플리케이션이 고가용성을 갖춰야 하고(중단시간 최소화) 운영상 견고해야 함
	- 시스템 규모가 커지고 요구사항과 기술이 바뀌더라도 오랜 기간 쉽게 유지보수할 수 있는 방법을 찾고 있다.
	- 사물의 동작 방식에 대해 타고난 호기심이 있다. 대형 웹사이트와 온라인 서비스의 내부가 어떻게 돌아가는지 알고 싶다. 이책은 다양한 데이터베이스와 데이터 처리 시스템의 내부를 분해한다. 이런 시스템 설계에 반영된 기발한 생각을 탐험하는 것이 매우 즐겁다 
- 데이터베이스가 데이터를 저장하는 방법과 데이터를 요청 했을 때 다시 찾을 수 있는 방법에 대해서 자세하게 설명 하고 있다. 애플리케이션 개발자가 데이터베이스에 데이터를 제공하는 형식과 나중에 다시 요청할 수 있는 메커니즘인 데이터 모델과 질의 언어에 대해 책으로 경험해 볼 수 있어서 좋았다.

# 데이터 시스템의 기초
## 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
- 애플리 케이션이 유용하려면 다양한 요구사항을 충족해야함
	- 기능적 요구 사항 : 여러 방법으로 데이터를 저장하고 조회하고 검색하고 처리하게끔 허용하는 작업과 같이 해야하는 일 
	- 비기능적 요구사항 : 보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성 
- 데이터 중심 애플리케이션(data-intensive application)은 기술적 발전을 활용해 실현 가능한 범위를 넓힘
  - 데이터 중심적(data-intensive) : 데이터 양, 데이터 복잡성, 데이터가 변하는 속도 등, 데이터가 주요 도전과제인 애플리케이션
  - 계산 중심적(compute-intensive) : CPU 사이클이 병목인 경우
	- 표준 구성 요소(standard building block)
		- 구동 어플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장(데이터베이스)
		- 읽기 속도 향상을 위해 값비싼 수행 결과를 기억(캐시)
		- 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공(검색 색인(search index))
		- 비동기 처리를 위해 다른 프로세스로 메시지 보내기(스트림 처리(stream processing))
		- 주기적으로 대량의 누적된 데이터를 분석(일괄 처리(batch processing))
- 데이터 시스템에 대한 생각
	- 레디스(Redis) : 메시지 큐로 사용하는 데이터 스토어
	- 아파치 카프카(Apache Kafka) : 데이터베이스처럼 지속성(durability)을 보장하는 메시지 큐
	- 복합 데이터 시스템(composite data system) : 외부 클라이언트가 일관된 결과를 볼 수 있게끔 쓰기에서 캐시를 올바르게 무효화하거나 업데이트하는 등의 특정 보장 기능을 제공함 
- 신뢰성(Reliability) : 결함이 발생해도 시스템이 올바르게 동작하게 만든다
	- 하드웨어나 소프트웨어 결함, 심지어 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작
	- 기대치
		- 애플리케이션은 사용자가 기대한 기능을 수행함
		- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용함
		- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족함
		- 시스템은 허가되지 않은 접근과 오남용을 방지함 
	- 내결함성(fault-tolerant) 또는 탄력성(resilient) : 결함을 예측하고 대처할 수 있는 시스템
		- 결함 : 사양에서 벗어난 시스템의 한 구성 요소
		- 장애 : 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우 
	- 하드웨어 결함
		- 하드디스크가 고장 나고, 램에 결함이 생기고, 대규모 정전 사태가 발생하고, 누군구가 네트워크 케이블을 잘못 뽑는 것과 같은 결함
		- 시스템 장애율을 줄이기 위해 각 하드웨어 구성 요소에 중복(redundancy)을 추가하는 방법
	- 소프트웨어 오류
		- 시스템 내 체계적 오류(systematic error)
			- 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그 
			- CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
			- 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
			- 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애(cascading failure)
	- 인적 오류
		- 실제 사용자에게 영향이 없는 비 프로덕션 샌드박스(sandbox)를 제공
		- 롤아웃(roll out) : 예상치 못한 버그가 일부 사용자에게만 영향이 미치게함
		- 모니터링 = 원경 측정(telemtery)
- 확장성(Scalability) : 부하가 증가해도 좋은 성능을 유지하기 위한 전략 
	- 시스템의 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법
	- 부하 기술하기
		- 시스템의 현재 부하를 간결하게 기술
		- 부하 매개변수(load parameter) : 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자(active user), 캐시 적중률 등 
	- 성능 기술하기
		- 시스템의 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사
			- 부하 매개변수를 증가시키고 시스템 자원(CPU,메모리,네트워크 대여폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
			- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 자원을 늘려야 할까?
			- 성능 수치 필요
				- 하둡 같은 일과 처리 시스템 -> 처리량(throughput: 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)
				- 온라인 시스템 : 서비스 응답 시간(response time) - 클라이언트가 요청을 보내고 응답을 받는 사이의 시간 
					- 응답 시간(response time) : 클라이언트 관점에서 본 시간, 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함함
					- 지연 시간(latency) : 요청이 처리되길 기다리는 시간, 서비스를 기다리며 휴지(latent) 상태인 시간 
		- 추가 지연을 일으키는 여러 원인
			- 백그라운드 프로세스의 컨텍스트 스위치(context switch), 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지(garbage collection pause), 디스크에서 읽기를 강제하는 페이지 폴트(page fault), 서버 랙의 기계적인 진동 
		- 백분위
			- 중앙값, 50분위, p50
			- 95분위, 99분위, 99.9분위(p95,p99,p999( 
			- 서비스 수준 목표(service level objective,SLO)와 서비스 수준 협약서(service level agreement,SLA)에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에도 자주 등장 
		- 선두 차단(head-of-line blocking) : 서버는 병렬로 소수의 작업만 처리할 수 있기 때문에(ex-CPU 코어수에 제한됨) 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체됨
	- 부하 대응 접근 방식
		- 용량 확장(scaling up, 수직확장 vertical scaling) : 좀 더 강력한 장비로 이동
		- 규모 확장(scaling out, 수평확장 horizontal scaling) : 다수의 낮은 사양 장비에 부하를 분산 
		- 비공유 아키텍처(shared-nothing) : 다수의 장비에 부하를 분산하는 아키텍처
		- 탄력적(elastic) : 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가 
		- 아키텍처를 결정하는 요소 : 읽기의 양, 쓰기의 양 ,저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등 
- 유지보수성(Maintainability) 
	- 시스템에서 작업하는 엔지니어와 운영 팀의 삶을 개선, 좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있께하며 새로운 사용 사례에 적용
	- 좋은 운용성이란 시스템의 건강 상태를 잘 관찰할 수 있고 시스템을 효율적으로 관리하는 방법을 보유
	- 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 함
	- 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 기술 채무(technical debt) 상환, 새로운 기능 추가 등 
	- 소프트웨어 시스템 설계 원칙
		- 운용성(operability) : 운영의 편리함 만들기
			- 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들기
			- 좋은 운영팀
				- 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
				- 시스템 장애, 성능 저하 등의 문제를 원인을 추적
				- 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
				- 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
				- 미래에 발생가능한 문제를 예측해 문제가 발생하기 전에 해결(용량 계획)
				- 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
				- 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스크를 수행
				- 설정 변경으로 생기는 시스템 보안 유지보수
				- 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의 
				- 개인 인사 이동에도 시스템에 대한 조직의 지식을 보존함 
			- 데이터 시스템은 동일 반복 태스크를 쉽게 하기 위해서
				- 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
				- 표준 도구를 이용해 자동화와 통합을 위한 우수한 자원을 제공
				- 개별 장비 의존성을 회피, 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함
				- 좋은 문서와 이해하기 쉬운 운영 모델(ex- X를 하면 Y가 발생한다) 제공
				- 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정으히라 수 있는 자유를 관리자에게 부여
				- 적절하게 자기 회복(self-healing)이 가능할 뿐 아니라 필요에 따라 관리자에게 시스템 상태를 수동으로 제어할 수 있게 함 
				- 예측 가능하게 동작하고 예기치 않은 상황을 최소화함
		- 단순성(simplicity) : 복잡도 관리
			- 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라
			- 복잡도 : 같은 시스템에서 작업해야하는 모든 사람의 진행을 느리게 하고 나아가 유지보수 비용이 증가 
				- 증상 : 상태 공간의 급증, 모듈 간 강한 커플링(tight coupling), 복잡한 의존성, 일관성 없는 명명(naming)과 용어,성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례(specital-casing)
		- 발전성(evolvability)
			- 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 해라, 예기치 않은 사용 사례를 적용하기가 쉬움 -> 유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)
			- 조직 프로세스 측면에서 애자일(agile) 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공 
			- 애자일 커뮤니티는 테스트 주도 개발(test-driven development(TDD))과 리팩토링(refactoring) 같이 자주 변화하는 환경에서 소프트웨어를 개발할때 도움이 되는 기술 도구와 패턴을 개발 

# 데이터 모델과 질의 언어 
- 데이터 모델
	- 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각해야 하는지에 대해서도 지대한 영향을 미침
	- 하위 계층 관점에서 데이터 모델을 표현하는 방법
		- 애플리케이션 개발자는 현실(사람,조직,상품,행동,자금 흐름, 센서 등)을 보고 객체나 데이터 구조, 그리고 이러한 데이터 구조를 다루는 API를 모델링함, 이런 구조는 보통 애플리케이션에 특화됌
		- 데이터 구조를 저장할 때는 JSON이나 XML 문서, 관계형 데이터 베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현함
		- 데이터베이스 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 상의 바이트 단위로 표현하는 방법을 결정함, 이 표현은 다양한 방법으로 데이터를 질의, 탐색, 조작, 처리할 수 있게 함
		- 더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등의 관점에서 바이트를 표현하는 방법을 알아냄
- 관계형 모델과 문서 모델
	- 데이터는 (SQL에서 테이블이라 불리는) 관계(relation)로 구성되고 각 관계는 순서 없는 튜플(tuple)(SQL에서 로우(row)) 모음
	- 트랜잭션 처리(영업이나 은행거래, 항공 계약, 창고에 재고 보관)와 일괄 처리(고객 송장 작성, 급여 지불, 보고)
- NoSQL
	- Not Only SQL
	- 원동력
		- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
		- 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
		- 관계형 모델에서 지원하지 않는 특수 질의 동작
		- 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람
- 객체 관계형 불일치
	- 임피던스 불일치(impedance mismatch) : 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체(테이블, 로우 , 칼럼) 사이에 거추장스러운 전환 계층이 필요한데 모델 사이의 분리를 뜻함
	- 관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것, 관계(테이블)는 단순히 튜플(로우)의 컬렉션이 전부
- 스키마 유연성 
	- 쓰기 스키마(schema-on-write) : 관계형 데이터베이스의 전통적인 접근 방식으로 스키마는 명시적이고 데이터 베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장함
		- 정적(컴파일 타임) 타입 확인과 비슷
	- 읽기 스키마(schema-on-read) : 데이터 구조는 암묵적이고 데이터를 읽을 때만 해석됨
		- 프로그래밍 언어에서 동적(런타임) 타입 확인과 유사
- 질의를 위한 데이터 지역성
	- 문서는 보통 JSON, XML로 부호화된 단일 연속 문자열이나 (몽고 DB의 BSON 같은) JSON 또는 XML의 이진 변형으로 저장됨
- 맵리듀스 질의
	- 맵리듀스(MapReduce) : 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델, 여러 함수형 프로그래밍 언어에 있는 map(collect라고도 함)과 reduce(fold나 inject라고도 함) 함수를 기반으로 함
- 그래프형 데이터 모델
	- 두 유형의 객체로 이루어짐
		- 정점(vertex) : 노드나 엔터티
			- 고유한 식별자
			- 유출(outgoing) 간선 집합
			- 유입(incoming) 간선 집합
			- 속성 컬렉션(키-값 쌍)
		- 간선(edge) : 관계나 호(arc)
			- 고유한 식별자
			- 간선이 시작하는 정점(꼬리 정점)
			- 간선이 끝나는 정점(머리 정점)
			- 두 정점 간 관계 유형을 설명하는 레이블
			- 속성 컬렉션(키-값 쌍)
		- 예시
			- 소셜 그래프 : 정점은 사람이고 간선은 사람들이 서로 알고 있음을 나타냄
			- 웹 그래프 : 정점은 웹페이지고 간선은 다른 페이지에 대한 HTML 링크를 나타냄
			- 도로나 철도 네트워크 : 정점은 교차로이고 간선은 교차로나 간 도로나 철로 선을 나타냄
- 사이퍼 질의 언어
	- 사이퍼(Cypher) : 속성 그래프를 위한 

# 저장소와 검색
- 실제 데이터베이스 문제 : 동시성 제어, 로그가 영원히 커지지 않게끔 디스크 공간을 회수, 오류 처리, 부분적으로 기록된 레코드 처리 
- 색인 : 어떤 부가적인 메타데이터를 유지하는 것
- 실제 구현에서 중요한 문제
	- 파일 형식
		- CSV는 로그에 가장 적합한 형식이 아님, 바이트 단위의 문자열 길이를 부호화한 다음 원시 문자열을 부호화하는 바이너리 형식을 사용하는 편이 더 빠르고 간단함
	- 레코드 삭제
		- 키와 관련된 값을 삭제하려면 데이터 파일에 특수한 레코드(툼스톤(tombstone)라 불림)를 추가해야함, 로그 세그먼트가 병합될 때 툼스톤은 병합 과정에서 삭제된 키의 이전 값을 무시함
	- 고장(Crash) 복구
		- 데이터베이스가 재시작되면 인메모리 해시 맵은 손실됨, 원칙적으로는 전체 세그먼트 파일을 처음부터 끝까지 읽고 각 키에 대한 최신 값의 오프셋을 확인해서 각 세그먼트 해시 맵을 복원할 수 있음
	- 부분적으로 레코드 쓰기
		- 데이터베이스는 로그에 레코드를 추가하는 도중에도 죽을 수 있음, 비트캐스크 파일은 체크섬을 포함하고 있어 로그의 손상된 부분을 탐지해 무시할 수 있음
	- 동시성 제어
		- 쓰기를 엄격하게 순차적으로 로그에 추가할 때 일반적인 구현 방법은 하나의 쓰기 스레드만 사용하는 것 , 데이터 파일 세그먼트는 추가 전용이거나 불변(immutable)이므로 다중 스레드로 동시에 읽기를 할 수 있음
- B트리
	- 전통적으로 4KB 크기(때로는 더 큰)의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 함 
	- 로그 구조화 색인 : 데이터베이스를 일반적으로 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나누고 항상 순차적으로 세그먼트를 기록
- 다중 칼럼 색인
	- 결합 색인(concatenated index)
		- 하나의 칼럼에 다른 칼럼을 추가하는 방식으로 하나의 키에 여러 필드를 단순히 결합함
- 트랜잭션 처리와 분산 시스템의 특성 비교

|특성|트랜잭션 처리 시스템(OLTP)|분석 시스템(OLAP)
|:---:|:---:|:---:|
|주요 읽기 패턴|질의당 적은 수의 레코드, 키 기준으로 가져옴| 많은 레코드에 대한 집계
|주요 쓰기 패턴|임의 접근, 사용자 입력을 낮은 지연 시간으로 기록|대규모 불러오기(bulk import, ETL) 또는 이벤트 스트림
|주요 사용처|웹 애플리케이션을 통한 최종 사용자/소비자|의사결정 지원을 위한 내부 분석가
|데이터 표현|데이터의 최신 상태(현재 시점)|시간이 지나며 일어난 이벤트 이력
|데이터셋 크기|기가바이트에서 테라바이트|테라바이트에서 페타바이트

- 데이터 웨어하우징
	- 데이터웨어하우스 : 분석가들이 OLTP 작업에 영향을 주지 않고 마음껏 질의할 수 있는 개별 데이터베이스
	- ETL(Extract-Transform-Load) : OLTP 데이터베이스에서(주기적인 데이터 덤프나 지속적인 갱신 스트림을 사용해) 추출(extract)하고 분석 친화적인 스키마로 변환(transform) 하고 깨끗하게 정리한 다음 데이터 웨어하우스에 적재(load)함
- 드릴 다운 : 요약된 정보에서 상세 정보까지 계층을 나눠 점점 구체적으로 분석하는 작업
- 슬라이싱과 다이싱 : 상세한 분석을 위해 주어진 큰 규모의 데이터를 작은 단위로 나누고 원하는 세부 분석 결과를 얻을 때까지 반복함
- 분석용 스키마 : 별 모양 스키마와 눈꽃송이 모양 스키마
	- 별 모양 스키마(star schema)(차원 모델링(dimensional modeling))
		- 테이블 관계가 시각화될 때 사실 테이블이 가운데에 있고 차원 테이블로 둘러싸고 있다는 사실에 비롯됌
	- 눈꽃송이 모양 스키마(snowflake schema) : 차원이 하위차원으로 더 세분화됨
	- 스키마 중심에 소위 사실 테이블(fact table) 
		- 사실 테이블의 각 로우는 특정 시각에 발생한 이벤트에 해당
		- 차원 테이블(dimension table) 다른 테이블을 가리키는 외래 키 참조
- OLTP 시스템은 보통 사용자 대면이기 때문에 대량의 요청을 받을 수 있음, 부하를 처리하기 위해 보통 애플리케이션이 각 질의마다 작은 수의 레코드만 다룸, 애플리케이션은 키의 일부만 사용하는 레코드를 요청하고 저장소 엔진은 요청한 키의 데이터를 찾기 위해 색인을 사용함, 디스크 탐색이 병목
- 데이터 웨어하우스와 유사한 분석 시스템은 최종 사용자가 아닌 비즈니스 분석가가 주로 사용하기 때문에 덜 알려져 있음, OLTP시스템보다 훨씬 더 적은 수의 질의를 다루지만 각 질의는 대개 매우 다루기 어렵고 짧은 시간에 수백만 개의 레코드를 스캔해야함, 일반적으로 디스크 대역폭(디스크 탐색이 아닌)이 병목, 칼럼 지향 저장소는 이런 종류의 작업부하를 처리할 때 사용 가능한 날로 인기가 높아지고 있는 솔루션 
- OLTP 관점
	- 로그 구조화 관점에서 파일에 추가와 오래된 파일의 삭제만 허용하고 한 번 쓰여진 파일을 절대 갱신하지 않음, 비트캐스크, SS테이블, LSM 트리, 레벨DB, 카산드라, HBase, 루씬 등이 이 그룹에 속함
	- 제자리 갱신 관점에서 덮어쓰기 할 수있는 고정 크기 페이지의 셋으로 디스크를 다룸, 이 관점에서 가장 큰 예가 B트리, B트리는 모든 주요 관계형 데이터베이스와 많은 비정형 데이터베이스에서도 사용함

# 부호와와 발전
- 데이터 부호화 형식
	- 메모리에 객체(object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table), 트리(tree) 등으로 데이터가 유지됨
	- 인메모리 표현에서 바이트열로의 전환을 부호화(직렬화,마샬링), 그 반대로 복호화(파싱, 역직렬화, 언마샬링)
	- XML과 CSV에서는 수와 숫자(digit)로 구성된 문자열을 구분할 수 없다(외부 스키마 참조는 제외). JSON 문자열과 수를 구분하지만 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않음
- 쓰기 스키마와 읽기 스키마
	- 쓰기 스키마(writer's schema) 
		- 애플리케이션이 파일이나 데이터베이스에 쓰기 위해 또는 네트워크를 통해 전송 등의 목적으로 어떤 데이터를 아브로로 부화하길 원한다면 알고 있는 스키마 버전을 사용해 데이터를 부호화함
	- 읽기 스키마(reader's schema)
		- 애플리케이션이 파일이나 데이터베이스에서 또는 네트워크로부터 수신 등으로 읽은 어떤 데이터를 복호화하길 원한다면 데이터가 특정 스키마로 복호화하길 기대함 
- 서비스를 통한 데이터플로 : REST와 RPC
	- 서버 : 네트워크를 통해 API를 공개
	- 클라이언트 : API로 요청을 만들어 서버에 연결할 수 있음
	- 서비스 : 서버가 공개한 API
	- 웹의 동작 방식
		- 클라이언트(웹 브라우저)는 웹 서버로 요청을 보냄, HTML,CSS,자바스크립트,이미지 등을 다운로드 하기 위해서는 GET 요청을 보내고, 서버로 데이터를 전송하기 위해서는 POST 요청을 보냄, API는 표준화된 프로토콜과 데이터 타입(HTTP,URL,SSL/TLS,HTML 등)으로 구성됨, 웹 브라우저, 웹 서버, 웹 사이트 작성자 대부분이 이 표준에 동의하기 때문에 모든 웹 브라우저로 모든 웹 사이트에 접근 할 수 있음
- 웹 서비스
	- REST는 간단한 데이터 타입을 강조하며 URL을 사용해 리소스를 식별하고 캐시 제어, 인증, 콘텐츠 유형 협상에 HTTP 기능을 사용함
	- RESTful : REST 원칙에 따라 설계된 API
	- SOAP : 네트워크 API 요청을 위한 XML 기반 프로토콜 , HTTP 상에서 가장 일반적으로 사용되지만 HTTP와 독립적이며 대부분의 HTTP 기능을 사용하지 않음
- 분산 액터 프레임워크
	- 액터 모델(actor model) : 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델
	- 아카(Akka) : 기본적으로 자바의 내장 직렬화를 사용, 상위 호환성이나 하위 호환성을 제공하지 않음
	- 올리언스(Orleans) : 기본적으로 사용자 정의 데이터 부호화 형식을 사용함 
	- 얼랭(erlang) 

# 분산 데이터
- 여러 장비 간 분산된 데이터베이스를 필요로 하는 이유
	- 확장성
		- 데이터 볼륨, 읽기 부하, 쓰기 부하가 단일 장비에서 다룰 수 있는 양보다 커지면 부하를 여러 장비로 분배할 수 있음
	- 내결함성/고가용성
		- 장비 하나(또는 여러 장비나 네트워크, 전체 데이터센터)가 죽더라도 애플리케이션이 계속 동작해야 한다면 여러 장비를 사용해 중복성을 제공할 수 있음, 장비 하나가 실패하면 다른 하나가 이어받음
	- 지연 시간
		- 전 세계에 사용자가 있다면 사용자와 지리적으로 가까운 곳의 데이터센터에서 서비스를 제공하기 위해 전 세계 다양한 곳에 서버를 두고 싶을 것
- 고부하로 확장
	- 더 강력한 장비를 구매하는것(수직확장, 용량 확장)
	- 많은 CPU, 많은 메모리 칩, 많은 디스크를 하나의 운영체제로 함께 결합함
	- 공유 메모리 아케틱처(shared-memory architecture)
- 비공유 아키텍처(shared-nothing) - 수평 확장, 규모 확장
	- 노드 : 데이터베이스 소프트웨어를 수행하는 각 장비나 가상 장비
- 복제 대 파티셔닝
	- 복제 : 같은 데이터의 복사본을 잠재적으로 다른 위치에 있는 여러 노드에 유지함
	- 파티셔닝 : 큰 데이터베이스를 파티션이라는 작은 서브넷으로 나누고 각 파티션은 각기 다른 노드에 할당함(샤딩)

# 복제
- 다양한 용도로 사용
	- 고가용성 : 한 장비(또는 여러 장비나 전체 데이터 센터)가 다운될 때도 시스템이 계속 동작하게 함
	- 연결이 끊긴 작업 : 네트워크 중단이 있을 때도 애플리케이션이 계속 동작할 수 있게 함
	- 지연 시간 : 지리적으로 사용자에게 가까이 데이터를 배치해 사용자가 더 빠르게 작업할 수 있게 함
	- 확장성 : 복제본에서 읽기를 수행해 단일 장비에서 다룰 수 있는 양보다 많은 양의 읽기 작업을 처리할 수 있음
- 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지
	- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄임
	- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높임
	- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘림
- 3가지 주요 접근 방식
	- 단일 리더 복제 : 클라이언트는 모든 쓰기를 단일 노드(리더)로 전송하고 리더는 데이터 변경 이벤트 스트림을 다른 복제 서버(팔로워)로 전송함
	- 다중 리더 복제 : 클라이언트는 각 쓰기를 여러 리더 노드 중 쓰기를 받아들일 수 있는 노드로 전송함
	- 리더 없는 복제 : 클라이언트는 각 쓰기를 여러 노드로 전송함 
- 리더와 팔로워
	- 복제 서버(replica) : 데이터베이스의 복사본을 저장하는 각 노드 
	- 데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리돼야함
	- 리더기반 복제(leader-based replication, 능동/수동, 마스터 슬레이브 복제) : 복제 서버 중 하나를 리더(마스터나 프라이머리)로 지정함
	- 팔로워(follower, 읽기 복제 서버(read replica), 슬레이브, 2차, 핫 대기(hot standby)) : 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터변경을 복제 로그(replication log)나 변경 스트림(change stream)의 일부로 팔로워에게 전송함
- 동기식 대 비동기식 복제
	- 동기식 : 리더는 팔로워 1이 쓰기를 수신했는지 확인해줄 때까지 기다림, 확인이 끝나면 사용자에게 성공을 보고하고 다른 클라이언트에게 해당 쓰기를 보여줌
		- 동기식 복제의 장점 : 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장함
		- 단점 : 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없음, 리더는 모든 쓰기를 차단(block)하고 동기 복제 서버가 다시 사용할 수 있을때 까지 기다려야함
	- 비동기식 : 리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않음 
		- 시스템이 원활히 동작할 때는 빠르지만 복제 지연이 증가하고 서버 장애가 발생하면 어떤 일이 일어났는지 파악하는 작업이 중요함
	- 반동기식(semi-synchronous) : 두 노드(리더와 하나의 동기팔로워)에 데이터의 최신 복사본이 있는 것을 보장함
- 리더 장애 : 장애 복구
	- 자동 장애 복구
		- 리더가 장애인지 판단함 : 고장,정전,네트워크 문제 등 잠재적으로 여러가지가 잘못될 수 있음
		- 새로운 리더를 선택함 : 새로운 리더로 가장 적합한 후보는 보통 이전리더의 최신 데이터 변경사항을 가진 복제 서버
		- 새로운 리더 사용을 위해 시스템을 재설정함 :요청 라우팅 
- 쓰기 전 로그 배송
	- 일반적으로 모든 쓰기는 로그에 기록함
		- 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분, 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션을 함 
		- 개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 변경은 쓰기 전 로그(Write-ahead log, WAL)에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원함
- 다중 리더 복제 토폴로지
	- 복제 토폴로지 : 쓰기를 한 노드에서 다른 노드로 전달하는 통신 결로를 설명함
	- 암시된 핸드오프 : 네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 홈 노드로 전송
- 최종 쓰기 승리(LWW, 동시 쓰기 버리기)
	- 최종적 수렴 달성이 목표지만 지속성을 희생함, 동일한 키에 여러 번의 동시 쓰기가 있다면 클라이언트에게 모두 성공으로 보고될지라도(w개의 복제 서버에 쓰여졌기 때문에) 쓰기 중 하나만 남고 다른 쓰기는 조용히 무시됨
	- 이전 발생(happens-before) : 작업 B가 작업 A에 대해서 알거나 A에 의존적이거나 어떤 방식으로든 A를 기반으로 한다면 작업 A는 작업 B의 이전발생
	- 동시작업 : 작업이 다른 작업보다 먼저 발생하지 않는 경우
- 동시에 쓴 값 병합
	- 형제(sibling) : 여려 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야함 
	- 툼스톤 : 시스템은 형제를 병합할 때 상품을 제거했음을 나타내기 위해 해당 버전 번호에 표시를 남겨둬야함
	- 버전 벡터(version vector) : 모든 복제본의 버전 번호 모음
- 복제 지연
	- 쓰기 후 일관성 : 사용자는 자신이 제출한 데이터를 항상 볼 수 있어야 함
	- 단조 읽기 : 사용자가 어떤 시점에 데이터를 본 후에는 예전 시점의 데이터는 나중에 볼 수 없음
	- 일관된 순서로 읽기 : 사용자는 인과성이 있는 상태의 데이터를 봐야 함
