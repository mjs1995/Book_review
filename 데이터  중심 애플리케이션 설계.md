# 서평
- 데이터 처리의 기본기를 다지기에 좋은 참고서로 데이터 모델 설계, 질의 언어 , 복제, 트랜잭션, 일괄 처리, 스트림 처리 등 데이터 처리의 다양한 측면을 다루고있다. 이 책의 목적은 다양하고 빠르게 변하는 데이터 저장과 처리 기술 분야를 탐험하는데 도움을 준다. 책의 서문에는 다음과 같은 독자에게 추천하고 있다.
	- 데이터 시스템을 확장성 있게 만드는 방법을 알고 싶은 사람(웹 또는 모바일 앱이 수백만 명의 사용자를 감당할 수 있게 하고 싶다)
	- 애플리케이션이 고가용성을 갖춰야 하고(중단시간 최소화) 운영상 견고해야 함
	- 시스템 규모가 커지고 요구사항과 기술이 바뀌더라도 오랜 기간 쉽게 유지보수할 수 있는 방법을 찾고 있다.
	- 사물의 동작 방식에 대해 타고난 호기심이 있다. 대형 웹사이트와 온라인 서비스의 내부가 어떻게 돌아가는지 알고 싶다. 이책은 다양한 데이터베이스와 데이터 처리 시스템의 내부를 분해한다. 이런 시스템 설계에 반영된 기발한 생각을 탐험하는 것이 매우 즐겁다 

# 데이터 시스템의 기초
## 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
- 애플리 케이션이 유용하려면 다양한 요구사항을 충족해야함
	- 기능적 요구 사항 : 여러 방법으로 데이터를 저장하고 조회하고 검색하고 처리하게끔 허용하는 작업과 같이 해야하는 일 
	- 비기능적 요구사항 : 보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성 
- 데이터 중심 애플리케이션(data-intensive application)은 기술적 발전을 활용해 실현 가능한 범위를 넓힘
  - 데이터 중심적(data-intensive) : 데이터 양, 데이터 복잡성, 데이터가 변하는 속도 등, 데이터가 주요 도전과제인 애플리케이션
  - 계산 중심적(compute-intensive) : CPU 사이클이 병목인 경우
	- 표준 구성 요소(standard building block)
		- 구동 어플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장(데이터베이스)
		- 읽기 속도 향상을 위해 값비싼 수행 결과를 기억(캐시)
		- 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공(검색 색인(search index))
		- 비동기 처리를 위해 다른 프로세스로 메시지 보내기(스트림 처리(stream processing))
		- 주기적으로 대량의 누적된 데이터를 분석(일괄 처리(batch processing))
- 데이터 시스템에 대한 생각
	- 레디스(Redis) : 메시지 큐로 사용하는 데이터 스토어
	- 아파치 카프카(Apache Kafka) : 데이터베이스처럼 지속성(durability)을 보장하는 메시지 큐
	- 복합 데이터 시스템(composite data system) : 외부 클라이언트가 일관된 결과를 볼 수 있게끔 쓰기에서 캐시를 올바르게 무효화하거나 업데이트하는 등의 특정 보장 기능을 제공함 
- 신뢰성(Reliability) : 결함이 발생해도 시스템이 올바르게 동작하게 만든다
	- 하드웨어나 소프트웨어 결함, 심지어 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작
	- 기대치
		- 애플리케이션은 사용자가 기대한 기능을 수행함
		- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용함
		- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족함
		- 시스템은 허가되지 않은 접근과 오남용을 방지함 
	- 내결함성(fault-tolerant) 또는 탄력성(resilient) : 결함을 예측하고 대처할 수 있는 시스템
		- 결함 : 사양에서 벗어난 시스템의 한 구성 요소
		- 장애 : 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우 
	- 하드웨어 결함
		- 하드디스크가 고장 나고, 램에 결함이 생기고, 대규모 정전 사태가 발생하고, 누군구가 네트워크 케이블을 잘못 뽑는 것과 같은 결함
		- 시스템 장애율을 줄이기 위해 각 하드웨어 구성 요소에 중복(redundancy)을 추가하는 방법
	- 소프트웨어 오류
		- 시스템 내 체계적 오류(systematic error)
			- 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그 
			- CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
			- 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
			- 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애(cascading failure)
	- 인적 오류
		- 실제 사용자에게 영향이 없는 비 프로덕션 샌드박스(sandbox)를 제공
		- 롤아웃(roll out) : 예상치 못한 버그가 일부 사용자에게만 영향이 미치게함
		- 모니터링 = 원경 측정(telemtery)
- 확장성(Scalability) : 부하가 증가해도 좋은 성능을 유지하기 위한 전략 
	- 시스템의 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법
	- 부하 기술하기
		- 시스템의 현재 부하를 간결하게 기술
		- 부하 매개변수(load parameter) : 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자(active user), 캐시 적중률 등 
	- 성능 기술하기
		- 시스템의 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사
			- 부하 매개변수를 증가시키고 시스템 자원(CPU,메모리,네트워크 대여폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
			- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 자원을 늘려야 할까?
			- 성능 수치 필요
				- 하둡 같은 일과 처리 시스템 -> 처리량(throughput: 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)
				- 온라인 시스템 : 서비스 응답 시간(response time) - 클라이언트가 요청을 보내고 응답을 받는 사이의 시간 
					- 응답 시간(response time) : 클라이언트 관점에서 본 시간, 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함함
					- 지연 시간(latency) : 요청이 처리되길 기다리는 시간, 서비스를 기다리며 휴지(latent) 상태인 시간 
		- 추가 지연을 일으키는 여러 원인
			- 백그라운드 프로세스의 컨텍스트 스위치(context switch), 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지(garbage collection pause), 디스크에서 읽기를 강제하는 페이지 폴트(page fault), 서버 랙의 기계적인 진동 
		- 백분위
			- 중앙값, 50분위, p50
			- 95분위, 99분위, 99.9분위(p95,p99,p999( 
			- 서비스 수준 목표(service level objective,SLO)와 서비스 수준 협약서(service level agreement,SLA)에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에도 자주 등장 
		- 선두 차단(head-of-line blocking) : 서버는 병렬로 소수의 작업만 처리할 수 있기 때문에(ex-CPU 코어수에 제한됨) 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체됨
	- 부하 대응 접근 방식
		- 용량 확장(scaling up, 수직확장 vertical scaling) : 좀 더 강력한 장비로 이동
		- 규모 확장(scaling out, 수평확장 horizontal scaling) : 다수의 낮은 사양 장비에 부하를 분산 
		- 비공유 아키텍처(shared-nothing) : 다수의 장비에 부하를 분산하는 아키텍처
		- 탄력적(elastic) : 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가 
		- 아키텍처를 결정하는 요소 : 읽기의 양, 쓰기의 양 ,저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등 
- 유지보수성(Maintainability) 
	- 시스템에서 작업하는 엔지니어와 운영 팀의 삶을 개선, 좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있께하며 새로운 사용 사례에 적용
	- 좋은 운용성이란 시스템의 건강 상태를 잘 관찰할 수 있고 시스템을 효율적으로 관리하는 방법을 보유
	- 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 함
	- 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 기술 채무(technical debt) 상환, 새로운 기능 추가 등 
	- 소프트웨어 시스템 설계 원칙
		- 운용성(operability) : 운영의 편리함 만들기
			- 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들기
			- 좋은 운영팀
				- 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
				- 시스템 장애, 성능 저하 등의 문제를 원인을 추적
				- 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
				- 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
				- 미래에 발생가능한 문제를 예측해 문제가 발생하기 전에 해결(용량 계획)
				- 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
				- 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스크를 수행
				- 설정 변경으로 생기는 시스템 보안 유지보수
				- 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의 
				- 개인 인사 이동에도 시스템에 대한 조직의 지식을 보존함 
			- 데이터 시스템은 동일 반복 태스크를 쉽게 하기 위해서
				- 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
				- 표준 도구를 이용해 자동화와 통합을 위한 우수한 자원을 제공
				- 개별 장비 의존성을 회피, 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함
				- 좋은 문서와 이해하기 쉬운 운영 모델(ex- X를 하면 Y가 발생한다) 제공
				- 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정으히라 수 있는 자유를 관리자에게 부여
				- 적절하게 자기 회복(self-healing)이 가능할 뿐 아니라 필요에 따라 관리자에게 시스템 상태를 수동으로 제어할 수 있게 함 
				- 예측 가능하게 동작하고 예기치 않은 상황을 최소화함
		- 단순성(simplicity) : 복잡도 관리
			- 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라
			- 복잡도 : 같은 시스템에서 작업해야하는 모든 사람의 진행을 느리게 하고 나아가 유지보수 비용이 증가 
				- 증상 : 상태 공간의 급증, 모듈 간 강한 커플링(tight coupling), 복잡한 의존성, 일관성 없는 명명(naming)과 용어,성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례(specital-casing)
		- 발전성(evolvability)
			- 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 해라, 예기치 않은 사용 사례를 적용하기가 쉬움 -> 유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)
			- 조직 프로세스 측면에서 애자일(agile) 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공 
			- 애자일 커뮤니티는 테스트 주도 개발(test-driven development(TDD))과 리팩토링(refactoring) 같이 자주 변화하는 환경에서 소프트웨어를 개발할때 도움이 되는 기술 도구와 패턴을 개발 
