# 서평
- ![제목 없는 디자인 (4)](https://user-images.githubusercontent.com/47103479/192147638-3ea844d1-a327-46e1-a442-b8e2ff18f2ad.png)
- 데이터 엔지니어로 실무를 하면서 2년차에 접어들게 되었는데 조직의 다양한 개편으로 인해 작년과 다르게 데이터를 바라보는 시각이 넓어지게 되었습니다. 세미나를 참석하면서 다양한 데이터를 다루는 조직을 간접 경험하게 되었고 tech 블로그를 통해서 다른 기술사의 조직 운영 및 기술 발전과 커리어에 대해 관심이 많이 가지게 되었습니다. 구글이 일하는 방식이 궁금하고 수만 명의 엔지니어가 다듬어온 소프트웨어 엔지니어링 지식에 대해 더 자세히 알고자 책을 선택하게 되었습니다. 
- 이 책은 소프트웨어 조직이 설계, 아키텍처 잡기, 코드 작성 시 명심해야 한다고 믿는 세 가지 기본 원칙을 강조고 있습니다. 코드가 수명을 다할 때까지 새로운 요구사항에 잘 적응하려면 어떻게 해야 하는가? 에 대한 시관과 변경, 커져가는 규모에 발맞춰 조직은 어떻게 진화해야 하는가? 에 대한 규모와 성장, 시간과 변경, 규모와 성장에서 얻은 교훈들을 바탕으로 조직은 어떻게 의사결정을 내려야 하는가? 에 대한 트레이드오프와 비용에 관하여 자세한 설명과 구글의 사례를 통해 설명하고 있습니다.
- 이 책은 구글이 소프트웨어 엔지니어링을 바라보는 주된 시각에 따라 3가지의 주제로 나누어 설명을 하고 있습니다. 
  - 첫 번째로는 문화로 구글의 문화는 독특하지만 구글이 엔지니어링 문화를 발전시키며 깨우친 교훈들은 폭넓게 적용시키며 소프트웨어 개발은 팀에 의해 이루어지므로 조직이 성장하고 건실하게 유지되려면 개발 문화 면에서도 올바른 원칙이 꼭 필요하다는 점은 강조하고 있습니다.
  - 두 번째로는 프로세스로 구글이 버텨낸 시간과 규모에서 효과적으로 작동한 프로세스들을 소개하고, 아직 시원한 답을 찾지 못한 영역도 이야기하고 있습니다.
  - 세 번째로는 도구로 끊임없이 커져가고 나이를 먹는 코드베이스를 말끔하게 관리하기 위해 구글이 도구 인프라를 어떻게 투자해왔는지를 이야기합니다. 
- 이 책은 조직 혹은 개별 프로그래머를 위한 정책,모범 사례를 평가하고 정의하는 방법, 관리 가능한 소프트웨어로 만들어주는 도구와 기술 관련 모든 주제를 다루고 있습니다. 
- 구글이 지식을 공유하는데 있어서 배움을 가로막는 장애물은 무엇이며 내 지식을 키우려면 어떻게 행동을 해야 하는지에 대해 많은 생각을 가지게 되었습니다. 또한 지식을 확장할 때 오피스 아워나 문서자료 등 프로젝트와 관련하여 다양한 시도를 해볼 수 있다는 생각을 하였습니다. 또한, 구글 엔지니어가 번아웃에서 벗어나는 방법에 대해서 보며 구글이 갈고 닦은 다양한 노하우와 삶의 지혜를 엿볼 수 있어서 좋았습니다.
- 이 책은 실무를 하고 있는 개인기여자나 조직을 올바르게 이끌어가고 싶은 리더분께 추천드리고 싶습니다. 개인 기여자로서 리더를 이해하는 데 도움이 되었고 사회생활을 통하면서 섬기는 리더가 되려면 어떠한 자세를 가져야 할지 많은 생각을 준 책이었습니다. 조직을 올바르게 이끌어가고 조직원의 커리어를 생각해주는 리더가 되었을 때 다시 한번 책을 읽으며 부족한 부분을 채우며 주니어 때 보이지 않던 다양한 감정을 느낄 거 같습니다.
 
# 전제
- 시간 위를 걷는 프로그래밍
  - 소프트웨어 엔지니어링은 단순히 코드를 작성하는 행위에 더하여, 시간의 흐름에 발맞춰 한 조직이 그 코드를 유지보수하는 데 이용하는 모든 도구와 프로세스를 포괄함
  - 소프트웨어 엔지니어링이란 흐르는 시간 위에서 순간순간의 프로그래밍을 모두 합산한 것(programming integrated over time)라는 관점 

## 소프트웨어 엔지니어링
- 프로그래밍과 소프트웨어의 엔지니어링의 가장 큰 차이는 시간, (규모) 확장, 실전에서의 트레이드오프
- 소프트웨어 엔지니어링 프로젝트에서 엔지니어는 시간의 흐름과 언젠가 변경될 가능성에 더 신경 써야 함, 소프트웨어 엔지니어링 조직은 만들어낼 소프트웨어 자체뿐 아니라 제작하는 조직까지 양 측면 모두에서의 확장과 효율에 더 집중해야 함, 소프트웨어 엔지니어는 대체로 수명과 성장 속도를 정밀하게 예측하기 어려운 상황에서 결과에 더 큰 영향을 주는 보다 복잡한 결정을 내려야 함
- 프로그래밍 작업(개발development)과 소프트웨어 엔지니어링 작업(개발 + 수정modification + 유지보수maintenance)의 차이도 궁금할 것
- 코드의 예상 수명 : 단순한 구동 수명(execution lifetime)이 아니라 유지보수 수명을 말함, 이 코드가 언제까지 개발, 구동, 유지보수 될 것인지, 혹은 이 소프트웨어의 가치가 언제까지 유효할지를 묻는 질문
- 하이럼의 법칙(Hyrum's Law) : API 사용자가 충분히 많다면 API 명세에 적힌 내용은 중요하지 않음, 시스템에서 눈에 보이는 모든 행위(동작)를 누군가는 이용하게 될 것이기 때문 
- 해시 플러딩(hash flooding) : 서비스 거부 공격(Denial-of-Service,DoS)의 하나로, 해시 테이블과 해시 함수의 구조를 아는 사용자가 일부러 해시 테이블을 느려지도록 구성한 데이터를 제공하는 공격 
- 비욘세 규칙(The Beyonce Rule) : 코드를 짰으면 자기 코드에 대한 테스트도 자기가 제대로 만들었야지 라는 뜻 
- 자동화(한 사람이 더 많은 일을 수행), 통합과 일관성(저수준 변경이 영향을 미치는 범위 제한), 전문성(적은 인원으로 더 많은 일을 수행)
- 코드베이스의 유연성에 영향을 주는 여러 요인
  - 전문성(expertise) : 여러 방법에 대한 충분한 지식
  - 안전성(stability) : 더 규칙적으로 릴리스하여 릴리스 사이의 변경량을 줄였음
  - 순응(conformity) : 업그레이드를 겪지 않은 코드가 많지 않음, 규칙적인 업그레이드가 도움이 됨 
  - 익숙함(familiarity) : 업그레이드를 정기적으로 수행하기 때문에 그 과정에서 중복되는 작업ㅇ르 찾고 자동화하려고 노력함
  - 정책(policy) : 비욘세 규칙과 같은 유용한 정책과 절차를 갖춤 
- 원점 회귀(왼쪽으로 옮기기)
  - 개발자 워크플로를 시간순으로 생각 - 개념잡기와 설계에서 시작하여 구현, 리뷰, 테스트, 커밋, 카나리를 거쳐 최종적으로 프로덕션 환경에 배포
    - 카나리(canary) : 변경 사항을 소수의 사용자 집단(주로 사내 이용자)에만 배포하여 검증하는 테스트를 말함, 베타 테스트와 달리 사용자에게 서비스가 변경되었음을 통지하지 않고 진행함 
  - 원점 회귀(shift left) : 보안성 점검을 개발 프로세스의 마지막으로 연기하면 안 된다고 호소하며 보안을 고려하는 시점을 왼쪽으로 이동시켜라(shift left on security)라고 한 말에서 유래함 
- 트레이드오프와 비용
  - 에스컬레이션 경로(escalation path) : 실무 담당자로부터 최종 결정권자까지 계층적인 의사결정권자의 목록을 말함, 결재 라인이라고 생각해됨
  - 비용, 투입된 노력과 다음의 요소들까지 모두 포괄함
    - 금융 비용(돈)
    - 리소스 비용(CPU 시간)
    - 인적 비용(엔지니어링 노력)
    - 거래 비용(조치를 취하는 비용)
    - 기회 비용(조치를 취하지 않는 비용)
    - 사회적 비용(선택이 사회 전체에 미치는 영향)
    - 현상 유지 편향(status quo bias)과 손실 회피(loss aversion)같은 치우침(bias)도 존재함 
- 엔지니어링 조직의 선택을 결정짓는 요인
  - 반드시 해야 하는 일(법적 요구사항, 고객 요구사항)
  - 근거에 기반하여 당시 내릴 수 있는 최선의 선택(적절한 결정권자가 확정)
- 의사결정을 위한 근거 자료
  - 관련한 정략적 데이터를 모두 측정할 수 있거나 최소한 추정이라도 할 수 있는 경우
  - 측정하기 어렵거나 측정 방법을 모르는 정략적 데이터 존재 

# 문화
## 팀워크 이끌어내기 
- 버스 지수(bus factor)
    - 몇 명의 팀원이 버스에 치여서 일을 할 수 없게 될 때 프로젝트가 망하게 되는지를 나타내는 지수 
    - 혼자 일하게 되면 버스 지수 외에 전반적인 진행 속도에도 해로움, 혼자 일한다는 것은 고된 싸움이며 사람들의 기대보다 훨씬 느리다는 점을 잊기 쉬움 
    - 다른 이들과 함께 어울려 일하면 개인의 노력만으로는 깨우치기 어려운 공동의 지혜라는 이점을 얻을 수 있음 
- 모든 건 팀에 달렸다
  - 다른 사람과 함께 일해야 함, 비전을 공유하세요, 역할을 나누세요, 다른 이로부터 배우세요, 멋진 팀을 만드세요
- 사회적 상호작용의 세 기둥
  - 겸손(humility)
    - 당신과 당신의 코드는 우주의 중심이 아님, 당신은 모든 것을 알지도, 완벽하지도 않습니다. 겸손한 사람은 배움에 열려 있습니다.
  - 존중(respect)
    - 함께 일하는 동료를 진심으로 생각합니다. 친절하게 대하고 그들의 능력과 성취에 감사해야함
  - 신뢰(trust)
    - 동료들이 유능하고 올바른 일을 하리라 믿습니다. 필요하면 그들에게 스스로 방향을 정하게 해도 좋습니다.
- 집단적 자존심(collective) : 자신이 잘 아는 분야에 대해 걱정하는 대신 팀의 성취와 단계의 자부심을 높이려 노력하기 
- 빠르게 실패하고 반복하기
  - 실패는 선택이다, 가끔씩 실패하지 않는다면 충분히 혁식적이지 않거나 위험을 충분히 감수하지 않은 것이다.
  - 실패를 배우고 다음 단계로 넘어갈 수 있는 절호의 기회라고 생각하는 것, 동일한 일을 반복해서 실패한다면(즉, 다음 단계로 넘어가지 못한다면) 실패한 게 아니라 무능한 것 
- 비난 없는 포스트모템 문화(postmortem - 프로젝트를 마친 후 전 과정을 되돌아보며 잘된 점과 잘못된 점을 되돌아보는 사후 검토 작업을 말함)
  - 무엇을 배웠는지와 배운 것을 토대로 앞으로 무엇을 바꿀지가 담겨야 함 
  - 사건의 개요
  - 사건을 인지하고 해결에 이르기까지의 타임라인
  - 사건의 근본 원인
  - 영향과 피해 평가
  - 문제를 즉시 해결하기 위한 조치 항목(소유자 명시)
  - 재발 방지를 위한 조치 항목
  - 해당 경험에서 얻은 교훈
- 인내심을 기르자
  - 구덩이에 뛰어들어 많은 것을 빠르게 시도해보고 세부사항은 넘기면서 길을 찾아내는 상향식(bottom-upp)엔지니어
  - 먼저 전체 지형을 파악하고, 필요한 거의 모든 메서드를 구현한 뒤에야 버그 사냥에나서는 하향ㅅ힉(top-down) 엔지니어 
- 구글답게 하기
  - 모호함을 뚫고 번창한다 - 끊임없이 변화하는 환경 속에서도 상충하는 메시지와 방향에 잘 대처하고, 합의를 이끌어내고, 문제에 대한 진전을 이룰 수 있음 
  - 피드백을 소중히 한다 - 피드백을 주고받을 때 품위와 겸손을 유지하고 개인과 팀의 발전에 피드백이 주는 가치를 이해함 
  - 저항(항상성)을 극복한다 - 다른 이들이 저항하거나 관성 때문에 움직이지 않으려 하더라도 야심 찬 목표를 세우고 밀고 나아감
  - 사용자를 우선한다 - 구글 제품의 사용자 입장에서 생각하고 존중하며 그들에게 가장 도움되는 행동을 추구함
  - 팀에 관심을 기울인다 - 동료들의 입장에서 생각하고 존중하며 팀의 결집을 위해 누가 시키지 않더라도 적극적으로 도움 
  - 옳은 일을 한다 - 모든 일에 강한 윤리 의식을 갖고 임함, 팀과 제품의 진정성을 지키기 위해서라면 어렵거나 불편한 결정을 내릴 수 있어야 함 

## 지식 공유
- 배움을 가로막는 장애물
  - 심리적 안전 부족
    - 불이익이 두려워서 스스로 위험을 감수하거나 실수를 드러내기 꺼리는 환경 
  - 정보 섬(information islands)
    - 조직의 각 부서가 서로 소통하거나 자원을 공유하지 않아서 지식이 파편화됨
    - 정보 파편화 : 섬마다 서로 다른 그림을 그리고 그마저도 불완전함
    - 정보 중복 : 섬마다 나름의 작업 방식을 재창조함
    - 정보 왜곡 : 같은 일이라도 섬마다 작업 방식이 다르고, 심지어 충돌하기도 함 
  - 단일 장애점(single point of failure,SPOF)
    - 중요한 정보를 한 사람이 독점하면 병목이 생김, 단기 효율을 높여주는 대신(내가 하는 게 빠르지) 장기 확장성을 희생하는 꼴
  - 전부 아니면 전무 전문성(all-or-nothing expertise)
    - 조직 구성원이 모든 것을 아는 사람과 아무것도 모르는 초심자로 나뉨, 지식과 책임은 계속 이미 전문가가 된 사람들에게 집중되고, 새로운 팀원이나 초심자들은 그들만의 울타리에 갇혀 느리게 성장하게 됨 
  - 앵무새처럼 흉내내기(parroting)
    - 이해하지 못한 상태로 흉내만 내는것을 말함 
  - 유령의 묘지(haunted graveyard)
    - 무언가 잘못될 게 두려워서 아무도 손대지 않는 영역(주로 코드)
- 철학
  - 소프트웨어 엔지니어링을 여러 버전의 프로그램을 여러 사람이 참여해 개발하는 일 
- 내 지식 키우기
  - 질문하기
    - 초심자가 저지르는 가장 큰 실수는 무언가 막혔을 때 질문하지 않는 것, 혼자서 극복해내고 싶다거나 너무 기초적인 질문이란 소리를 듣는게 두려워서 일 수 있음
    - 도움을 청하기 전에 최대한 노력해봐야 해라고 생각할지 모름, 여러분의 동료가 가장 훌륭한 정보 소스일 경우가 많음, 이 귀중한 자원을 충분히 활용하기 
    - 가면 증후군(impostor syndrome) : 사기꾼 신드롬, 자신의 능력보다 과대평가받고 있다고 느껴서, 자칫 실수하면 자신이 사기꾼임을 들킬지 모른다는 두려움을 말함, 걱정하지 말고 모르는 건 바로바로 물어봐야 더 빨리 성장하고 팀에도 더 빨리 녹아들 수 있음 
    - 팀의 리더든 새로운 멤버든 항상 무언가 배울 게 있는 환경에서 살아야 함, 그렇지 않으면 더 이상 성장하지 못할 것(그리고 결국 새로운 환경을 찾아 떠나게 되겠죠), 특히 조직(혹은 팀)의 리더들이 솔선수범해서 이런 문화를 만들어야함 
    - 끈기를 가지고 상냥하게 답변해줘야 사람들이 안심하고 도움을 청하는 환경이 조성됨, 초기의 망설임을 극복하면 분위기를 빠르게 조성할 수 있으니 질문을 하도록 권장하고 사소한 질문이라도 답을 얻을 수 있도록 힘써주기 
  - 맥락 이해하기
    - 무언가를 옮기거나 바꾸려면 그게 왜 그자리에 있는지부터 이해하자라고말하는 체스터슨의 울타리(Chesterson's fence)원칙 
- 질문 확장하기 : 커뮤니티에 묻기
  - 미래의 자신을 위해서라도 무언가를 일대일로 배울 때는 기록하는 습관을 기르기, 여러분보다 나중에 들어오는 동료들도 여러분과 똑같은 질문을 할 가능성이 큼, 기록해둔 지식을 공유하기 
- 지식 확장하기
  - 오피스 아워
    - 때로는 사람과 직접 대화를 해야지만 쉽게 풀리는 문제가 있음
    - 오피스 아워(office hours)가 좋은 해결책이 될 수 있음, 누군가가 특정 주제에 관한 질문에 답해줄 목적으로 시간을 비워 둔 정기적인 이벤트(보통은 매주 똑같은 시간에 진행함)
    - 전문가와의 면담은 문제가 여전히 불명확하여 어떻게 질문해야 할지 모를 때나(가령 새로운 서비스 설계를 막 시작했을 때) 문서화되지 않은 특수한 문제에 맞닥뜨렸을 때 특히 유용함 
  - 기술 강연과 수업
    - 기술 강연(tech talk)과 수업(class), 연사가 청중에게 직접 강의하는 형태로 진행됨
    - 자꾸 오해를 일으킬 정도로 복잡한 주제를 다뤄야 함 
    - 주제가 비교적 안정적이어야 함 
    - 질문에 답해주고 일대일로 도와줄 수 있는 교사가 있어야 효과가 큰 주제여야 함 
    - 수업을 정기적으로 개설해도 될 만큼 수요가 많아야 함 
  - 문서자료 
    - 독자가 무언가를 배울도록 돕는 것을 최우선 목표로 하는 기록된 지식 
    - 문서자료 갱신하기
      - 무언가를 막 배운 순간이 기존 문서자료에서 개선점을 찾기에 가장 좋을 때
    - 새로운 문서자료 작성하기
      - 숙달되면 자신만의 문서자료를 작성하고 기존 문서자료들을 갱신하기, 다른 사람에게 공유하여 여러분이 걸어간 길을 쉽게 따라오도록 하기 
      - 나아가 그 문서자료를 다른이들이 찾기 쉽도록 해주면 금상첨화 
      - 피드백할 방법이 있어야 함 
    - 문서화 촉진하기
      - 문서자료에 담긴 정보는 기본으로 참고해야 할 표준이 됨 
      - 표준을 팀 외부로 확산시킬 수도 있음 
- 조직의 지식 확장하기
  - 표준 정보 소스 구축하기
    - 회사 차원의 중앙집중적 정보 원천(sources of information)으로 전문가의 지식을 표준화하고 전파하는 수단 
  - 개발자 가이드
    - 공식 가이드, 코딩 스타일 가이드, 공식 소프트웨어 엔지니어링 모범 사례, 코드 리뷰 가이드와 테스트 가이드, 금주의 팁(TotW - Tips of the Week)
    - 전문가는 회사 차원의 방침을 개인적으로 설명해주지 않아도 되므로 시간이 절약되고, 배우는 사람은 필요하면 언제든 신뢰 가는 정보를 찾아볼 수 있는 정보 소스가 있음을 알게 됨 
- 가독성 인증 프로세스
  - 모든 변경 목록(CL - changelist)은 가독성 승인을 얻어야 함 
  - 가독성 승인(readability approval)이란 해당 언어의 가독성 자격증(readability certificaition)이 있는 누군가가 해당 CL을 승인했다는 표시 

## 공정 사회를 위한 엔지니어링
- 프로그래밍은 당면한 문제에 집중하여 코드를 생산함, 소프트웨어 엔지니어링은 수십 년 혹은 평생에 걸친 유동적이고 모호한 문제에 대응하기 위해 코드, 도구, 정책, 프로세스 등을 응용하는 더 폭넓은 개념 
- 리크루터는지원자 모집과 초기 인터뷰까지 진행하는 사람을 말하며, 채용 관리자는 최종적으로 도장을 찍는 사람을 뜻함 
- 가치 vs 결과
  - 자신을 솔직하게 바라보고 성찰하자 
  - 모두를 위해 만들지 말자, 모두와 함께 만들자
  - 제품을 이용하기 가장 어려운 이들을 위해 설계하자
  - 가정하지 말고, 시스템 전반의 공정성을 측정하자 

## 팀 이끌기
- 관리자(manager)는 사람을 이끌고 테크 리드(tech lead)는 기술과 관련된 책임을 짐 
- 관리자와 테크 리드
  - 테크 리드 매니저(tech lead manager) : 신생 팀이라면 관리자와 테크 리드 역할을 한 사람이 맡음
  - 엔지니어링 관리자
    - 자신이 관리하는 팀의 구성원 모두 (테크 리드도 포함)의 성과(performance), 생산성(productivity), 행복(happiness)을 책임져야 함 
  - 테크 리드
    - 제품의 기술적인 면, 즉 기술과 관련한 결정과 선택, 아키텍처, 우선순위, 성능과 일반적인 프로젝트 관리를 책임짐
    - 팀 관리자의 직속일 때가 많고, 규모가 큰 팀일 경우엔 별도의 프로그램 관리자(program manager)를 두어 프로젝트 관리를 지원토록 함 
    - 엔지니어링 관리자와 긴밀히 협조하여 맡겨진 제품을 개발하는 데 필요한 팀원을 확보하고 엔지니어들의 기술 스펙트럼과 기술 수준을 최대한 활용해 목표를 완수하게끔 이끌어야 함 
  - 테크 리드 매니저
    - TLM은 인적,기술적 요구를 혼자 관장하는 사람 
    - 구글에서는 규ㅜ모가 크고 잘 조직된 팀이라면 테크 리드와 엔지니어링 매니저를 각 1명씩, 총 두명이 이끄는 것이 통례
    - 자신의 일, 위임, 사람 관리 사이에서 균형을 잡는 요령을 배워야함 
- 개인 기여자에서 리더로
  - 두려워해야 할 건 오직... 전부다
    - 사람들 대부분이 관리자라는 단어를 불쾌해 함, 소프트웨어 개발 분야에서 가장 큰 이유는 바로 코딩할 시간이 크게 줄어든다는 점 
    - 경력 대부분을 코딩하며 보낸 사람이라면 하루의 끝에서 작성한 코드, 설계 문서, 해결한 버그 더미 등을 가리키며 이게 오늘 내가 한 일이야라고 외칠 수 있음, 하지만 관리 일로 바삐 보낸 하루의 끝에서는 오늘 한 일이 하나도 없군이라고 생각하게 되는 경우가 허다함 
    - 피터의 법칙 : 위계 조직에서 직원들은 자신의 무능력이 드러나는 직급까지 승진하는 경향이 있음
      - 주어진 위치에서 뛰어난 성과를 내는 직원은 승진을 거듭하다가 더는 성과를 낼 수 없는 위치까지 올라선 후 멈추게 됨, 그래서 결국 조직 전체가 무능한 사람들로 채워지는 역설적인 상황 
    - 코드는 정말 잘짜지만 사람을 관리하거나 팀을 이끌 마음이 전혀 없는 엔지니어에게 억지로 관리자나 테크 리드 역할을 맡기면, 여러분은 형편없는 관리자를 얻는 대신 뛰어난 엔지니어를 잃게됨 
  - 섬기는 리더십(Servant Leadership)
    - 팀을 떠받드는 것, 섬기는 리더로서 여러분은 겸손,존중,신뢰의 분위기를 조성하려 힘써야함
    - 섬기는 리더는 팀이 나아가는 길 앞의 균열을 메우고 필요할 때 조언을 해줌, 자신의 손을 더럽히는 데 주저하지 않음, 섬기는 리더가 행하는 관리는 오직 팀의 기술적, 사회적 건강 관리뿐 
- 오늘날의 엔지니어링 관리자
  - 전통적인 관리자는 일을 어떻게 처리할지를 고민하는 반면, 훌륭한 관리자는 무슨일을 처리할지 고민함(그리고 어떻게는 팀을 믿고 맡김) 
- 안티패턴
  - 만만한 사람 고용하기
    - 여러분보다 똑똑하고 여러분을 대체할 역량을 갖춘 사람을 적극적으로 뽑아야함, 실제로 그 사람들이 여러분의 위치를 시시때때로 위협할 수 있음(여러분이 실수를 저지르면 지적해주기도 하고요), 하지만 이 사람들은 여러분에게 강렬한 자극과 함께 멋진 일들도 안겨줄 것
    - 스스로 할 일을 찾고 확장하며, 일부는 스스로 팀을 이끌고 싶어 할 것 
  - 저성과자 방치하기
    - 저성과자의 역량이 높아지기를 혹은 어디론가 떠나기를 희망하는 사이, 팀의 다른 고성과자들은 저성과자들을 밀고 당겨주느라 귀중한 에너지를 낭비하고 팀의 사기는 서서히 떨어져감
    - 저성과자를 방치하는 일은 새로운 고성과자가 팀에 합류하는 걸 막기도 하며, 그나마 있던 팀내 고성과자를 떠나게도 함 
  - 사람 문제 무시하기
  - 만인의 친구 되기 
  - 채용 기준 타협하기
  - 팀을 어린이처럼 대하기 
- 올바른패턴
  - 자존심 버리기
    - 리더 역할이 처음인 사람은 대부분 모든 사안을 올바르게 결정하고, 모든 것을 알고, 모든 질문에 답해야 한다는 강박으로 스스로를 옭아맴
    - 사과한다고 돈이 드는 건 아니잖아요? 사람들은 무언가를 망쳤으면 사과할 줄 아는 리더를 존경함 
  - 마음 다스리기
  - 촉매자 되기
    - 고무 오리 디버깅(Rubber Duck Debugging) : 먼저 고무 오리 인형을 장만하고, 고무 오리에게 문제의 코드를 한줄 한줄 설명하다 보면 오리가 깨달음을 주곤 함, 자신의 생각을 정리하다 보면 해결책이 떠오르곤 하는 원리를 고무 오리라는 가상의 대화 상대를 촉매로 디버에 적용한 기법
  - 장애물 치우기 
  - 선생이자 멘토 되기
    - 새로 합류하여 팀의 문화에 익숙해지고 적절한 수준 및 팀이 활용하는 기술과 코드베이스를 공부하고 있는 팀원에게 매우 중요함
    - 훌륭한 멘토라면 성장하는 팀에 발맞춰 멘티가 배우는 데 쓰는 시간과 제품 개발에 기여하는 시간의 균형을 잘 잡아줘야 함
    - 팀의 프로세스와 체계에 대한 경험, 다른 이에게 무언가를 설명해주는 능력, 마지막으로 멘티에게 도움이 얼마나 필요한지를 측정하는 능력 
  - 명확한 목표 세우기 
  - 정직하기 
  - 행복한지 확인하기 
    - 리더로서 팀의 생산성을 장기적으로 더욱 끌어올리려면(이탈하는 팀원 줄이기 포함) 팀원들이 행복해하는지를 확인하는 데도 시간을 써야함 
    - 수시로 팀원들의 복지를 챙기고, 그들이 하는 일을 인정해주고, 일에 만족하는지 확인하기, 한 테크 리드 매니저는 지저분하고 표 안 나는 일, 하지만 꼭 해야만 하는 일들을 스프레드시트에 정리한 다음 모든 팀원에게 고르게 분배되도록 관리함 
    - 테크 리드 매니저는 팀이 일한 시간을 측정하여 이따금 대체 휴가를 주거나 팀 소풍을 보내주기도 했음, 번아웃과 피로 누적을 피하는 방법
    - 팀원들과의 서먹함도 줄일 겸 일대일 면담을 하며 기술적인 이야기를 나누곤 함, 친해진 다음에는 하는 일에 만족하는지, 다음 프로젝트로 무얼 하고 싶은지 같은 이야기를 나눴음 
    - 마지막에 뭐 필요한거 없어요?라고 묻는 것, 팀원들의 생산성과 행복 증진에 필요한 것을 갖춰주는 데 아주 효과적인 마무리 멘트 

## 성장하는 조직 이끌기
- 3A 리더십 : 늘 결정하라(Always Be Deciding) , 늘 떠나라(Always Be Leaving), 늘 확장하라(Always Be Scaling)
- 웹 검색의 트레이드 오프 : 좋게(품질), 빠르게(지연시간), 저렴하게(용량)
- 성공 사이클
  - 분석 : 문제가 주어지고 해결하기 위해 씨름을 시작함
  - 분투 : 팀이 준비가 덜 되었다고 생각하더라도 일에 착수함, 실패할 경우에도 대비해야 함
  - 견인 : 결국 팀이 문제를 정복하기 시작함
  - 보상 : 성공의 보상은 더 많은 일과 더 많은 책임 
  - 압축 단계(compression stage) : 새로운 문제를 받아왔는데 (보통은) 인력 충원은 없음, 맡겨진 문제가 두 개가 되어버렸음, 원래의 문제도 여전히 관리가 필요하니 절반의 인력과 절반의 시간을 할애함 , 결국 새로운 문제는 나머지 절반의 인력으로만 대응해야 함, 이러한 사이클의 마지막 단계를 뜻함, 지금까지 하던 모든 작업을 절반 크기로 압축한다는 뜻 
  - 문제를 압축하려면 팀 효율을 극대화할 방법을 찾아야 하며, 동시에 자신의 시간과 집중력을 더 커진 책임 범위에 맞춰 확장하는 방법도 배워야 함 
- 에너지 관리하기
  - 진짜 휴가 떠나기 
  - 일과 쉽게 단절하기 : 일에서 신경을 끄려거든 업무용 랩톱을 회사에 두고 떠나기, 휴대폰에 업무용 앱이 깔려있다면 지우기
  - 진짜 주말 보내기 : 직장과 단절된 상태에서만 재충전이 이뤄짐, 금요일 저녁에 미련 없이 퇴근한 후 주말에는 오롯이 자신이 좋아하는 일만 하기 
  - 매일매일 휴식하기 : 자연적으로 인간의 뇌는 90분 주기로 운용됨, 90분마다 돌아오는 이 기회를 의자에서 일어나 사무실 주변을 돌거나 10분 정도 산책하는데 사용하기 
  - 스스로에게 정신 건강의 날을 가질 수 있는 권한을 부여하기 

## 엔지니어링 생산성 측정하기 
- GSM 프레임워크 : 목표와 신호를 뒷받침하는 의미 있는 지표 선정하기 
  - GSM은 목표(goal), 신호(signal), 지표(metric)의 약자
  - 목표는 측정자가 원하는 최종 결과, 측정을 통해 이해하고 싶은 내용을 고차원의 어휘로 표현하되 특정한 측정 방식을 명시해서는 안 됨
  - 신호는 원하는 최종 결과를 이루었는지 판단하는 방법, 우리가 측정하고 싶어 하는 것이지만 신호 자체는 측정하지 못할 수도 있음
  - 지표는 신호를 대변함, 우리가 실제로 측정하는 대상, 이상적인 측정법은 아닐 수 있으나 충분히 가깝다고 믿는 것이어야 함 
  - 가로등 효과(streetlight effect) : 가로등 아래에서 열쇠 찾기, 보이는 곳만 봐서는 정작 열쇠가 떨어진 곳은 살펴보지 못할 수 있다는 뜻 
  - GSM은 실제로 결과를 측정하기 앞서 원칙에 입각하여 적절한 지표들을 선정하게 해줌으로써 지표 크리프(metrcis creep)와 지표 편향(metrics bias)을 예방해줌
  - GSM은 측정이 되는 영역과 그렇지 않은 영역을 알려줌 
- 목표
  - 퀀츠(QUNATS)
    - 코드 품질(Quality of the code) : 작성한 코드의 품질은 어떤가? 희귀 버그를 예방하기에 충분한 테스트 케이스가 갖춰졌는가? 아키텍처는 위험과 변경을 받아들일 수 있을 만큼 유연한가? 
    - 엔지니어들의 몰입도(Attention from engineers) : 엔지니어들이 얼마나 자주 몰입 상태에서 깨어나는가? 알림은 엔지니어의 주의력이 얼마나 흐트리는가? 도구는 엔지니어들이 작업 맥락을 전환하는 데 도움을 주는가?
    - 지적 복잡성(intellectual complexity) : 작업을 완료하는 데 인지 부하가 얼마나 걸리는가? 해결해야 할 문제에 내재된 복잡성은 어느 정도인가? 엔지니어들이 불필요한 복잡성을 처리해야 하는가?
    - 박자와 속도(Tempo and velocity) : 엔지니어들이 작업을 얼마나 빨리 완수할 수 있는가? 릴리스를 얼마나 빨리 밀어낼 수 있나? 주어진 시간에 얼마나 많은 작업을 완료하는가?
    - 만족도(Statisfaction) : 엔지니어가 도구에 얼마나 만족하는가? 도구가 엔지니어에게 필요한 기능을 얼마나 잘 지원하는가? 엔지니어들이 주어진 업무와 완성한 제품에 얼마나 만족하는가? 엔지니어들이 번아웃되지는 않는가?

# 프로세스 
## 스타일 가이드와 규칙
- 규칙은 곧 법, 제안이나 권장사항이 아닌, 엄격하고 꼭 지켜야 하는 법
- 지침(guidance)은 권장사항과 모범 사례를 말함, 따르면 편이 이득이라서 어지간하면 따르라고 권하지만, 규칙과 달리 다소 변형해 적용해도 괜찮음 
- 규칙을 만들때 중요한 원칙
  - 규칙의 양을 최소화
  - 코드를 읽는 사람에게 맞춤
  - 일관되어야 함
  - 오류가 나기 쉽거나 예상치 못한 동작을 유발하는 구조를 피함
  - 꼭 필요하다면 실용성을 생각해 예외를 허용함 
- 스타일 가이드
  - 위험을 피하기 위한 규칙
  - 모범 사례를 적용하기 위한 규칙
  - 일관성을 보장하기 위한 규칙 
- 사소함의 법칙(law of triviality) : 중요한 사안을 고민하는 데는 아주 적은 시간만 들이면서 사소한 일에는 필요 이상의 시간과 노력을 들이는 현상 
- 스타일의 중재자
  - 스타일 중재자(style arbiter) : 구글의 스타일 가이드들은 언어별로 소유자가 따로 있어서 최종 결정과 승인을 책임짐, 이러한 소유자 들을 일컬음
  - 프로그래밍 언어별로 경험 많은 전무가 그룹이 스타일 가이드를 소유하고 결정권자 역할을 함 
- 프리서브밋 검사(presubmit check) : 서브밋 직전 검사 

## 코드 리뷰
- 코드 리뷰는 작성자 이외의 사람이 코드를 검토하는 프로세스로, 주로 코드를 코드베이스에 반영하기 전에 수행함 
- 코드 리뷰는 버그가 코드베이스로 침투하기 전에 잡아낸다 처럼 확실하고 쉽게 납득하는 이점을 제공함 
- 코드 리뷰 흐름
  - 프리커밋 리뷰(precommit review: 커밋 직전 리뷰) :구글에서는 변경을 코드베이스에 커밋하기 전에 수행함
  - 합의한 엔지니어는 좋아 보임(looks good to me)이라는 뜻의 LGTM이라는 태그를 달아 의사를 표현함 
- 구글의 코드 리뷰
  - 다른 엔지니어로부터 정확성(correctness)과 이해 용이성(comprehension)을 평가받음, 작성자가 의도한 작업을 코드가 적절하게 수행하는지를 봄
  - 변경되는 코드 영역을 관리하는 코드 소유자(code owner)로부터 변경 코드가 적절하다는 (그리고 특정 디렉터리에 체크인해도 좋다는) 승인을 받음 
  - 누군가로부터 가독성 승인을 받음, 변경 코드가 해당 언어의 스타일과 모범 사례를 잘 따르고 조직에서 기대하는 방식으로 작성되었는지를 검사받음 
- 코드 리뷰의 이점
  - 잘 설계된 코드 리뷰 프로세스와 코드 리뷰를 중요하게 다루는 문화가 주는 대표적인 이점
  - 코드가 정확한지 확인해줌
  - 변경된 코드를 다른 엔지니어도 잘 이해함
  - 코드베이스가 일관되게 관리됨
  - 팀이 소유권(주인의식)을 더 강하게 느낌
  - 지식이 공유됨
  - 코드 리뷰 자체의 기록이 남음 
- 지식 공유
  - 리뷰 프로세스는 제안, 신기술 소개, 조언을 통해 리뷰어가 변경 작성자에게 도메인 지식을 전파하도록 이끌어줌(리뷰어는 작성자를 도와줄 생각으로 가볍게 FYI 주석을 남길수 있음 - 참고로, for your information)
- 코드 리뷰 유형
  - 그린필드 리뷰와 새로운 기능 개발
    - 완전히 새로운 코드를 대상으로 하는 가장 드문 유형의 코드리뷰, 대상 코드가 오랜 기간 존속될 수 있는지를 평가하기에 가장 중요한 기회
    - 코드는 시간이 흐르고 프로젝트 규모가 커져 초기에 내린 가정들이 변해도 여전히 유지보수하기 쉬워야 함 
    - 그린필드 : 아무런 기반 시설이나 기초 작업 없이 잡초만 무성한 허허벌판에서 시작하는 공사에 빗대어 부름 
  - 동작 변경, 개선, 최적화
    - 꼭 필요한 변경인지, 코드베이스를 개선하는지를 살펴야 함
  - 버그 수정과 롤백
  - 리팩터링과 대규모 변경 
    - 대규모 변경(large-scale change(LSC) 프로세스ㅓ)

## 문서자료
- 코드와 독립적인 일반적인 의미인 문서 혹은 기록으로 남기는 행위로서의 문서화와 명확하게 구분하기 위해 문서자료로 옮김
- 문서자료의 혜택
  - API를 가다듬는 데 도움을 줌, API 문서화는 API가 가치가 있는지를 알아내는 가장 확실한 방법 중 하나, 문서화를 하다 보면 자연스럽게 자신의 설계를 되돌아보게 됨
  - 유지보수를 위한 로드맵과 과거 이력을 제공함, 코딩에서 꼼수는 무조건 피해야 하지만, 어쩔 수 없다면 주석이라도 잘 달아둬야 함 
  - 코드를 더 전문적이고 매력 있어 보이게 함 
  - 이용자들의 질문이 줄어듬
- 문서자료의 취급
  - 꼭 따라야 하는 내부 정책과 규칙이 있어야 함
  - 버전 관리 시스템에 등록해 관리해야 함
  - 관리 책임자를 명시해야 함
  - 변경 시 (문서자료가 설명하는 코드와 함께) 리뷰를 거쳐야 함
  - 코드상의 버그를 추적하듯 문제를 추적해야 함
  - 주기적으로 평가(혹은 테스트)를 받아야 함
  - 가능하다면 정확성이나 최신 정보 반영 여부 등을 측정해야함
- 독자 유형
  - 문서를 짧게 쓰려면 때로는 모든 정보를 담아 길게 쓴 다음 간명하게 편집하고 중복된 정보를 삭제하는 과정을 거쳐야 함
  - 프랑스의 철학자인 블레즈 파스칼(Blaise Pascal)은 시간이 더 있었따면 편지가 보다 짧아졌을 거에요 라고 말함
  - 탐색자(seeker) : 자신이 원하는 것을 정확히 알고, 읽고 있는 문서자료가 원하는 정보를 담고 있는지를 알고 싶어 하는 엔지니어, 일관성이 핵심, 비슷한 포맷을 일관되게 적용하는 게 좋음 
  - 배회자(stumbler) : 무엇을 원하는지를 정확하게 알지 못하는 사람, 명료한 글이 효과적
- 문서자료 유형
  - 소프트웨어 엔지니어가 자주 작성하게 되는 주요 문서의 종류
    - 참조용 문서자료(코드 주석 포함)
    - 설계 문서
    - 튜토리얼
    - 개념 설명 문서자료
    - 랜딩 페이지
- 문서자료 리뷰
  - 정확성 확인용 기술 리뷰 : 주로 해당 주제 전문가가 수행하며, 팀 동료인 경우가 많음, 코드 리뷰 과정에서 함께 다룸
  - 명확성 확인용 독자 리뷰 : 주로 도메인을 잘 모르는 사람이 수행함, 팀에 새로 합류한 동료나 해당 API의 고객일 것
  - 일관성 확인용 작문 리뷰 : 주로 테크니컬 라이터나 지원자가 수행함
- 좋은 문서 자료의 특징 : 완전성(completeness), 정확성(accuracy), 명확성(clarity)

## 테스트 개요
- 테스트를 작성하는 이유
  - 테스트하려는 단 하나의 행위(주로 메서드나 API)
  - 특정한 입력(API에 전달하려는 값)
  - 관측 가능한 출력 혹은 동작
  - 통제된 조건(하나의 격리된 프로세스 등)
- 테스트 스위트(test suit) : 간단한 테스트가 수백에서 수천 개 모이는것
- 가장 순수한 형태의 자동 테스트는 테스트 작성, 테스트 수행, 실패한 테스트에 대한 조치, 자동 테스트는 적은 양의 코드로 구성됨
- 테스트 코드가 주는 혜택
  - 디버깅 감소
  - 자신 있게 변경
  - 더 나은 문서자료
  - 더 단순한 리뷰
  - 사려 깊은 설계
  - 고품질의 릴리스를 빠르게
- 테스트 스위트 설계하기
  - 크기는 테스트 케이스 하나를 실행하는 데 필요한 자원을 뜻함, 메모리, 프로세스, 시간 등 
  - 범위는(scope)는 검증하려는 특정한 코드 경로(code path)를 뜻함
- 작은 테스트
  - 테스트가 단 하나의 프로세스에서 실행되어야 한다는 것 
  - 테스트도 테스트 대상 코드와 같은 프로세스에서 실행되어야 한다는 뜻 
- 중간 크기 테스트
  - 중간 크기 테스트는 여러 프로세스와 스레드를 활용할 수 있고, 로컬 호스트로의 네트워크 호출 같은 블로킹 호출도 이용할 수 있음, 단 외부 시스템과의 통신은 여전히 불허함
- 큰 테스트
  - 중간 크기 테스트를 구속하던 로컬 호스트 제약에서 해방되어, 테스트와 대상 시스템이 여러 대의 기기를 활용할 수 있게 됨
  - 전체 시스템의 종단간(end-to-end) 테스트 - 코드 조각이 아닌 설정을 검증하는게 주된 목적
  - 테스트 대역을 사용하는 게 불가능한 레거시 컴포넌트를 테스트할 때
- 테스트 크기와 무관한 공통 특성
  - 모든 테스트는 밀폐(hermetic)되어야 함, 셋업(setup), 실행(execute), 테어다운(tear down)하는 데 필요한 모든 정보를 담고 있어야 함
  - 테스트 수행 순서 같은 외부 환경에 관해서는 가능한한 아무것도 가정하지 않아야 함 
- 테스트 범위(test scope)
  - 주어진 테스트가 얼마나 많은 코드를 검증하느냐 
  - 좁은 범위 테스트(narrow-scoped test)는 독립된 클래스나 메서드같이 코드베이스 중 작은 일부 로직을 검증하도록 설계됨
  - (보통 통합 테스트 integration test)중간 범위 테스트(medium-scoped test)는 적은 수의 컴포넌트들 사이의 상호작용을 검증하도록 설계됨, 서버와 데이터베이스의 상호작용을 검증함
  - (보통 기능 테스트 functional test, 종단간 테스트 end-to-end test, 시스템 테스트 system test 등으로 불리는) 넓은 범위 테스트(large-scoped test)는 시스템의 서로 다른 부분들 사이의 상호작용, 혹은 클래스나 메서드 하나만 실행할 때는 괜찮다가 여럿을 조합해 실행하면 나타나는 예기치 못한 동작을 검증하도록 설계됨 
  - 아이스크림 콘(ice cream cone)에서는 엔지니어들이 종단간 테스트를 많이 작성하고 통합 테스트나 단위 테스트는 훨씬 적게 작성함, 스위트는 일반적으로 느리고 신뢰할 수 없으며 고치기도 어려움
  - 모래시계(hourglass)는 종단간 테스트와 단위 테스트는 많지만 통합 테스트가 적음, 구성요소들이 강하게 커플링되어 각각의 인스턴스를 독립적으로 만들어낼 수 없을 때 나타남 
- 의도적으로 실패 상황을 만드는 테스트
  - 단위 테스트에서라면 예외나 에러를 시뮬레이션해볼 수 있고, 통합 테스트나 종단간 테스트에서라면 원격 프로시저 호출(RPC) 오류를 주입하거나 지연시간을 늘려볼 수 있음
  - 카오스 엔지니어링(chaos engineering) 같은 기법을 활용하면 실제 프로덕션 네트워크에 영향을 주는 훨씬 더 큰 중단 사태도 시뮬레이션할 수 있음 
  - 신뢰할 수 있는 시스템이라면 부정적인 조건을 예측하고 대응 방식을 통제할 수 있어야 함
- 코드 커버리지
  - 어느 테스트가 기능 코드의 어느 라인을 실행하는지를 측정하는 수단 
- 모노리포(monorepo) : 여러 프로젝트의 코드를 하나의 리포지터리에서 관리하는 소프트웨어 개발 전략을 말함 

## 단위 테스트
- 크기는 테스트가 소비하는 자원과 수행할 수 있는 작업을 뜻하며, 범위는 테스트가 검증고자 하는 코드의 양을 의미함
- 단위 테스트(unit test) : 단일 클래스나 메서드처럼 범위가 상대적으로 좁은 테스트를 뜻함
- 테스트의 가장 중요한 목적은 버그 예방, 엔지니어의 생산성 개선
- 특성
  - 구글의 테스트 크기 정의에 따르면 단위 테스트는 대체로 작은 테스트에 속함, 작은 테스트는 빠르고 결정적이어서 개발자들이 수시로 수행하며 피드백을 즉각 얻을 수 있음
  - 단위 테스트는 대체로 대상 코드와 동시에 작성할 수 있을 만큼 작성하기 쉬움, 따라서 엔지니어들은 커다란 시스템을 설정하거나 이해할 필요 없이 작성 중인 코드를 검증하는 데 집중할 수 있음 
  - 빠르게 작성할 수 있으므로 테스트 커버리지를 높이기 좋음, 커버리지가 높다면 엔지니어들은 기존 동작을 망가뜨리지 않으리라는 확신 속에서 코드를 변경할 수 있음
  - 각각의 테스트는 개념적으로 간단하고 시스템의 특정 부분에 집중하므로 실패 시 원인을 파악하기 쉬움
  - 대상 시스템의 사용법과 의도한 동작 방식을 알려주는 문서자료 혹은 예제 코드 역할을 해줌 
- 유지보수하기 쉬운 테스트는 그냥 작동하는(just work) 테스트를 말함, 한 번 작성해두면 실패하지 않는 한 엔지니어가 신경 쓸 필요 없고, 혹 실패한다면 원인을 바로 알 수 있는 진짜 버그를 찾았다는 뜻
- 깨지기 쉬운 테스트 예방하기
  - 실제로는 버그가 없음에도, 심지어 검증 대상 코드와는 관련조차 없는 변경 때문에 실패하는 테스트를 말함 
  - 불규칙한 테스트(flaky test) : 대상 코드에 아무런 변경이 없음에도 무작위로 실패함 
- 변하지 않는 테스트를 만들기 위해 노력하자
  - 순수 리팩터링 : 성능 최적화, 코드 가독성 개선 등이 속함, 테스트의 역할은 리팩터링 후에도 시스템의 행위가 달라지지 않았음을 보장하는 것
  - 새로운 기능 추가 : 새로운 기능이나 행위를 추가할 때는 기존 행위들에 영향을 주지 않아야 함
  - 버그 수정 : 새로운 기능 추가와 비슷함
  - 행위 변경 : 시스템의 기존 행위를 변경하는 경우로, 기존 테스트 역시 변경되어야 함
  - 리팩터링, 새 기능 추가, 버그 수정 시에는 기존 테스트를 손볼 일이 없어야 한다는 것, 시스템을 확장할 때는 기존 테스트들을 일일이 손보는 게 아니라 확장한 부분과 관련된 소수의 테스트만 새로 작성하면 됨 
- 상호작용이 아니라 상태를 테스트하자
  - 상태 테스트(state test) : 메서드 호출 후 시스템 자체를 관찰함
  - 상호작용 테스트(interaction test) : 호출을 처리하는 과정에서 시스템이 다른 모듈(시스템)들과 협력하여 기대한 일련의 동작을 수행하는지를 확인함 
- 명확한 테스트 작성하기
  - 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트를 말함 
- 완전하고 간결하게 만들자
  - 완전한 테스트(complete test) : 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 담고 있는 테스트를 말함 
  - 간결한 테스트(concise test) : 코드가 산만하지 않고, 관련 없는 정보는 포함하지 않은 테스트 
- 공유 셋업
  - 셋업(setup) 메서드 : 많은 테스트 프레임워크가 하나의 테스트 스위트에 속한 테스트 각각을 수행하기 직전에 실행되는 메서드를 정의할 수 있게 해줌 

## 테스트 대역
- 테스트 대역(test double) : 실제 구현 대신 사용할 수 있는 객체나 함수를 말함 
- 목(mock)은 테스트 대역 중 한 형태인 모의 객체를 저장할 때도 쓰기 때문 
- 테스트 대역이 소프트웨어 개발에 미치는 영향
  - 테스트 용이성(testability)
    - 테스트 대역을 사용하려면 코드베이스가 테스트하기 쉽도록 설계되어 있어야 함 
  - 적용 가능성(applicability)
    - 테스트 대역을 제대로 활용하면 엔지니어링 속도가 크게 개선되겠지만, 잘못 사용하면 오히려 깨지기 쉽고 복잡하고 효율도 나쁜 테스트로 전락함
  - 충실성(fidelity)
    - 테스트 대역이 실제 구현의 행위와 얼마나 유사하냐를 말함
- 효과적인 테스트 대역 사용법을 위한 기본 개념
  - 이어주기(seam)
    - 제품 코드 차원에서 테스트 대역을 활용할 수 있는 길을 터줘서 테스트하기 쉽게끔 만들어주는 걸 뜻함 
    - 프로덕션 환경에서 이용하는 의존 대상을 다른 대상으로 교체할 수 있도록 해주면 됨 
    - 의존성 주입(dependency injection - DI) : 의존성 주입을 활용하는 클래스는 필요한 클래스(의존성)를 내부에서 직접 생성하지 않고 외부에서 건네받음
  - 모의 객체 프레임워크(mocking framework)
    - 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리 
    - 객체를 대역으로 대체할 수 있게 해줌, 모의 객체(mock)는 구체적인 동작 방식을 테스트가 지정할 수 있는 테스트 대역을 말함
- 테스트 대역 활용 기법
  - 속이기(가짜 객체 fake object) : 제품 코드로는 적합하지 않지만 실제 구현과 비슷하게 동작하도록 가볍게 구현한 대역
  - 뭉개기(스텁 stub) : 원래는 없던 행위를 부여하는 과정을 말함
    - 스텁을 이용한 뭉개기는 원래는 없는 행위를 테스트가 함수에 덧씌우는 방법, 테스트에서 실제 구현을 대체할 수 있는 쉽고 빠른 방법
    - 스텁 과용의 위험성
      - 불명확해진다
      - 깨지기 쉬워진다
      - 테스트 효과가 감소한다
  - 상호작용 테스트(interaction test) : 대상 함수를 실제로 호출하지 않고도 그 함수가 어떻게 호출되는지를 검증하는 기법 
    - 상태 테스트(state test) : 대상 시스템을 호출하여 올바른 값을 반환하는지, 혹은 대상 시스템의 상태가 올바르게 변경되었는지를 검증하는 테스트, 상호작용 테스트보다 상태 테스트를 우선하는게 좋음 
    - 상호작용 테스트가 적합한 경우
      - 실제 구현이나 가짜 객체를 이용할 수 없어서(실제 구현은 너무 느리고 가짜 객체는 존재하지 않아서) 상태 테스트가 불가능한 경우
      - 함수 호출 횟수나 호출 순서가 달라지면 기대와 다르게 동작하는 경우 
- 실제 구현
  - 고전적 테스트(classical test) : 실제 구현을 선호하는 테스트 방식
  - 모의 객체 중심주의 테스트(mockist test) : 모의 객체 프레임워크를 선호하는 테스트 방식 
- 결정성
  - 결정적(deterministic) 테스트 : 같은 버전의 시스템을 대상으로 실행하면 언제든 똑같은 결과를 내어주는 테스트, 항상 성공하거나 항상(같은 이유로) 실패해야 한다는 뜻
  - 비결정적(nondeterministic) 테스트 : 대상 시스템은 그대로인데 결과가 달라지는 테스트

## 더 큰 테스트
- 특성
  - 느릴 수 있음
  - 밀폐되지 않을 수 있음, 대규모 테스트는 다른 테스트나 최종 사용자와 자원 및 트래픽을 공유하기도 함 
  - 비결정적일 수 있음, 예컨대 밀폐되지 않은 대규모 테스트라면 다른 테스트나 사용자 상태에 영향을 받을 수 있어서 완벽히 결정적이라고 보장하기가 거의 불가능함 
- 충실성(fidelity)
  - 테스트가 대상의 실제 행위를 얼마나 충실하게 반영했느냐를 나타내는 속성
- 더 큰 테스트를 만들지 않는 이유
  - 높은 신뢰성 : 결과가 불규칙하면 안 되며 유용한 성공/실패 신호를 제공해야 함
  - 빠른 속도 : 개발자 워크플로를 방해하지 않을 정도로 빨라야 함 
  - 높은 확장성 : 구글은 변경되는 코드에 영향을 받는 모든 테스트를 서브밋 직전과 직후에 효율적으로 실행 할 수 있어야 함
- 가능한 한 작은 테스트
  - 연쇄 테스트(chain test) : 여러 개의 내부 시스템이 관여하는 기능을 테스트하면서 테스트 크기를 작게 만드는 좋은 전략 
- 큰 테스트의 구조
  - 테스트 대상 시스템 확보(system under test - SUT)
    - 밀폐성 : SUT는 현재 테스트하려는 기능과 관련 없는 구성요소를 사용하거나 상호작용하지 못해야 함
    - 충실성 : SUT는 테스트 중인 프로덕션 시스템을 충실히 반영해야 함, 충실성이 높은 SUT는 프로덕션 버전과 유사한 바이너리로 구성됨(비슷한 설정, 비슷한 인프라, 비슷한 토폴로지)
  - 필요한 테스트 데이터 준비
  - 대상 시스템을 이용해 동작 수행
  - 행위 검증 
- 테스트 데이터
  - 시드 데이터 : 테스트 개시 시점의 SUT 상태를 반영하여 SUT를 사전 초기화해주는 데이터
  - 테스트 트래픽 : 테스트 수행 과정에서 SUT로 보내는 데이터 
  - 샘플링한 데이터 : 테스트 커버리지를 극대화할 수 있는 최소한의 데이터만 추출해내는 기술을 스마트 샘플링(smart sampling)
- 검증
  - 수동 검증 : 사람이 SUT와 직접 상호작용하며 올바르게 동작하는지 확인하는 걸 말함
  - 단정문 : 단위 테스트처럼, 시스템이 의도된 대로 동작하는지 명확히 검사하는 검증 방식 
  - A/B 비교 : A/B 테스트는 두 별의 SUT를 구동시켜 똑같은 데이터를 보낸 다음 결과를 비교하는 검증 방식 
- 배치 토폴로지(deployment topology) : 다양한 바이너리가 컴퓨터 네트워크에 배치되는 형태 
- 스모크 테스트(smoke test) : 본격적인 테스트에 앞서 테스트를 진행해도 되는 상황인지를 확인해보는 용도의 테스트
- 탐색적 테스트(exploratory testing) : 새로운 사용자 시나리오를 시도해가며 의문스러운 동작을 찾는 수동 테스트
- 퍼즐 테스트(fuzz test) : 정상적이지 않은 혹은 무작위의 데이터를 입력해 수행하는 테스트를 말함 
- 버그 파티 : 관련인 모두가 모여 함께 테스트한다 , 엔지니어는 물론 관련된 모든 사람(관리자, 제품 관리자, 테스트 엔지니어 등 제품에 익숙한 사람이면 누구든)이 모여 제품을 수동으로 테스트함 
- 사용자 인수 테스트(user acceptance testing - UAT)는 공개 API를 통해 제품을 조작하면서 특정 사용자 여정(user journey)이 의도한 대로 이루어지는지를 보장하는 테스트
  - 사용자가 각 단계에서 무엇을 볼 수 있고 무엇을 할 수 있는지에 초점을 두어 특정한 작업을 완수하기까지 과정(workflow)을 거시적으로 기술해줌
- 프로버와 카나리 분석
  - 프로버(Prober : 탐사 장치, 무인 우주 탐사선) : 프로덕션 환경을 대상으로 단정문을 수행하는 기능 테스트
  - 카나리 분석(canary analysis) : 신버전을 프로덕션 환경에 언제 배포할지가 주된 관심사라는 점이 다름, 프로덕션 서비스 중 일부를 새로운 버전(카나리아)으로 조금씩 대체해가면서 신버전과 기존 버전 모두를 대상으로 프로버를 수행함, 전체 시스템 중 일부만 신버전(카나리아)으로 대체하여 혹은 신버전에서 문제가 생기더라도 대다수의 기존 시스템(광부)이 서비스를 무사히 지탱해준다는 점이 비슷함 
- 카오스 엔지니어링(chaos testing) : 시스템에 꾸준히 결함을 심어서 무슨 일이 벌어지는지 관찰하는 테스트 , 시스템이 안정적이고 신뢰할 수 잇다는 담당 팀의 가정을 깨줘서 시스템에 복원력이 갖춰지도록 돕는 것 
- 큰 테스트에서 실패를 잘 처리하는 요령
  - 무엇이 실패했는지 명확히 알려주자
  - 최소한의 노력으로 근본 원인을 찾을 수 있도록 하자
  - 지원 정보 및 연락처 정보를 제공하자 

## 폐기
- 폐기(deprecation) : 이주를 순차적으로 진행하여 궁극적으로는 낡은 시스템을 완전히 걷어내는 과정 
- 폐기 유형
  - 권고 폐기(advisory deprecation) : 기한이 없고 조직에서도 우선순위가 높지 않은(혹은 폐기 작업에 자원을 투입할 의지가 없는) 경우 , 희망 폐기(aspirational deprecation) 
  - 강제 폐기(compulsory deprecation) : 대개 낡은 시스템의 지원 종료일을 못 박는 형태로 이루어짐 
  - 제자리 달리기(running to stay in place) 현상 : 무언가를 열심히 하지만 실제 목적은 현상 유지에 있는 눈속임을 말함 
  - 폐기 경고
    - 사용자에게 전달되는 폐기 경고 메시지에 반드시 담겨야 할 특성 두 가지
      - 실행 가능성(actionability)
        - 해당 문제와 관련한 전문 지식을 갖춘 평균적인 엔지니어가 이론적으로 뿐 아니라 실질적인 조치를 취할 수 있다면 실행 가능한 경고 
      - 적시성(relevance)
        - 폐기 경고가 유용하려면 적시에 떠야함, 사용자가 실제로 관련 동작을 수행할 때 경고가 뜬다면 적절한 때라고 할 수 있음 
- 폐기 도구
  - 발견 : 폐기를 진행하는 내내, 특히 프로세스의 초기 단계에서 낡은 시스템을 누가(by whom) 그리고 어떻게(how) 이용하고 있는지를 알아야 함 
  - 마이그레이션(이주) : 구글에서는 폐기에 필요한 일의 상당 부분을 앞에서 이야기한 코드 생성 및 리뷰 도구들을 활용해 처리함 
  - 퇴행 방지 : 새로 작성하는 코드에서 폐기 중인 대상을 이용하는 걸 퇴행이라 함 
  - 가시성(visibility) : 가시성이란 빌드 시스템에서 각 빌드 타깃이 자신에게 의존할 수 있는 타깃의 범위를 지정하는 속성 

## 버전 관리와 브랜치 관리
- 버전 관리 시스템(Version Control System - VCS) : 가장 널리 쓰이는 소프트웨어 엔지니어링 도구 
- VCS는 파일의 시간에 따른 변경 기록(버전)을 추적하는 시스템, VCS는 파일들의 메타 데이터를 관리하며, 이 메타데이터와 파일들의 버전별 복사본을 합쳐 리포지터리(repository, 줄여서 리포 repo)라고 함, VCS를 이용하면 여러 개발자가 같은 파일들로 동시에 작업할 수 있어서 팀 업무를 효과적으로 조율할 수 있음 
- 중앙집중형 VCS(Centralized VCS)
  - 단 하나의 중앙 리포지터리를 이용하는 모델(조직 내 공유 컴퓨트 자원을 이용할 가능성이 큼), 개발자들은 각 파일을 체크아웃하여 로컬 컴퓨터에서 이용할 수 있음, 하지만 이 파일들의 버전 관리 상태와 관련한 작업들(파일 추가, 동기화, 기존 파일 갱신 등)은 반드시 중앙 서버에 전달해야 함, 개별 개발자가 커밋하는 모든 코드는 결국 중앙 리포지터리로 커밋됨
  - RCS와 같은 초기 VCS들은 동시 편집을 막아주는 락킹에 집중함
- 분산형 VCS(Distributed Version Control System - DVCS)
  - 깃과 머큐리얼(Mercurial)
  - 분산형 VCS 작업 프로세스
    - 기본 리포지터리를 로컬에 복제함
    - 파일을 변경함
    - 로컬 리포지터리에 커밋함
    - 2~3을 워하는 만큼 반복함
    - 로컬에 적용된 커밋 중 일부를 혹은 전체를 다른 리포지터리로 커밋함, 이때 다른 리포지터리는 1에서 복제해온 리포지터리일 수도, 아닐 수도 있음
  - 대부분의 분산형 VCS 프로젝트가 단 하나의 진실 공급원을 개념적으로 정의하고 진행함(예컨대 깃허브상의 특정 리포지터리를 공급원으로 삼음)
- 브랜치 관리
  - 개발 브랜치(dev branch)
    - 구현은 다 했지만 커밋하진 않았어요와 이제부터 이 코드를 기준으로 개발하세요의 중간 단계
  - 릴리스 브랜치
    - 제품의 릴리스 간격(혹은 릴리스 수명)이 몇 시간 이상이면 릴리스 브랜치를 따로 생성하는 게 좋음, 릴리스한 제품과 정확히 같은 코드를 담게 됨, 공식 릴리스 후 다음 릴리스 전에 심각한 결함이 발견된다면 트렁크에서 해당 수정 코드를 최소한으로 선별하여 릴리스 브랜치로 병합함
- 원-버전 
  - 어느 리포지터리의 어느 브랜치가 진실 공급원인지를 개발자가 명확히 알도록 한다는 단일 진실 공급원 개념을 확장한 개념
  - 구체적으로는 모든 의존성이 우리 리포지터리에 담겨 있고 각 의존성은 단 하나의 안정된 버전만 존재해야 한다라는 뜻 
  - 원-버전 규칙은 조직의 효율에 지대한 영향을 줌, 어디에 커밋할지 혹은 어느 걸 사용할지 선택할 일을 없애면 일이 기가 막히게 단순해짐
- 셰이딩(shading) : 자바 업계에서 많이 사용, 라이브러리의 내부 의존성들(클래스, 함수 등)의 이름을 변경해주는 기술 
- 초크포인트(chokepoint) : 결과를 좌우하는 결정적인 요건, 전략상 중요한 길목(요충지)을 뜻함
- 모노리포(단일 리포지터리) : 개인정보, 법준수, 비밀유지, 보안 등의 요구사항이 모든 프로젝트에 동일하게 적용되는 조직이라면 진정한 모노리포가 좋음 
- 자동 버전 범핑(version bumping) : 프로그램의 버전을 새로운 고윳값으로 증가시키는 기능을 말함
- 앞으로 업데이트할 일 없는 개인 토이 프로젝트가 아니라면 소프트웨어 개발 프로젝트에서는 무조건 버전 관리 시스템을 이용

## Code Search
- 구글이 이용하는 코드 브라우징 및 검색도구로, 프런트엔드 UI와 다양한 백엔드 요소로 이루어져 있음 
- Code Search (예상) 질문에 답해주기
  - 이 심볼은 어디에 정의되어 있나요?
  - 이건 어디서 사용되죠?
  - 이 심볼은 어떻게 인클루드하죠?
  - 이 코드는 언제 코드베이스에 추가된 거죠?
  - 전체적으로 CPU 사이클을 얼마나 소모하나요?
- Code Search는 다른 도구들의 기반을 제공하며, 모든 문서자료와 개발자 도구가 참조하는 중앙의 표준 저장소라는 가치를 추가로 제공함 

## 빌드 시스템과 빌드 철학
- 기본적으로 모든 빌드시스템의 목적은 단순함, 엔지니어들이 작성한 소스 코드를 기계가 읽을 수 있는 바이너리로 변환하는 것
  - 속도 : 개발자가 명령 하나로 빌드를 수행하고 몇 초 안에 결과 바이너리를 얻을 수 있어야 함 
  - 정확성 : 소스 파일과 기타 입력 데이터가 같다면 모든 개발자가 어떤 컴퓨터에서 빌드하더라도 항상 동일한 결과를 내어줘야 함 
- 모던 빌드 시스템
  - 작업 사이의 의존성(릴리스가 완료됐다고 표시하기 전에 문서자료 업로드 하기)
  - 아티팩트(artifact : 산출물) 사이의 의존성 (내 코드를 빌드하려면 최신 컴퓨터 비전 라이브러리가 필요함)
  - 자기 코드베이스에서의 내부 의존성, 다른 팀이 소유한 혹은 다른 조직이나 서드파티가 소유한 코드나 데이터로의 외부 의존성 등 다양함
- 태스크 기반 빌드 시스템(task-based build system)
  - 기본 작업 단위는 당연히 태스크, 각 태스크는 어떠한 로직을 수행할 수 있는 일종의 스크립트이며 다른 태스크와의 의존 관계를 명시하여 반드시 먼저 수행되도록 할 수 있음
  - 태스크 기반 빌드 시스템의 어두운 면
    - 빌드 단계들을 병렬로 실행하기 어렵다
    - 증분 빌드를 수행하기 어렵다
      - 좋은 빌드 시스템은 작은 변경으로 전체 코드베이스를 처음부터 다시 빌드하지 않도록 증분 빌드(incremental build)를 수행해줌, 증분 빌드는 빌드 시스템이 느리고 앞서의 이유들로 빌드 단계들을 병렬로 진행할 수 없을 때 특히 중요함 
    - 스크립트를 유지보수하고 디버깅하기 어렵다 
- 분산 빌드(distributed build) : 단위 작업들을 여러 컴퓨터에 뿌려 빌드한 후 취합해 최종 결과를 만들어주는 기술 
- 원격 실행(remote execution) : 빌드를 하는 실제 작업들을 여러 워커(worker)에 나눠 수행하는 기술 
- 자기 기술(self-descriptive) : 데이터 자체뿐 아니라 데이터의 형태와 의미를 설명하는 메타데이터까지를 모두 포함하여 스스로를 완벽하게 설명해준다는 뜻 
- 의존성 관리
  - 내부 의존성 
    - 큰 프로젝트를 작은 모듈들로 나누면 의존성 대부분이 내부 모듈 사이에서 만들어짐, 의존하는 타깃 대부분이 같은 소스 리포지터리에서 정의되고 빌드됨
    - 하나의 타깃과 그 타깃이 만들어내는 모든 내부 의존성은 언제나 같은 커밋/리비전에서 빌드됨 
  - 외부 의존성
    - 의존 대상이 내부에 있지 않다면 당연히 외부의 것을 이용해야 함
    - 빌드 시스템 바깥에서 빌드되고 저장되어 있는 아티팩트를 말함, 소스 코드로부터 빌드하는 대신(일반적으로 인터넷을 통해 접근하는) 아티팩트 리포지터리(artifact repository)에서 직접 가져와 그대로 이용함 
- 벤더링(vendoring) : 외부 의존성을 자신의 관리 하에 두는 것

## Critique : 구글의 코드 리뷰 도구
- 코드 리뷰에 가장 필요한 기능, 즉 리뷰어와 잣ㄱ성자에게 코드 리뷰용 화면과 댓글 기능을 제공함, 변경에 점수를 매김으로써 코드베이스에 체크인할 코드를 선별하는 게이트키핑도 지원함
- 리뷰 과정에서 오고 간 기술적 결정과 그 근거를 코드 주석에 기록하지 않았더라도 추적할 수 있음 
- 코드 리뷰 도구 원칙
  - 간결성 
    - UI는 불필요한 선택을 줄여 코드 리뷰를 쉽게 진행할 수 있는 매끄러운 인터페이스를 제공함
    - 빠르게 로드되고 내비게이션이 쉽고 단축키도 지원함, 리뷰 현황을 한눈에 알 수 있도록 시각적으로 표시해줌 
  - 신뢰 제공 : 코드 리뷰는 다른 이의 일을 늦추는 일을 늦추는게 아니라 힘을 보태주는 활동
  - 익숙한 소통 방식 : 변경에 대한 의견을 사용자가 익숙한 방법으로 제시할 수 있도록 함 
  - 워크플로 통합 : 다른 핵심 소프트웨어 개발 도구들에 통합할 수 있는 통합 포인트를 다양하게 제공함 
- 코드 리뷰 흐름
  - 1. 변경 생성
    - 사용자(작성자)가 개인 작업 공간의 코드베이스에 변경을 생성함
  - 2. 리뷰 요청
    - 디프(diff : 변경으로 인해 달라질 코드)와 코드 분석 결과를 보여줌, 작성자가 확인하고 만족한다면 한 명 이상의 리뷰어에게 리뷰 요청 매일을 보냄
  - 3. 댓글 달기
    - 리뷰어들은 Critique에서 변경 사항을 열어보고 디프에 댓글 초안(draft)을 작성함
  - 4. 변경 수정 및 댓글에 답하기
    - 작성자가 피드백을 확인하여 변경을 수정하고 새로운 스냅샷을 업로드하면 리뷰어들에게 답변이 전달됨 
  - 5. 변경 승인
    - 리뷰어가 변경의 최신 모습이 맘에 들면 변경을 승인하고 좋아 보임(looks good to me - LGTM) 이라고 표시함
  - 6. 변경 커밋 
    - 변경이 승인되었음을 Critique이 알려주면 (잠시 후 다시 이야기함) 작성자가 커밋 프로세스를 시작할 수 있음 

## 정적 분석
- 정적 분석(static analysis)은 프로그램을 실행하지 않은 채로 소스 코드를 분석하여 버그나 안티패턴등의 잠재적인 문제를 찾아내는 것을 말함, 정적이라는 단어가 프로그램을 실행하지 않고 소스 코드를 분석한다는 의미(프로그램을 실행하여 분석하는 건 동적 분석(dynamic analysis)
- 정적 분석은 코드베이스를 개선하고 버그를 조기에 발견해줌, 나아가 코드 리뷰와 테스트처럼 비용이 더 많이 드는 활동에서는 기계적으로 검증할 수 없는 문제에 집중하도록 해주는 훌륭한 도구 
- 정적 분석을 적용하며 깨우친 핵심 교훈
  - 개발자 행복에 집중하자.
    - 거짓 음성(false negative)은 분석 도구가 검출하도록 설계된 문제를 놓치는 걸 말함, 거짓 양성은 문제가 없는데 문제를 찾았다고 보고하는 경우 
    - 유효 거짓 양성(effective false positive) : 사용자가 거짓 양성이라고 인식하는 비율, 검출한 문제에 대해 개발자가 긍정적인 조치를 취하지 않는 경우 
  - 정적 분석을 개발자 워크플로에 반드시 끼워 넣자.
  - 사용자가 기여할 수 있도록 하자.
- 프리서브밋 검사(presubmit check) : 작성 중인 변경이 커밋되지 못하게 막는 분석기를 추가할 수 있도록 함 

## 의존성 관리
- 의존성 관리(dependency management) : 우리가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일을 말함 
- 업스트림 의존성들(upstream dependencies) : 내 코드에서 직접 이용하는 의존성을 포함하여 그 의존성이 이용하는 더 상위 의존성들을 통칭함 
- 소프트웨어의 버전을 메이저/마이너/패치 형태로 표현해 의미를 부여하는 관행 자체만을 말함, {메이저/마이너/패치 형태의 버전 번호 + 해당 체계}까지 포괄한 넓은 의미로 이해함 
- 유의적 버전(SemVer - semantic versioning) 
  - 메이저 : API가 변경되어 의존성을 이용하던 기존 코드를 깨드릴 수 있음
  - 마이너 : 순수하게 기능 추가만 있음(기존 코드를 깨드리지 않음)
  - 패치(API에 영향을 주지 않는 내부 구현 개선과 버그 수정) 
- 하이럼의 법칙 : 사용자 수가 충분히 많아지면 시스템이 약속하지 않았더라도 관찰 가능한 모든 행위에 누군가는 의존하게 된다 
- 담벼락 너머로 던지기(throw over the wall) : 내던지듯 넘긴 후 더는 책임지지 않는 개발 방식을 말함, 안티패턴의 하나 

## 대규모 변경(LSC - Large-scale change)
- LSC로 인해 생성되는 변경들
  - 코드베이스 전반을 훑는 분석 도구로 찾은 공통 안티패턴 청소
  - 폐기 대상 API 호출 대체
  - (컴파일러 업그레이드 등) 저수준 인프라 개선사항 활성화
  - 사용자들을 옛 시스템에서 새로운 시스템으로 마이그레이션 
- 명확성, 최적화, 미래 호환성 개선이 목표 
- 유령의 묘지(haunted graveyard) : 너무 오래되고 둔하고 복잡해서 아무도 손대려 하지 않는 시스템을 뜻함
- 변경 관리
  - 대규모 변경 인프라에서 가장 중요한 도구는 마스터 변경을 여러 개의 샤드로 나눈 후 테스트, 메일링, 리뷰, 커밋 단계를 독립적으로 관리해주는 도구 
- 대규모 변경 프로세스
  - 권한 부여
    - 간단한 제안 문서 작성 요청
      - 변경을 제안하는 이유
      - 코드베이스 전반에 주는 예상 영향(예: 제안한 LSC로 인해 생성되는 작은 샤드 수)
      - 리뷰어들이 던질만한 질문과 그에 대한 답변 
    - 이 절차는 해당 변경과 관련한 기반 지식이 부족한 사람들에게 변경을 어떻게 설명할지를 다시 한번 생각해보게 하는 효과가 있음, 작성자는 또한 리팩터링될 API들의 소유자들로부터 도메인 리뷰도 받아야 함 
  - 변경 생성
    - 샤드로 분할한 후 여러 사람이 나눠 생성할 수도 있게 했음, 훨씬 노동 집약적이지만 시급한 애플리케이션을 위해 전역 변경을 더 빠르게 진행할 수 있음 
  - 샤드 관리
    - Rosie는 거대한 변경을 하거나 입력받아서 서브밋할 수 있는 작은 변경(샤드)들로 쪼개줌, 프로젝트 경계와 소유권 규칙을 참고함. 그런 다음 개별 샤드를 독립된 테스트-메일-서브밋 파이프라인에 태움 
    - 테스트 하기
    - 리뷰어에게 메일 보내기 : Roise는 테스트를 수행하여 변경이 안전하다고 검증한 다음 적절한 리뷰어에게 메일을 보냄 
    - 리뷰하기 : Rosie가 생성한 변경들로 표준 코드 리뷰 프로세스를 거쳐야 함 
    - 서브밋 하기
      - 개별 변경을 커밋함
      - 변경을 리포지터리로 실제 커밋하기 전에는 다양한 프로젝트별 프리커밋 검사가 진행됨
      - Rosie 덕에 구글은 매일 수천 개의 변경을 생성, 테스트, 리뷰, 서브밋할 수 있고, 각 팀은 자신의 사용자들을 효과적으로 마이그레이션시킬 수 있음 
  - 마무리 청소 
- 과거에는 한 번 결정하면 되돌릴 수 없던 설계를 LSC 덕분에 필요하면 사후에 변경할 수 있게 되었음, 설계 시 새로운 가능성을 열어준 것, 핵심 인프라 메인테이너들은 구글 코드베이스의 많은 부분을 새로운 시스템, 언어 버전, 라이브러리 이디엄으로 마이그레이션할 수 있는 능력을 얻었음

## 지속적 통합(continuous integration - CI)
- 팀원들이 작업 결과를 자주 통합하는 소프트웨어 개발 방식이다. 통합할 때마다 자동 빌드(테스트 포함)하여 통합 오류를 빠르게 찾아낸다
- 빠르게 진화하는 복잡한 생태계 전체를 지속적으로 조립하고 테스트하는 개발 방식
- CI의 기본 목적은 문제를 일으키는 변경을 가능한 한 조기에 자동으로 발견해내는 것 
- 테스트라는 시각에서 CI
  - 코드(와 다른 요소)가 변경되어 지속적으로 통합되는 개발/릴리스 워크플로에서 무슨(what) 테스트를 언제(when) 실행해야 하는가?
  - 워크플로의 각 테스트 지점에서 (적절한 충실성을 갖춘) 테스트 대상 시스템(SUT)을 (합리적인 비용으로) 어떻게(how)구성해야 하는가?
- 핵심 개념 
  - 빠른 피드백 루프(fast feedback loop)
    - 코드 변경의 생애 : 편집/컴파일/디버그 -> 프리서브밋 -> 포스트서브밋 -> 릴리스후보(RC) -> RC 승격(스테이징 등 임시 환경) -> 최종 RC 승격(프로덕션)
    - CI는 빠른 피드백 루프를 이용하도록 유도하여 버그 비용을 최소로 줄여줌
    - 대표적인 형태들을 피드백이 빠른 순서
      - 로컬 개발 시의 편집-컴파일-디버그 루프
      - 프리서브밋 시 변경 작성자에게 주어지는 자동 테스트 결과
      - 두 프로젝트를 변경한 후 통합 시 오류. 양쪽 변경들을 서브밋한 다음 함께 테스트할 때 발견(예: 포스트서브밋)
      - 내 프로젝트와 업스트림 마이크로서비스 의존성 사이의 호환성 충돌. 업스트림 서비스의 최신 변경이 스테이징 환경에 배포될 때 QA 엔지니어가 발견 
      - 기능을 먼저 이용해본 사내 이용자의 버그 리포트
      - 외부 고객 혹은 언론 매체의 버그 리포트 (혹은 서비스 장애 리포트)
    - 버전 왜곡(version skew) : 분산 시스템에 호환되지 않는 여러 코드, 데이터, 설정 정보(configuration)가 공존하는 상태를 말함 
    - 실험(experiment)과 기능 플래그(feature flag)도 매우 강력한 피드백 루프
- 자동화
  - 지속적 빌드(continuous build - CB)
    - 가장 최근의 코드 변경을 헤드 (트렁크)에 통합한 다음 자동으로 빌드와 테스트를 수행함
      - 헤드(head)는 구글 모노리포에서 가장 최신 버전의 코드를 뜻함 
      - 다른 버전 관리 시스템에서는 트렁크(trunk), 메인(main), 메인라인(mainline)이라고도 함, 항상 헤드로 통합하는 개발 방식을 트렁크 기반 개발 
    - 참 헤드(true head)는 최신 변경이 커밋된 버전
    - 녹색 헤드(green head)는 CB가 검증한 최신 변경을 뜻함
  - 지속적 배포(continuous delivery - CD)
    - 지속해서 릴리스 후보를 조합한 다음 다양한 환경에 차례로 승격시켜 테스트하는 활동. 프로덕션까지 승격시키는 경우도 있고 그렇지 않은 경우도 있음
    - 첫 번째 단계는 릴리스 자동화, 헤드로부터 지속해서 최신 코드와 설정 정보를 가져와서 릴리스 후보를 만들어내는 작업
      - 릴리스 후보(release candidate - RC) : 자동화된 프로세스가 만든, 서로 밀접하게 관련된 요소들로 구서된 배포 가능한 단위, 지속적 빌드를 통과한 코드, 설정 정보, 기타 의존성들을 조합해 만듬 
- 지속적 테스트(continuous testing - CT)
  - 무슨(what) 테스트를 언제(when)실행할지를 정하는게 CI의 주된 목표
  - 프리서브밋만으로 부족한 이유
    - 프리서브밋 때 모든 테스트를 다 돌려보지 않는 이유 
      - 가장 큰 이유는 비용
      - 코드를 서브밋할 때마다 테스트 때문에 한참을 기다려야 한다면 생산성이 심각하게 떨어짐 
      - 불안정하거나 비결정적인 테스트가 끼어들어서 엔지니어가 다음 일을 진행하지 못하게 돼도 손해가 막심함
      - 프리서브밋 테스트가 수행되는 동안에도 리포지터리는 계속 수정될 수 있어서 장시간 열심히 테스트한 변경과 이미 호환되지 않게 달라져 있을 가능성도 있음
      - 공중 충돌(mid-air collision) : 전혀 다른 파일들을 건드리는 다른 변경 때문에 나의 테스트가 실패하는 일이 실제로도 일어남 
  - 릴리스 후보 테스트
    - 온전성 검사 : 코드를 잘라와 RC용으로 다시 컴파일할 때 예상치 못한 일이 발생하지 않았는지를 재차 확인함
    - 검사 용이성 : RC의 테스트 결과를 확인하려는 엔지니어가 지속적 빌드 로그를 파헤쳐보지 않고도 해당 RC와 관련된 결과를 바로 살펴볼수 있음
    - 체리픽 허용 : RC에 체리픽(cherry pick) 수정을 반영한다면 지속적 빌드가 테스트한 코드와 달라짐
    - 비상 배포 : 비상 상황 발생 시, 지속적 배포는 참 헤드의 코드를 잘라와서 (지속적 빌드 전체가 다시 통과될 때까지 기다리지 않고) 배포를 해도 괜찮겠다는 마음의 안정을 가져다주는 데 꼭 필요한 최소한의 테스트만 실행할 수 있음
- CI의 과제 
  - 프리서브밋 최적화 : 앞서 언급한 잠재적인 문제를 고려하여 프리서브밋 시 어떤(which) 테스트를 어떻게(how) 수행해야 할까요?
  - 범인 찾기(culprit)와 실패 격리(failure isolation) : 문제를 일으킨 코드(또는 기타 변경)가 어느 것이고, 어느 시스템에서 문제가 발생했을까요?
  - 자원 제약 : 테스트를 실행하려면 자원이 있어야 하고, 거대한 테스트는 엄청난 자원을 소비함, 또한 프로세스 단계마다 자동화 테스트를 수행하는 데 필요한 인프라 비용도 상당할 수 있음
  - 실패 관리(failure management) : 테스트 실패 시 어떻게 대응해야 하는가를 말함 
- 밀폐 테스트(hermetic test) : 모든 것을 갖춘 테스트 환경에서 수행하는 테스트 
  - 우수한 결정성(determinism , 예 안정성) 과 격리(isolation)
- 빌드 경찰
  - 담당 프로젝트의 테스트를 모두 통과시키는 일을 책임짐
  - 테스트 실패를 목격하는 즉시 하던 일을 멈추고 빌드를 고쳐야 함, 일반적으로 문제를 일으킨 변경을 찾아내어 롤백할지 패치할지를 결정함, 패치는 대체로 위험이 커서 롤백을 권장함 
