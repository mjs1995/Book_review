# 서평
- 이 책은 소프트웨어 조직이 설계, 아키텍처 잡기, 코드 작성 시 명심해야 한다고 믿는 세 가지 기본 원칙을 강조고 있습니다. 코드가 수명을 다할 때까지 새로운 요구사항에 잘 적응하려면 어떻게 해야하는가?에 대한 시관과 변경, 커져가는 규모에 발맞춰 조직은 어떻게 진화해야 하는가?에 대한 규모와 성장, 시간과 변경, 규모와 성장에서 얻은 교훈들을 바탕으로 조직은 어떻게 의사결정을 내려야 하는가?에 대한 트레이드 오프와 비용이 해당됩니다.
- 이 책은 구글이 소프트웨어 엔지니어링을 바라보는 주된 시각에 따라 3가지의 주제로 나누어 설명을 하고 있습니다. 
  - 첫 번째로는 문화로 구글의 문화는 독특하지만 구글이 엔지니어링 문화를 발전시키며 깨우친 교훈들은 폭넓게 적용시키며 소프트웨어 개발은 팀에 의해 이루어지므로 조직이 성장하고 건실하게 유지되려면 개발 문화 면에서도 올바른 원칙이 꼭 필요하다는 점은 강조하고 있습니다.
  - 두 번째로는 프로세스로 구글이 버텨낸 시간과 규모에서 효과적으로 작동한 프로세스들을 소개하고, 아직 시원한 답을 찾지 못한 영역도 이야기하고 있습니다.
  - 세 번째로는 도구로 끊임없이 커져가고 나이를 먹는 코드베이스를 말끔하게 관리하기 위해 구글이 도구 인프라를 어떻게 투자해왔는지를 이야기합니다. 
- 이 책은 조직 혹은 개별 프로그래머를 위한 정책,모범 사례를 평가하고 정의하는 방법, 관리 가능한 소프트웨어어로 만들어주는 도구와 기술 관련 모든 주제를 다루고 있습니다. 

# 전제
- 시간 위를 걷는 프로그래밍
  - 소프트웨어 엔지니어링은 단순히 코드를 작성하는 행위에 더하여, 시간의 흐름에 발맞춰 한 조직이 그 코드를 유지보수하는 데 이용하는 모든 도구와 프로세스를 포괄함
  - 소프트웨어 엔지니어링이란 흐르는 시간 위에서 순간순간의 프로그래밍을 모두 합산한 것(programming integrated over time)라는 관점 

## 소프트웨어 엔지니어링
- 프로그래밍과 소프트웨어의 엔지니어링의 가장 큰 차이는 시간, (규모) 확장, 실전에서의 트레이드오프
- 소프트웨어 엔지니어링 프로젝트에서 엔지니어는 시간의 흐름과 언젠가 변경될 가능성에 더 신경 써야 함, 소프트웨어 엔지니어링 조직은 만들어낼 소프트웨어 자체뿐 아니라 제작하는 조직까지 양 측면 모두에서의 확장과 효율에 더 집중해야 함, 소프트웨어 엔지니어는 대체로 수명과 성장 속도를 정밀하게 예측하기 어려운 상황에서 결과에 더 큰 영향을 주는 보다 복잡한 결정을 내려야 함
- 프로그래밍 작업(개발development)과 소프트웨어 엔지니어링 작업(개발 + 수정modification + 유지보수maintenance)의 차이도 궁금할 것
- 코드의 예상 수명 : 단순한 구동 수명(execution lifetime)이 아니라 유지보수 수명을 말함, 이 코드가 언제까지 개발, 구동, 유지보수 될 것인지, 혹은 이 소프트웨어의 가치가 언제까지 유효할지를 묻는 질문
- 하이럼의 법칙(Hyrum's Law) : API 사용자가 충분히 많다면 API 명세에 적힌 내용은 중요하지 않음, 시스템에서 눈에 보이는 모든 행위(동작)를 누군가는 이용하게 될 것이기 때문 
- 해시 플러딩(hash flooding) : 서비스 거부 공격(Denial-of-Service,DoS)의 하나로, 해시 테이블과 해시 함수의 구조를 아는 사용자가 일부러 해시 테이블을 느려지도록 구성한 데이터를 제공하는 공격 
- 비욘세 규칙(The Beyonce Rule) : 코드를 짰으면 자기 코드에 대한 테스트도 자기가 제대로 만들었야지 라는 뜻 
- 자동화(한 사람이 더 많은 일을 수행), 통합과 일관성(저수준 변경이 영향을 미치는 범위 제한), 전문성(적은 인원으로 더 많은 일을 수행)
- 코드베이스의 유연성에 영향을 주는 여러 요인
  - 전문성(expertise) : 여러 방법에 대한 충분한 지식
  - 안전성(stability) : 더 규칙적으로 릴리스하여 릴리스 사이의 변경량을 줄였음
  - 순응(conformity) : 업그레이드를 겪지 않은 코드가 많지 않음, 규칙적인 업그레이드가 도움이 됨 
  - 익숙함(familiarity) : 업그레이드를 정기적으로 수행하기 때문에 그 과정에서 중복되는 작업ㅇ르 찾고 자동화하려고 노력함
  - 정책(policy) : 비욘세 규칙과 같은 유용한 정책과 절차를 갖춤 
- 원점 회귀(왼쪽으로 옮기기)
  - 개발자 워크플로를 시간순으로 생각 - 개념잡기와 설계에서 시작하여 구현, 리뷰, 테스트, 커밋, 카나리를 거쳐 최종적으로 프로덕션 환경에 배포
    - 카나리(canary) : 변경 사항을 소수의 사용자 집단(주로 사내 이용자)에만 배포하여 검증하는 테스트를 말함, 베타 테스트와 달리 사용자에게 서비스가 변경되었음을 통지하지 않고 진행함 
  - 원점 회귀(shift left) : 보안성 점검을 개발 프로세스의 마지막으로 연기하면 안 된다고 호소하며 보안을 고려하는 시점을 왼쪽으로 이동시켜라(shift left on security)라고 한 말에서 유래함 
- 트레이드오프와 비용
  - 에스컬레이션 경로(escalation path) : 실무 담당자로부터 최종 결정권자까지 계층적인 의사결정권자의 목록을 말함, 결재 라인이라고 생각해됨
  - 비용, 투입된 노력과 다음의 요소들까지 모두 포괄함
    - 금융 비용(돈)
    - 리소스 비용(CPU 시간)
    - 인적 비용(엔지니어링 노력)
    - 거래 비용(조치를 취하는 비용)
    - 기회 비용(조치를 취하지 않는 비용)
    - 사회적 비용(선택이 사회 전체에 미치는 영향)
    - 현상 유지 편향(status quo bias)과 손실 회피(loss aversion)같은 치우침(bias)도 존재함 
- 엔지니어링 조직의 선택을 결정짓는 요인
  - 반드시 해야 하는 일(법적 요구사항, 고객 요구사항)
  - 근거에 기반하여 당시 내릴 수 있는 최선의 선택(적절한 결정권자가 확정)
- 의사결정을 위한 근거 자료
  - 관련한 정략적 데이터를 모두 측정할 수 있거나 최소한 추정이라도 할 수 있는 경우
  - 측정하기 어렵거나 측정 방법을 모르는 정략적 데이터 존재 

# 문화
## 팀워크 이끌어내기 
- 버스 지수(bus factor)
    - 몇 명의 팀원이 버스에 치여서 일을 할 수 없게 될 때 프로젝트가 망하게 되는지를 나타내는 지수 
    - 혼자 일하게 되면 버스 지수 외에 전반적인 진행 속도에도 해로움, 혼자 일한다는 것은 고된 싸움이며 사람들의 기대보다 훨씬 느리다는 점을 잊기 쉬움 
    - 다른 이들과 함께 어울려 일하면 개인의 노력만으로는 깨우치기 어려운 공동의 지혜라는 이점을 얻을 수 있음 
- 모든 건 팀에 달렸다
  - 다른 사람과 함께 일해야 함, 비전을 공유하세요, 역할을 나누세요, 다른 이로부터 배우세요, 멋진 팀을 만드세요
- 사회적 상호작용의 세 기둥
  - 겸손(humility)
    - 당신과 당신의 코드는 우주의 중심이 아님, 당신은 모든 것을 알지도, 완벽하지도 않습니다. 겸손한 사람은 배움에 열려 있습니다.
  - 존중(respect)
    - 함께 일하는 동료를 진심으로 생각합니다. 친절하게 대하고 그들의 능력과 성취에 감사해야함
  - 신뢰(trust)
    - 동료들이 유능하고 올바른 일을 하리라 믿습니다. 필요하면 그들에게 스스로 방향을 정하게 해도 좋습니다.
- 집단적 자존심(collective) : 자신이 잘 아는 분야에 대해 걱정하는 대신 팀의 성취와 단계의 자부심을 높이려 노력하기 
- 빠르게 실패하고 반복하기
  - 실패는 선택이다, 가끔씩 실패하지 않는다면 충분히 혁식적이지 않거나 위험을 충분히 감수하지 않은 것이다.
  - 실패를 배우고 다음 단계로 넘어갈 수 있는 절호의 기회라고 생각하는 것, 동일한 일을 반복해서 실패한다면(즉, 다음 단계로 넘어가지 못한다면) 실패한 게 아니라 무능한 것 
- 비난 없는 포스트모템 문화(postmortem - 프로젝트를 마친 후 전 과정을 되돌아보며 잘된 점과 잘못된 점을 되돌아보는 사후 검토 작업을 말함)
  - 무엇을 배웠는지와 배운 것을 토대로 앞으로 무엇을 바꿀지가 담겨야 함 
  - 사건의 개요
  - 사건을 인지하고 해결에 이르기까지의 타임라인
  - 사건의 근본 원인
  - 영향과 피해 평가
  - 문제를 즉시 해결하기 위한 조치 항목(소유자 명시)
  - 재발 방지를 위한 조치 항목
  - 해당 경험에서 얻은 교훈
- 인내심을 기르자
  - 구덩이에 뛰어들어 많은 것을 빠르게 시도해보고 세부사항은 넘기면서 길을 찾아내는 상향식(bottom-upp)엔지니어
  - 먼저 전체 지형을 파악하고, 필요한 거의 모든 메서드를 구현한 뒤에야 버그 사냥에나서는 하향ㅅ힉(top-down) 엔지니어 
- 구글답게 하기
  - 모호함을 뚫고 번창한다 - 끊임없이 변화하는 환경 속에서도 상충하는 메시지와 방향에 잘 대처하고, 합의를 이끌어내고, 문제에 대한 진전을 이룰 수 있음 
  - 피드백을 소중히 한다 - 피드백을 주고받을 때 품위와 겸손을 유지하고 개인과 팀의 발전에 피드백이 주는 가치를 이해함 
  - 저항(항상성)을 극복한다 - 다른 이들이 저항하거나 관성 때문에 움직이지 않으려 하더라도 야심 찬 목표를 세우고 밀고 나아감
  - 사용자를 우선한다 - 구글 제품의 사용자 입장에서 생각하고 존중하며 그들에게 가장 도움되는 행동을 추구함
  - 팀에 관심을 기울인다 - 동료들의 입장에서 생각하고 존중하며 팀의 결집을 위해 누가 시키지 않더라도 적극적으로 도움 
  - 옳은 일을 한다 - 모든 일에 강한 윤리 의식을 갖고 임함, 팀과 제품의 진정성을 지키기 위해서라면 어렵거나 불편한 결정을 내릴 수 있어야 함 

## 지식 공유
- 배움을 가로막는 장애물
  - 심리적 안전 부족
    - 불이익이 두려워서 스스로 위험을 감수하거나 실수를 드러내기 꺼리는 환경 
  - 정보 섬(information islands)
    - 조직의 각 부서가 서로 소통하거나 자원을 공유하지 않아서 지식이 파편화됨
    - 정보 파편화 : 섬마다 서로 다른 그림을 그리고 그마저도 불완전함
    - 정보 중복 : 섬마다 나름의 작업 방식을 재창조함
    - 정보 왜곡 : 같은 일이라도 섬마다 작업 방식이 다르고, 심지어 충돌하기도 함 
  - 단일 장애점(single point of failure,SPOF)
    - 중요한 정보를 한 사람이 독점하면 병목이 생김, 단기 효율을 높여주는 대신(내가 하는 게 빠르지) 장기 확장성을 희생하는 꼴
  - 전부 아니면 전무 전문성(all-or-nothing expertise)
    - 조직 구성원이 모든 것을 아는 사람과 아무것도 모르는 초심자로 나뉨, 지식과 책임은 계속 이미 전문가가 된 사람들에게 집중되고, 새로운 팀원이나 초심자들은 그들만의 울타리에 갇혀 느리게 성장하게 됨 
  - 앵무새처럼 흉내내기(parroting)
    - 이해하지 못한 상태로 흉내만 내는것을 말함 
  - 유령의 묘지(haunted graveyard)
    - 무언가 잘못될 게 두려워서 아무도 손대지 않는 영역(주로 코드)
- 철학
  - 소프트웨어 엔지니어링을 여러 버전의 프로그램을 여러 사람이 참여해 개발하는 일 
- 내 지식 키우기
  - 질문하기
    - 초심자가 저지르는 가장 큰 실수는 무언가 막혔을 때 질문하지 않는 것, 혼자서 극복해내고 싶다거나 너무 기초적인 질문이란 소리를 듣는게 두려워서 일 수 있음
    - 도움을 청하기 전에 최대한 노력해봐야 해라고 생각할지 모름, 여러분의 동료가 가장 훌륭한 정보 소스일 경우가 많음, 이 귀중한 자원을 충분히 활용하기 
    - 가면 증후군(impostor syndrome) : 사기꾼 신드롬, 자신의 능력보다 과대평가받고 있다고 느껴서, 자칫 실수하면 자신이 사기꾼임을 들킬지 모른다는 두려움을 말함, 걱정하지 말고 모르는 건 바로바로 물어봐야 더 빨리 성장하고 팀에도 더 빨리 녹아들 수 있음 
    - 팀의 리더든 새로운 멤버든 항상 무언가 배울 게 있는 환경에서 살아야 함, 그렇지 않으면 더 이상 성장하지 못할 것(그리고 결국 새로운 환경을 찾아 떠나게 되겠죠), 특히 조직(혹은 팀)의 리더들이 솔선수범해서 이런 문화를 만들어야함 
    - 끈기를 가지고 상냥하게 답변해줘야 사람들이 안심하고 도움을 청하는 환경이 조성됨, 초기의 망설임을 극복하면 분위기를 빠르게 조성할 수 있으니 질문을 하도록 권장하고 사소한 질문이라도 답을 얻을 수 있도록 힘써주기 
  - 맥락 이해하기
    - 무언가를 옮기거나 바꾸려면 그게 왜 그자리에 있는지부터 이해하자라고말하는 체스터슨의 울타리(Chesterson's fence)원칙 
- 질문 확장하기 : 커뮤니티에 묻기
  - 미래의 자신을 위해서라도 무언가를 일대일로 배울 때는 기록하는 습관을 기르기, 여러분보다 나중에 들어오는 동료들도 여러분과 똑같은 질문을 할 가능성이 큼, 기록해둔 지식을 공유하기 
- 지식 확장하기
  - 오피스 아워
    - 때로는 사람과 직접 대화를 해야지만 쉽게 풀리는 문제가 있음
    - 오피스 아워(office hours)가 좋은 해결책이 될 수 있음, 누군가가 특정 주제에 관한 질문에 답해줄 목적으로 시간을 비워 둔 정기적인 이벤트(보통은 매주 똑같은 시간에 진행함)
    - 전문가와의 면담은 문제가 여전히 불명확하여 어떻게 질문해야 할지 모를 때나(가령 새로운 서비스 설계를 막 시작했을 때) 문서화되지 않은 특수한 문제에 맞닥뜨렸을 때 특히 유용함 
  - 기술 강연과 수업
    - 기술 강연(tech talk)과 수업(class), 연사가 청중에게 직접 강의하는 형태로 진행됨
    - 자꾸 오해를 일으킬 정도로 복잡한 주제를 다뤄야 함 
    - 주제가 비교적 안정적이어야 함 
    - 질문에 답해주고 일대일로 도와줄 수 있는 교사가 있어야 효과가 큰 주제여야 함 
    - 수업을 정기적으로 개설해도 될 만큼 수요가 많아야 함 
  - 문서자료 
    - 독자가 무언가를 배울도록 돕는 것을 최우선 목표로 하는 기록된 지식 
    - 문서자료 갱신하기
      - 무언가를 막 배운 순간이 기존 문서자료에서 개선점을 찾기에 가장 좋을 때
    - 새로운 문서자료 작성하기
      - 숙달되면 자신만의 문서자료를 작성하고 기존 문서자료들을 갱신하기, 다른 사람에게 공유하여 여러분이 걸어간 길을 쉽게 따라오도록 하기 
      - 나아가 그 문서자료를 다른이들이 찾기 쉽도록 해주면 금상첨화 
      - 피드백할 방법이 있어야 함 
    - 문서화 촉진하기
      - 문서자료에 담긴 정보는 기본으로 참고해야 할 표준이 됨 
      - 표준을 팀 외부로 확산시킬 수도 있음 
- 조직의 지식 확장하기
  - 표준 정보 소스 구축하기
    - 회사 차원의 중앙집중적 정보 원천(sources of information)으로 전문가의 지식을 표준화하고 전파하는 수단 
  - 개발자 가이드
    - 공식 가이드, 코딩 스타일 가이드, 공식 소프트웨어 엔지니어링 모범 사례, 코드 리뷰 가이드와 테스트 가이드, 금주의 팁(TotW - Tips of the Week)
    - 전문가는 회사 차원의 방침을 개인적으로 설명해주지 않아도 되므로 시간이 절약되고, 배우는 사람은 필요하면 언제든 신뢰 가는 정보를 찾아볼 수 있는 정보 소스가 있음을 알게 됨 
- 가독성 인증 프로세스
  - 모든 변경 목록(CL - changelist)은 가독성 승인을 얻어야 함 
  - 가독성 승인(readability approval)이란 해당 언어의 가독성 자격증(readability certificaition)이 있는 누군가가 해당 CL을 승인했다는 표시 

## 공정 사회를 위한 엔지니어링
- 프로그래밍은 당면한 문제에 집중하여 코드를 생산함, 소프트웨어 엔지니어링은 수십 년 혹은 평생에 걸친 유동적이고 모호한 문제에 대응하기 위해 코드, 도구, 정책, 프로세스 등을 응용하는 더 폭넓은 개념 
- 리크루터는지원자 모집과 초기 인터뷰까지 진행하는 사람을 말하며, 채용 관리자는 최종적으로 도장을 찍는 사람을 뜻함 
- 가치 vs 결과
  - 자신을 솔직하게 바라보고 성찰하자 
  - 모두를 위해 만들지 말자, 모두와 함께 만들자
  - 제품을 이용하기 가장 어려운 이들을 위해 설계하자
  - 가정하지 말고, 시스템 전반의 공정성을 측정하자 

## 팀 이끌기
- 관리자(manager)는 사람을 이끌고 테크 리드(tech lead)는 기술과 관련된 책임을 짐 
- 관리자와 테크 리드
  - 테크 리드 매니저(tech lead manager) : 신생 팀이라면 관리자와 테크 리드 역할을 한 사람이 맡음
  - 엔지니어링 관리자
    - 자신이 관리하는 팀의 구성원 모두 (테크 리드도 포함)의 성과(performance), 생산성(productivity), 행복(happiness)을 책임져야 함 
  - 테크 리드
    - 제품의 기술적인 면, 즉 기술과 관련한 결정과 선택, 아키텍처, 우선순위, 성능과 일반적인 프로젝트 관리를 책임짐
    - 팀 관리자의 직속일 때가 많고, 규모가 큰 팀일 경우엔 별도의 프로그램 관리자(program manager)를 두어 프로젝트 관리를 지원토록 함 
    - 엔지니어링 관리자와 긴밀히 협조하여 맡겨진 제품을 개발하는 데 필요한 팀원을 확보하고 엔지니어들의 기술 스펙트럼과 기술 수준을 최대한 활용해 목표를 완수하게끔 이끌어야 함 
  - 테크 리드 매니저
    - TLM은 인적,기술적 요구를 혼자 관장하는 사람 
    - 구글에서는 규ㅜ모가 크고 잘 조직된 팀이라면 테크 리드와 엔지니어링 매니저를 각 1명씩, 총 두명이 이끄는 것이 통례
    - 자신의 일, 위임, 사람 관리 사이에서 균형을 잡는 요령을 배워야함 
- 개인 기여자에서 리더로
  - 두려워해야 할 건 오직... 전부다
    - 사람들 대부분이 관리자라는 단어를 불쾌해 함, 소프트웨어 개발 분야에서 가장 큰 이유는 바로 코딩할 시간이 크게 줄어든다는 점 
    - 경력 대부분을 코딩하며 보낸 사람이라면 하루의 끝에서 작성한 코드, 설계 문서, 해결한 버그 더미 등을 가리키며 이게 오늘 내가 한 일이야라고 외칠 수 있음, 하지만 관리 일로 바삐 보낸 하루의 끝에서는 오늘 한 일이 하나도 없군이라고 생각하게 되는 경우가 허다함 
    - 피터의 법칙 : 위계 조직에서 직원들은 자신의 무능력이 드러나는 직급까지 승진하는 경향이 있음
      - 주어진 위치에서 뛰어난 성과를 내는 직원은 승진을 거듭하다가 더는 성과를 낼 수 없는 위치까지 올라선 후 멈추게 됨, 그래서 결국 조직 전체가 무능한 사람들로 채워지는 역설적인 상황 
    - 코드는 정말 잘짜지만 사람을 관리하거나 팀을 이끌 마음이 전혀 없는 엔지니어에게 억지로 관리자나 테크 리드 역할을 맡기면, 여러분은 형편없는 관리자를 얻는 대신 뛰어난 엔지니어를 잃게됨 
  - 섬기는 리더십(Servant Leadership)
    - 팀을 떠받드는 것, 섬기는 리더로서 여러분은 겸손,존중,신뢰의 분위기를 조성하려 힘써야함
    - 섬기는 리더는 팀이 나아가는 길 앞의 균열을 메우고 필요할 때 조언을 해줌, 자신의 손을 더럽히는 데 주저하지 않음, 섬기는 리더가 행하는 관리는 오직 팀의 기술적, 사회적 건강 관리뿐 
- 오늘날의 엔지니어링 관리자
  - 전통적인 관리자는 일을 어떻게 처리할지를 고민하는 반면, 훌륭한 관리자는 무슨일을 처리할지 고민함(그리고 어떻게는 팀을 믿고 맡김) 
- 안티패턴
  - 만만한 사람 고용하기
    - 여러분보다 똑똑하고 여러분을 대체할 역량을 갖춘 사람을 적극적으로 뽑아야함, 실제로 그 사람들이 여러분의 위치를 시시때때로 위협할 수 있음(여러분이 실수를 저지르면 지적해주기도 하고요), 하지만 이 사람들은 여러분에게 강렬한 자극과 함께 멋진 일들도 안겨줄 것
    - 스스로 할 일을 찾고 확장하며, 일부는 스스로 팀을 이끌고 싶어 할 것 
  - 저성과자 방치하기
    - 저성과자의 역량이 높아지기를 혹은 어디론가 떠나기를 희망하는 사이, 팀의 다른 고성과자들은 저성과자들을 밀고 당겨주느라 귀중한 에너지를 낭비하고 팀의 사기는 서서히 떨어져감
    - 저성과자를 방치하는 일은 새로운 고성과자가 팀에 합류하는 걸 막기도 하며, 그나마 있던 팀내 고성과자를 떠나게도 함 
  - 사람 문제 무시하기
  - 만인의 친구 되기 
  - 채용 기준 타협하기
  - 팀을 어린이처럼 대하기 
- 올바른패턴
  - 자존심 버리기
    - 리더 역할이 처음인 사람은 대부분 모든 사안을 올바르게 결정하고, 모든 것을 알고, 모든 질문에 답해야 한다는 강박으로 스스로를 옭아맴
    - 사과한다고 돈이 드는 건 아니잖아요? 사람들은 무언가를 망쳤으면 사과할 줄 아는 리더를 존경함 
  - 마음 다스리기
  - 촉매자 되기
    - 고무 오리 디버깅(Rubber Duck Debugging) : 먼저 고무 오리 인형을 장만하고, 고무 오리에게 문제의 코드를 한줄 한줄 설명하다 보면 오리가 깨달음을 주곤 함, 자신의 생각을 정리하다 보면 해결책이 떠오르곤 하는 원리를 고무 오리라는 가상의 대화 상대를 촉매로 디버에 적용한 기법
  - 장애물 치우기 
  - 선생이자 멘토 되기
    - 새로 합류하여 팀의 문화에 익숙해지고 적절한 수준 및 팀이 활용하는 기술과 코드베이스를 공부하고 있는 팀원에게 매우 중요함
    - 훌륭한 멘토라면 성장하는 팀에 발맞춰 멘티가 배우는 데 쓰는 시간과 제품 개발에 기여하는 시간의 균형을 잘 잡아줘야 함
    - 팀의 프로세스와 체계에 대한 경험, 다른 이에게 무언가를 설명해주는 능력, 마지막으로 멘티에게 도움이 얼마나 필요한지를 측정하는 능력 
  - 명확한 목표 세우기 
  - 정직하기 
  - 행복한지 확인하기 
    - 리더로서 팀의 생산성을 장기적으로 더욱 끌어올리려면(이탈하는 팀원 줄이기 포함) 팀원들이 행복해하는지를 확인하는 데도 시간을 써야함 
    - 수시로 팀원들의 복지를 챙기고, 그들이 하는 일을 인정해주고, 일에 만족하는지 확인하기, 한 테크 리드 매니저는 지저분하고 표 안 나는 일, 하지만 꼭 해야만 하는 일들을 스프레드시트에 정리한 다음 모든 팀원에게 고르게 분배되도록 관리함 
    - 테크 리드 매니저는 팀이 일한 시간을 측정하여 이따금 대체 휴가를 주거나 팀 소풍을 보내주기도 했음, 번아웃과 피로 누적을 피하는 방법
    - 팀원들과의 서먹함도 줄일 겸 일대일 면담을 하며 기술적인 이야기를 나누곤 함, 친해진 다음에는 하는 일에 만족하는지, 다음 프로젝트로 무얼 하고 싶은지 같은 이야기를 나눴음 
    - 마지막에 뭐 필요한거 없어요?라고 묻는 것, 팀원들의 생산성과 행복 증진에 필요한 것을 갖춰주는 데 아주 효과적인 마무리 멘트 

## 성장하는 조직 이끌기
- 3A 리더십 : 늘 결정하라(Always Be Deciding) , 늘 떠나라(Always Be Leaving), 늘 확장하라(Always Be Scaling)
- 웹 검색의 트레이드 오프 : 좋게(품질), 빠르게(지연시간), 저렴하게(용량)
- 성공 사이클
  - 분석 : 문제가 주어지고 해결하기 위해 씨름을 시작함
  - 분투 : 팀이 준비가 덜 되었다고 생각하더라도 일에 착수함, 실패할 경우에도 대비해야 함
  - 견인 : 결국 팀이 문제를 정복하기 시작함
  - 보상 : 성공의 보상은 더 많은 일과 더 많은 책임 
  - 압축 단계(compression stage) : 새로운 문제를 받아왔는데 (보통은) 인력 충원은 없음, 맡겨진 문제가 두 개가 되어버렸음, 원래의 문제도 여전히 관리가 필요하니 절반의 인력과 절반의 시간을 할애함 , 결국 새로운 문제는 나머지 절반의 인력으로만 대응해야 함, 이러한 사이클의 마지막 단계를 뜻함, 지금까지 하던 모든 작업을 절반 크기로 압축한다는 뜻 
  - 문제를 압축하려면 팀 효율을 극대화할 방법을 찾아야 하며, 동시에 자신의 시간과 집중력을 더 커진 책임 범위에 맞춰 확장하는 방법도 배워야 함 
- 에너지 관리하기
  - 진짜 휴가 떠나기 
  - 일과 쉽게 단절하기 : 일에서 신경을 끄려거든 업무용 랩톱을 회사에 두고 떠나기, 휴대폰에 업무용 앱이 깔려있다면 지우기
  - 진짜 주말 보내기 : 직장과 단절된 상태에서만 재충전이 이뤄짐, 금요일 저녁에 미련 없이 퇴근한 후 주말에는 오롯이 자신이 좋아하는 일만 하기 
  - 매일매일 휴식하기 : 자연적으로 인간의 뇌는 90분 주기로 운용됨, 90분마다 돌아오는 이 기회를 의자에서 일어나 사무실 주변을 돌거나 10분 정도 산책하는데 사용하기 
  - 스스로에게 정신 건강의 날을 가질 수 있는 권한을 부여하기 

## 엔지니어링 생산성 측정하기 
- GSM 프레임워크 : 목표와 신호를 뒷받침하는 의미 있는 지표 선정하기 
  - GSM은 목표(goal), 신호(signal), 지표(metric)의 약자
  - 목표는 측정자가 원하는 최종 결과, 측정을 통해 이해하고 싶은 내용을 고차원의 어휘로 표현하되 특정한 측정 방식을 명시해서는 안 됨
  - 신호는 원하는 최종 결과를 이루었는지 판단하는 방법, 우리가 측정하고 싶어 하는 것이지만 신호 자체는 측정하지 못할 수도 있음
  - 지표는 신호를 대변함, 우리가 실제로 측정하는 대상, 이상적인 측정법은 아닐 수 있으나 충분히 가깝다고 믿는 것이어야 함 
  - 가로등 효과(streetlight effect) : 가로등 아래에서 열쇠 찾기, 보이는 곳만 봐서는 정작 열쇠가 떨어진 곳은 살펴보지 못할 수 있다는 뜻 
  - GSM은 실제로 결과를 측정하기 앞서 원칙에 입각하여 적절한 지표들을 선정하게 해줌으로써 지표 크리프(metrcis creep)와 지표 편향(metrics bias)을 예방해줌
  - GSM은 측정이 되는 영역과 그렇지 않은 영역을 알려줌 
- 목표
  - 퀀츠(QUNATS)
    - 코드 품질(Quality of the code) : 작성한 코드의 품질은 어떤가? 희귀 버그를 예방하기에 충분한 테스트 케이스가 갖춰졌는가? 아키텍처는 위험과 변경을 받아들일 수 있을 만큼 유연한가? 
    - 엔지니어들의 몰입도(Attention from engineers) : 엔지니어들이 얼마나 자주 몰입 상태에서 깨어나는가? 알림은 엔지니어의 주의력이 얼마나 흐트리는가? 도구는 엔지니어들이 작업 맥락을 전환하는 데 도움을 주는가?
    - 지적 복잡성(intellectual complexity) : 작업을 완료하는 데 인지 부하가 얼마나 걸리는가? 해결해야 할 문제에 내재된 복잡성은 어느 정도인가? 엔지니어들이 불필요한 복잡성을 처리해야 하는가?
    - 박자와 속도(Tempo and velocity) : 엔지니어들이 작업을 얼마나 빨리 완수할 수 있는가? 릴리스를 얼마나 빨리 밀어낼 수 있나? 주어진 시간에 얼마나 많은 작업을 완료하는가?
    - 만족도(Statisfaction) : 엔지니어가 도구에 얼마나 만족하는가? 도구가 엔지니어에게 필요한 기능을 얼마나 잘 지원하는가? 엔지니어들이 주어진 업무와 완성한 제품에 얼마나 만족하는가? 엔지니어들이 번아웃되지는 않는가?

# 프로세스 
## 스타일 가이드와 규칙
- 규칙은 곧 법, 제안이나 권장사항이 아닌, 엄격하고 꼭 지켜야 하는 법
- 지침(guidance)은 권장사항과 모범 사례를 말함, 따르면 편이 이득이라서 어지간하면 따르라고 권하지만, 규칙과 달리 다소 변형해 적용해도 괜찮음 
- 규칙을 만들때 중요한 원칙
  - 규칙의 양을 최소화
  - 코드를 읽는 사람에게 맞춤
  - 일관되어야 함
  - 오류가 나기 쉽거나 예상치 못한 동작을 유발하는 구조를 피함
  - 꼭 필요하다면 실용성을 생각해 예외를 허용함 
- 스타일 가이드
  - 위험을 피하기 위한 규칙
  - 모범 사례를 적용하기 위한 규칙
  - 일관성을 보장하기 위한 규칙 
- 사소함의 법칙(law of triviality) : 중요한 사안을 고민하는 데는 아주 적은 시간만 들이면서 사소한 일에는 필요 이상의 시간과 노력을 들이는 현상 
- 스타일의 중재자
  - 스타일 중재자(style arbiter) : 구글의 스타일 가이드들은 언어별로 소유자가 따로 있어서 최종 결정과 승인을 책임짐, 이러한 소유자 들을 일컬음
  - 프로그래밍 언어별로 경험 많은 전무가 그룹이 스타일 가이드를 소유하고 결정권자 역할을 함 
- 프리서브밋 검사(presubmit check) : 서브밋 직전 검사 

## 코드 리뷰
- 코드 리뷰는 작성자 이외의 사람이 코드를 검토하는 프로세스로, 주로 코드를 코드베이스에 반영하기 전에 수행함 
- 코드 리뷰는 버그가 코드베이스로 침투하기 전에 잡아낸다 처럼 확실하고 쉽게 납득하는 이점을 제공함 
- 코드 리뷰 흐름
  - 프리커밋 리뷰(precommit review: 커밋 직전 리뷰) :구글에서는 변경을 코드베이스에 커밋하기 전에 수행함
  - 합의한 엔지니어는 좋아 보임(looks good to me)이라는 뜻의 LGTM이라는 태그를 달아 의사를 표현함 
- 구글의 코드 리뷰
  - 다른 엔지니어로부터 정확성(correctness)과 이해 용이성(comprehension)을 평가받음, 작성자가 의도한 작업을 코드가 적절하게 수행하는지를 봄
  - 변경되는 코드 영역을 관리하는 코드 소유자(code owner)로부터 변경 코드가 적절하다는 (그리고 특정 디렉터리에 체크인해도 좋다는) 승인을 받음 
  - 누군가로부터 가독성 승인을 받음, 변경 코드가 해당 언어의 스타일과 모범 사례를 잘 따르고 조직에서 기대하는 방식으로 작성되었는지를 검사받음 
- 코드 리뷰의 이점
  - 잘 설계된 코드 리뷰 프로세스와 코드 리뷰를 중요하게 다루는 문화가 주는 대표적인 이점
  - 코드가 정확한지 확인해줌
  - 변경된 코드를 다른 엔지니어도 잘 이해함
  - 코드베이스가 일관되게 관리됨
  - 팀이 소유권(주인의식)을 더 강하게 느낌
  - 지식이 공유됨
  - 코드 리뷰 자체의 기록이 남음 
- 지식 공유
  - 리뷰 프로세스는 제안, 신기술 소개, 조언을 통해 리뷰어가 변경 작성자에게 도메인 지식을 전파하도록 이끌어줌(리뷰어는 작성자를 도와줄 생각으로 가볍게 FYI 주석을 남길수 있음 - 참고로, for your information)
- 코드 리뷰 유형
  - 그린필드 리뷰와 새로운 기능 개발
    - 완전히 새로운 코드를 대상으로 하는 가장 드문 유형의 코드리뷰, 대상 코드가 오랜 기간 존속될 수 있는지를 평가하기에 가장 중요한 기회
    - 코드는 시간이 흐르고 프로젝트 규모가 커져 초기에 내린 가정들이 변해도 여전히 유지보수하기 쉬워야 함 
    - 그린필드 : 아무런 기반 시설이나 기초 작업 없이 잡초만 무성한 허허벌판에서 시작하는 공사에 빗대어 부름 
  - 동작 변경, 개선, 최적화
    - 꼭 필요한 변경인지, 코드베이스를 개선하는지를 살펴야 함
  - 버그 수정과 롤백
  - 리팩터링과 대규모 변경 
    - 대규모 변경(large-scale change(LSC) 프로세스ㅓ)

## 문서자료
- 코드와 독립적인 일반적인 의미인 문서 혹은 기록으로 남기는 행위로서의 문서화와 명확하게 구분하기 위해 문서자료로 옮김
- 문서자료의 혜택
  - API를 가다듬는 데 도움을 줌, API 문서화는 API가 가치가 있는지를 알아내는 가장 확실한 방법 중 하나, 문서화를 하다 보면 자연스럽게 자신의 설계를 되돌아보게 됨
  - 유지보수를 위한 로드맵과 과거 이력을 제공함, 코딩에서 꼼수는 무조건 피해야 하지만, 어쩔 수 없다면 주석이라도 잘 달아둬야 함 
  - 코드를 더 전문적이고 매력 있어 보이게 함 
  - 이용자들의 질문이 줄어듬
- 문서자료의 취급
  - 꼭 따라야 하는 내부 정책과 규칙이 있어야 함
  - 버전 관리 시스템에 등록해 관리해야 함
  - 관리 책임자를 명시해야 함
  - 변경 시 (문서자료가 설명하는 코드와 함께) 리뷰를 거쳐야 함
  - 코드상의 버그를 추적하듯 문제를 추적해야 함
  - 주기적으로 평가(혹은 테스트)를 받아야 함
  - 가능하다면 정확성이나 최신 정보 반영 여부 등을 측정해야함
- 독자 유형
  - 문서를 짧게 쓰려면 때로는 모든 정보를 담아 길게 쓴 다음 간명하게 편집하고 중복된 정보를 삭제하는 과정을 거쳐야 함
  - 프랑스의 철학자인 블레즈 파스칼(Blaise Pascal)은 시간이 더 있었따면 편지가 보다 짧아졌을 거에요 라고 말함
  - 탐색자(seeker) : 자신이 원하는 것을 정확히 알고, 읽고 있는 문서자료가 원하는 정보를 담고 있는지를 알고 싶어 하는 엔지니어, 일관성이 핵심, 비슷한 포맷을 일관되게 적용하는 게 좋음 
  - 배회자(stumbler) : 무엇을 원하는지를 정확하게 알지 못하는 사람, 명료한 글이 효과적
- 문서자료 유형
  - 소프트웨어 엔지니어가 자주 작성하게 되는 주요 문서의 종류
    - 참조용 문서자료(코드 주석 포함)
    - 설계 문서
    - 튜토리얼
    - 개념 설명 문서자료
    - 랜딩 페이지
- 문서자료 리뷰
  - 정확성 확인용 기술 리뷰 : 주로 해당 주제 전문가가 수행하며, 팀 동료인 경우가 많음, 코드 리뷰 과정에서 함께 다룸
  - 명확성 확인용 독자 리뷰 : 주로 도메인을 잘 모르는 사람이 수행함, 팀에 새로 합류한 동료나 해당 API의 고객일 것
  - 일관성 확인용 작문 리뷰 : 주로 테크니컬 라이터나 지원자가 수행함
- 좋은 문서 자료의 특징 : 완전성(completeness), 정확성(accuracy), 명확성(clarity)

## 테스트 개요
- 테스트를 작성하는 이유
  - 테스트하려는 단 하나의 행위(주로 메서드나 API)
  - 특정한 입력(API에 전달하려는 값)
  - 관측 가능한 출력 혹은 동작
  - 통제된 조건(하나의 격리된 프로세스 등)
- 테스트 스위트(test suit) : 간단한 테스트가 수백에서 수천 개 모이는것
- 가장 순수한 형태의 자동 테스트는 테스트 작성, 테스트 수행, 실패한 테스트에 대한 조치, 자동 테스트는 적은 양의 코드로 구성됨
- 테스트 코드가 주는 혜택
  - 디버깅 감소
  - 자신 있게 변경
  - 더 나은 문서자료
  - 더 단순한 리뷰
  - 사려 깊은 설계
  - 고품질의 릴리스를 빠르게
- 테스트 스위트 설계하기
  - 크기는 테스트 케이스 하나를 실행하는 데 필요한 자원을 뜻함, 메모리, 프로세스, 시간 등 
  - 범위는(scope)는 검증하려는 특정한 코드 경로(code path)를 뜻함
- 작은 테스트
  - 테스트가 단 하나의 프로세스에서 실행되어야 한다는 것 
  - 테스트도 테스트 대상 코드와 같은 프로세스에서 실행되어야 한다는 뜻 
- 중간 크기 테스트
  - 중간 크기 테스트는 여러 프로세스와 스레드를 활용할 수 있고, 로컬 호스트로의 네트워크 호출 같은 블로킹 호출도 이용할 수 있음, 단 외부 시스템과의 통신은 여전히 불허함
- 큰 테스트
  - 중간 크기 테스트를 구속하던 로컬 호스트 제약에서 해방되어, 테스트와 대상 시스템이 여러 대의 기기를 활용할 수 있게 됨
  - 전체 시스템의 종단간(end-to-end) 테스트 - 코드 조각이 아닌 설정을 검증하는게 주된 목적
  - 테스트 대역을 사용하는 게 불가능한 레거시 컴포넌트를 테스트할 때
- 테스트 크기와 무관한 공통 특성
  - 모든 테스트는 밀폐(hermetic)되어야 함, 셋업(setup), 실행(execute), 테어다운(tear down)하는 데 필요한 모든 정보를 담고 있어야 함
  - 테스트 수행 순서 같은 외부 환경에 관해서는 가능한한 아무것도 가정하지 않아야 함 
- 테스트 범위(test scope)
  - 주어진 테스트가 얼마나 많은 코드를 검증하느냐 
  - 좁은 범위 테스트(narrow-scoped test)는 독립된 클래스나 메서드같이 코드베이스 중 작은 일부 로직을 검증하도록 설계됨
  - (보통 통합 테스트 integration test)중간 범위 테스트(medium-scoped test)는 적은 수의 컴포넌트들 사이의 상호작용을 검증하도록 설계됨, 서버와 데이터베이스의 상호작용을 검증함
  - (보통 기능 테스트 functional test, 종단간 테스트 end-to-end test, 시스템 테스트 system test 등으로 불리는) 넓은 범위 테스트(large-scoped test)는 시스템의 서로 다른 부분들 사이의 상호작용, 혹은 클래스나 메서드 하나만 실행할 때는 괜찮다가 여럿을 조합해 실행하면 나타나는 예기치 못한 동작을 검증하도록 설계됨 
  - 아이스크림 콘(ice cream cone)에서는 엔지니어들이 종단간 테스트를 많이 작성하고 통합 테스트나 단위 테스트는 훨씬 적게 작성함, 스위트는 일반적으로 느리고 신뢰할 수 없으며 고치기도 어려움
  - 모래시계(hourglass)는 종단간 테스트와 단위 테스트는 많지만 통합 테스트가 적음, 구성요소들이 강하게 커플링되어 각각의 인스턴스를 독립적으로 만들어낼 수 없을 때 나타남 
- 의도적으로 실패 상황을 만드는 테스트
  - 단위 테스트에서라면 예외나 에러를 시뮬레이션해볼 수 있고, 통합 테스트나 종단간 테스트에서라면 원격 프로시저 호출(RPC) 오류를 주입하거나 지연시간을 늘려볼 수 있음
  - 카오스 엔지니어링(chaos engineering) 같은 기법을 활용하면 실제 프로덕션 네트워크에 영향을 주는 훨씬 더 큰 중단 사태도 시뮬레이션할 수 있음 
  - 신뢰할 수 있는 시스템이라면 부정적인 조건을 예측하고 대응 방식을 통제할 수 있어야 함
- 코드 커버리지
  - 어느 테스트가 기능 코드의 어느 라인을 실행하는지를 측정하는 수단 
- 모노리포(monorepo) : 여러 프로젝트의 코드를 하나의 리포지터리에서 관리하는 소프트웨어 개발 전략을 말함 

## 단위 테스트
- 크기는 테스트가 소비하는 자원과 수행할 수 있는 작업을 뜻하며, 범위는 테스트가 검증고자 하는 코드의 양을 의미함
- 단위 테스트(unit test) : 단일 클래스나 메서드처럼 범위가 상대적으로 좁은 테스트를 뜻함
- 테스트의 가장 중요한 목적은 버그 예방, 엔지니어의 생산성 개선
- 특성
  - 구글의 테스트 크기 정의에 따르면 단위 테스트는 대체로 작은 테스트에 속함, 작은 테스트는 빠르고 결정적이어서 개발자들이 수시로 수행하며 피드백을 즉각 얻을 수 있음
  - 단위 테스트는 대체로 대상 코드와 동시에 작성할 수 있을 만큼 작성하기 쉬움, 따라서 엔지니어들은 커다란 시스템을 설정하거나 이해할 필요 없이 작성 중인 코드를 검증하는 데 집중할 수 있음 
  - 빠르게 작성할 수 있으므로 테스트 커버리지를 높이기 좋음, 커버리지가 높다면 엔지니어들은 기존 동작을 망가뜨리지 않으리라는 확신 속에서 코드를 변경할 수 있음
  - 각각의 테스트는 개념적으로 간단하고 시스템의 특정 부분에 집중하므로 실패 시 원인을 파악하기 쉬움
  - 대상 시스템의 사용법과 의도한 동작 방식을 알려주는 문서자료 혹은 예제 코드 역할을 해줌 
- 유지보수하기 쉬운 테스트는 그냥 작동하는(just work) 테스트를 말함, 한 번 작성해두면 실패하지 않는 한 엔지니어가 신경 쓸 필요 없고, 혹 실패한다면 원인을 바로 알 수 있는 진짜 버그를 찾았다는 뜻
- 깨지기 쉬운 테스트 예방하기
  - 실제로는 버그가 없음에도, 심지어 검증 대상 코드와는 관련조차 없는 변경 때문에 실패하는 테스트를 말함 
  - 불규칙한 테스트(flaky test) : 대상 코드에 아무런 변경이 없음에도 무작위로 실패함 
- 변하지 않는 테스트를 만들기 위해 노력하자
  - 순수 리팩터링 : 성능 최적화, 코드 가독성 개선 등이 속함, 테스트의 역할은 리팩터링 후에도 시스템의 행위가 달라지지 않았음을 보장하는 것
  - 새로운 기능 추가 : 새로운 기능이나 행위를 추가할 때는 기존 행위들에 영향을 주지 않아야 함
  - 버그 수정 : 새로운 기능 추가와 비슷함
  - 행위 변경 : 시스템의 기존 행위를 변경하는 경우로, 기존 테스트 역시 변경되어야 함
  - 리팩터링, 새 기능 추가, 버그 수정 시에는 기존 테스트를 손볼 일이 없어야 한다는 것, 시스템을 확장할 때는 기존 테스트들을 일일이 손보는 게 아니라 확장한 부분과 관련된 소수의 테스트만 새로 작성하면 됨 
- 상호작용이 아니라 상태를 테스트하자
  - 상태 테스트(state test) : 메서드 호출 후 시스템 자체를 관찰함
  - 상호작용 테스트(interaction test) : 호출을 처리하는 과정에서 시스템이 다른 모듈(시스템)들과 협력하여 기대한 일련의 동작을 수행하는지를 확인함 
- 명확한 테스트 작성하기
  - 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트를 말함 
- 완전하고 간결하게 만들자
  - 완전한 테스트(complete test) : 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 담고 있는 테스트를 말함 
  - 간결한 테스트(concise test) : 코드가 산만하지 않고, 관련 없는 정보는 포함하지 않은 테스트 
- 공유 셋업
  - 셋업(setup) 메서드 : 많은 테스트 프레임워크가 하나의 테스트 스위트에 속한 테스트 각각을 수행하기 직전에 실행되는 메서드를 정의할 수 있게 해줌 

## 테스트 대역
- 테스트 대역(test double) : 실제 구현 대신 사용할 수 있는 객체나 함수를 말함 
- 목(mock)은 테스트 대역 중 한 형태인 모의 객체를 저장할 때도 쓰기 때문 
- 테스트 대역이 소프트웨어 개발에 미치는 영향
  - 테스트 용이성(testability)
    - 테스트 대역을 사용하려면 코드베이스가 테스트하기 쉽도록 설계되어 있어야 함 
  - 적용 가능성(applicability)
    - 테스트 대역을 제대로 활용하면 엔지니어링 속도가 크게 개선되겠지만, 잘못 사용하면 오히려 깨지기 쉽고 복잡하고 효율도 나쁜 테스트로 전락함
  - 충실성(fidelity)
    - 테스트 대역이 실제 구현의 행위와 얼마나 유사하냐를 말함
- 효과적인 테스트 대역 사용법을 위한 기본 개념
  - 이어주기(seam)
    - 제품 코드 차원에서 테스트 대역을 활용할 수 있는 길을 터줘서 테스트하기 쉽게끔 만들어주는 걸 뜻함 
    - 프로덕션 환경에서 이용하는 의존 대상을 다른 대상으로 교체할 수 있도록 해주면 됨 
    - 의존성 주입(dependency injection - DI) : 의존성 주입을 활용하는 클래스는 필요한 클래스(의존성)를 내부에서 직접 생성하지 않고 외부에서 건네받음
  - 모의 객체 프레임워크(mocking framework)
    - 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리 
    - 객체를 대역으로 대체할 수 있게 해줌, 모의 객체(mock)는 구체적인 동작 방식을 테스트가 지정할 수 있는 테스트 대역을 말함
- 테스트 대역 활용 기법
  - 속이기(가짜 객체 fake object) : 제품 코드로는 적합하지 않지만 실제 구현과 비슷하게 동작하도록 가볍게 구현한 대역
  - 뭉개기(스텁 stub) : 원래는 없던 행위를 부여하는 과정을 말함
    - 스텁을 이용한 뭉개기는 원래는 없는 행위를 테스트가 함수에 덧씌우는 방법, 테스트에서 실제 구현을 대체할 수 있는 쉽고 빠른 방법
    - 스텁 과용의 위험성
      - 불명확해진다
      - 깨지기 쉬워진다
      - 테스트 효과가 감소한다
  - 상호작용 테스트(interaction test) : 대상 함수를 실제로 호출하지 않고도 그 함수가 어떻게 호출되는지를 검증하는 기법 
    - 상태 테스트(state test) : 대상 시스템을 호출하여 올바른 값을 반환하는지, 혹은 대상 시스템의 상태가 올바르게 변경되었는지를 검증하는 테스트, 상호작용 테스트보다 상태 테스트를 우선하는게 좋음 
    - 상호작용 테스트가 적합한 경우
      - 실제 구현이나 가짜 객체를 이용할 수 없어서(실제 구현은 너무 느리고 가짜 객체는 존재하지 않아서) 상태 테스트가 불가능한 경우
      - 함수 호출 횟수나 호출 순서가 달라지면 기대와 다르게 동작하는 경우 
- 실제 구현
  - 고전적 테스트(classical test) : 실제 구현을 선호하는 테스트 방식
  - 모의 객체 중심주의 테스트(mockist test) : 모의 객체 프레임워크를 선호하는 테스트 방식 
- 결정성
  - 결정적(deterministic) 테스트 : 같은 버전의 시스템을 대상으로 실행하면 언제든 똑같은 결과를 내어주는 테스트, 항상 성공하거나 항상(같은 이유로) 실패해야 한다는 뜻
  - 비결정적(nondeterministic) 테스트 : 대상 시스템은 그대로인데 결과가 달라지는 테스트
