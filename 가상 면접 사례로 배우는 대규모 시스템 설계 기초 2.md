- 좋은 설계는 운영 관리의 편의성, 비용, 개선 및 개발 용이성 등의 다양한 주제를 오랜 시간 동안 고단하고 탐구한 끝에 탄생함

# 근접성 서비스
- 문제 이해 및 설계 범위 확정
  - 비기능 요구사항
    - 낮은 응답 지연(latency) : 사용자는 주변 사업장을 신속히 검색할 수 있어야 함
    - 데이터 보호(data privacy) : 사용자 위치는 민감한 정보. 위치 기반 서비스(LBS)를 설계할 때는 언제나 사용자의 정보를 보호할 방법을 고려해야 함. GDPR,CCPA 같은 데이터 사생활 보호 법안을 준수하도록 해야 함
    - 고가용성(high availability) 및 규모 확장성(scalability) 요구사항 : 인구 밀집 지역에서 이용자가 집중되는 시간에 트래픽이 급증해도 감당할 수 있도록 시스템을 설계해야 함 
- 개략적 설계안 제시 및 동의 구하기
  - API 설계
    - 사업장 관련 API
      - GET : 특정 사업장의 상세 정보 반환
      - POST : 새로운 사업장 추가
      - PUT : 사업장 상세 정보 갱신
      - DELETE : 특정 사업장 정보 삭제
  - 데이터 모델
    - 읽기 연산이 압도적인 시스템에는 MySQL 같은 관계형 데이터베이스가 바람직할 수 있음
  - 개략적 설계
    - 로드밸런서
      - 유입 트래픽을 자동으로 여러 서비스에 분산시키는 컴포넌트
      - 통상적으로 로드밸런서를 사용하는 회사는 로드밸런서에 단일 DNS 진입점(entry point)을 지정하고, URL 경로를 분석하여 어느 서비스에 트래픽을 전달할지 결정함 
    - 데이터베이스 클러스터
      - 주 데이터베이스는 쓰기 요청을 처리하며, 부 데이터 베이스, 즉 사본 데이터베이스는 읽기 요청을 처리함 
    - 주변 사업장 검색 알고리즘
      - 해시 기반 방안: 균등 격자, 지오해시, 카르테시안 계층 등
      - 트리 기반 방안 : 쿼드트리, 구글 S2, R 트리 등
      - 지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 색인을 만드는것. 지오해시, 쿼드트리, 구글 S2는 실제로 가장 널리 사용되는 방안 
- 상세 설계
  - 지역 및 가용성 구역
    - 기대 효과
      - 사용자와 시스템 사이의 물리적 거리를 최소한으로 줄일 수 있음. 미국 서부 사용자는 해당 지역 데이터 센터로 연결될 것이고, 유럽 사용자는 유럽 데이터 센터로 연결될 것
      - 트래픽을 인구에 따라 고르게 분산하는 유연성을 확보할 수 있음. 일본과 한국 같은 지역은 인구 밀도가 아주 높음. 그런 국가는 별도 지역으로 빼거나, 아예 한 지역 안에서도 여러 가용성 구역을 활용하여 부하를 분산시키는 것이 바람직할 수 있음 
      - 어떤 국가는 사용자 데이터를 해당 국가 이외의 지역으로 전송하지 못하도록 함. 그런 경우에는 해당 국가를 별도 지역으로 빼고, 해당 국가에서 발생하는 모든 트래픽은 DNS 라우팅을 통해 해당 지역 내 서비스가 처리하도록 해야 함 

# 주변 친구
- 개략적 설계안 제시 및 동의 구하기
  - RESTful API 서버
    - 무상태(stateless) API 서버의 클러스터로서, 통상적인 요청/응답 트래픽을 처리함 
  - 레디스 위치 정보 캐시
    - 레디스에 보관하는 캐시 항목에는 TTL(Time-To-Live) 필드가 있음. 이 기간이 지나면 해당 사용자는 비활성 상태로 바뀌고 그 위치 정보는 캐시에서 삭제됨
  - 레디스 펍/섭 서버
    - 레디스 펍/섭은 초경량 메시지 버스. 레디스 펍/섭에 새로운 채널을 생성하는 것은 아주 값싼 연산 
- 상세 설계
  - 레디스 펍/섭 서버
    - 구독자가 없는 채널로 전송된 메시지는 그대로 버려지는데, 그 과정에서 서버에 가해지는 부하는 거의 없음
    - 채널 하나를 유지하기 위해서는 구독자 관계를 추적하기 위해 해시 테이블과 연결 리스트가 필요한데 아주 소량의 메모리만을 사용함 

# 구글 맵
- 상세 설계
  - 카프카는 응답 지연이 낮고 많은 데이터를 동시에 처리할 수 있는 데이터 스트리밍 플랫폼으로, 실시간 데이터 피드를 지원하기 위해 고안되었음 

# 분산 메시지 큐
- 메시지 큐를 사용하면 이득
  - 결합도 완화(decoupling) : 메시지 큐를 사용하면 컴포넌트 사이의 강한 결합이 사라지므로 각각을 독립적으로 갱신할 수 있음
  - 규모 확장성 개선 : 메시지 큐에 데이터를 생산하는 생산자와 큐에서 메시지를 소비하는 소비자 시스템 규모를 트래픽 부하에 맞게 독립적으로 늘릴 수 있음
  - 가용성 개선 : 시스템의 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 계속 상호작용을 이어갈 수 있음
  - 성능 개선 : 메시지 큐를 사용하면 비동기 통신이 쉽게 가능함. 생산자는 응답을 기다리지 않고도 메시지를 보낼 수 있고, 소비자는 읽을 메시지가 있을 때만 해당 메시지를 소비하면 됨 
- 유명 분산 메시지 큐
  - 아파치 카프카
  - 아파치 RocketMQ
  - 아파치 RabbitMQ
  - 아파치 펄사
  - 아파치 ActiveMQ
  - ZeroMQ
- 메시지 큐 대 이벤트 스트리밍 플랫폼 
  - 전형적인 메시지 큐 RabbitMQ는 옵션으로 제공되는 스트리밍 기능을 추가하면 메시지를 반복적으로 소비할 수 있는 동시에 데이터의 장기 보관도 가능함. 그 기능은 데이터 추가만 가능한 로그를 통해 구현되어 있는데, 이벤트 스트리밍 플랫폼 구현과 유사함
  - 아파치 펄사는 기본적으로 카프카의 경쟁자이지만, 분산 메시지 큐로도 사용이 가능할 정도로 유연하고 성능도 좋다
  - 데이터 장기 보관, 메시지 반복 소비 등의 부가 기능을 갖춘 분산 메시지 큐를 설계
- 문제 이해 및 설계 범위 확정
  - 메시지 큐의 기본 기능 - 생산자는 메시지를 큐에 보내고, 소비자는 큐에서 메시지를 꺼낼 수 있으면됨
  - 메시지 전달방식, 데이터 보관기간 등 고려할 사항은 다양함
    - 메시지의 형태와 평균 크기, 텍스트 메시지만 지원하면 됨? 멀티미디어도 지원?
    - 메시지는 반복적으로 소비될 수 있어야 하나요? 메시지를 여러 소비자에게 수신하는 것이 가능해야 함
    - 메시지는 큐에 전달된 순서대로 소비되어야 하나요?
    - 데이터의 지속성이 보장되어야 하나요? 기간은 얼마 동안인가요?
    - 지원해야 하는 생산자와 소비자 수는 어느 정도입니까?
    - 어던 메시지 전달 방식을 지원해야 하나요? 최대 한 번, 최소 한 번, 정확히 한번 
    - 목표로 삼아야 할 대역폭과 단대단 지연 시간을 알려주 실 수 있으실 까요?
  - 기능 요구사항
    - 생산자는 메시지 큐에 메시지를 보낼 수 있어야 함
    - 소비자는 메시지 큐를 통해 메시지를 수신할 수 있어야 함
    - 메시지는 반복적으로 수신할 수도 있어야 하고, 단 한 번만 수신하도록 설정될 수도 있어야 함
    - 오래된 이력 데이터는 삭제될 수 있음
    - 메시지 크기는 킬로바이트 수준
    - 메시지가 생산된 순서대로 소비자에게 전달할 수 있어야 함
    - 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 함
  - 비기능 요구사항
    - 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정으로 선택 가능하게 하는 기능
    - 규모 확장성, 이 시스템은 특성상 분산 시스템일 수밖에 없음. 메시지 양이 급증해도 처리 가능해야 함
    - 지속성 및 내구성, 데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제되어야 함 
  - 전통적 메시지 큐와 다른점
    - RabitMQ와 같은 전통적인 메시지 큐는 이벤트 스트리밍 플랫폼처럼 메시지 보관 문제를 중요하게 다루지 않음
- 개략적 설계안 제시 및 동의 구하기
  - 메시지 큐의 기본 기능
    - 생산자는 메시지를 메시지 큐에 발행
    - 소비자는 큐를 구독하고 구독한 메시지를 소비
    - 메시지 큐는 생산자와 소비자 사이의 결합을 느슨하게 하는 서비스로, 생산자와 소비자의 독립적인 운영 및 규모 확장을 가능하게 하는 역할 담당
    - 생산자와 소비자는 모두 클라이언트/서버 모델 관점에서 보면 클라이언트고 서버 역할을 하는 것은 메시지 큐이며 이 클라이언트와 서버는 네트워크를 통해 통신
  - 메시지 모델
    - 메시지 모델은 일대일과 발행-구독 모델
    - 일대일 모델
      - 큐에 전송된 메시지는 오직 한 소비자만 가져갈 수 있음 
      - 어떤 소비자가 메시지를 가져갔다는 사실을 큐에 알리면 해당 메시지는 큐에서 삭제됨
      - 이 모델은 데이터 보관을 지원하지 않음
    - 발행-구독 모델
      - 토픽은 메시지를 주제별로 정리하는 데 사용됨
      - 각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 가짐
      - 메시지를 보내고 받을 때는 토픽에 보내고 받게 됨
  - 토픽,파티션,브로커
    - 토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당하기 힘든 상황이 벌어지면 어떻게 될까?
    - 파티션,즉 샤딩 기법을 활용. 토픽을 여러 파티션으로 분할한 다음에 메시지를 모든 파티션에 균등하게 나눠 보냄
    - 파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치함. 파티션을 유지하는 서버는 보통 브로커라 부름.
    - 파티션을 브로커에 분산하는 것이 높은 규모 확장성을 달성하는 비결. 토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 되기 때문
  - 소비자 그룹
    - 같은 그룹 내의 소비자는 메시지를 병렬로 소비할 수 있음
    - 데이터를 병렬로 읽으면 대역폭 측면에서는 좋지만 같은 파티션 안에 있는 메시지를 순서대로 소비할 수는 없음 
    - 한 가지 제약사항을 추가하면 이 문제를 해결. 어떤 파티션의 메시지는 한 그룹 안에서는 오직 한 소비자만 읽을 수 있도록 하는 것
    - 그룹 내 소비자의 수가 구독하는 토픽의 파티션 수보다 크면 어떤 소비자는 해당 토픽에서 데이터를 읽지 못하게 됨 
  - 개략적 설계안 
    - 클라이언트
      - 생산자 : 메시지를 특정 토픽으로 보냄
      - 소비자 그룹 : 토픽을 구독하고 메시지를 소비함
    - 브로커 : 파티션들을 유지함. 하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지함
    - 저장소
      - 데이터 저장소 : 메시지는 파티션 내 데이터 저장소에 보관됨
      - 상태 저장소 : 소비자 상태는 이 저장소에서 유지됨
      - 메타데이터 저장소 : 토픽 설정, 토픽 속성 등은 이 저장소에 유지됨
    - 조정 서비스
      - 서비스 탐색 : 어떤 브로커가 살아있는지 알려줌
      - 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당해야 하며, 한 클러스터에는 반드시 활성 상태 컨트롤러가 하나 있어야 함. 이 컨트롤러가 파티션 배치를 책임짐
      - 아파치 주키퍼나 etcd가 보통 컨트롤러 선출을 담당하는 컴포넌트로 널리 이용됨
- 상세 설계
  - 데이터의 장기 보관 요구사항을 만족하면서 높은 대역폭을 제공
    - 회전 디스크의 높은 순차 탐색 성능과 현대적 운영체제가 제공하는 적극적 디스크 캐시 전략을 잘 이용하는 디스크 기반 자료 구조를 활용할 것
    - 메시지가 생산자로부터 소비자에게 전달되는 순간까지 아무 수정 없이도 전송이 가능하도록 하는 메시지 자료 구조를 설계하고 활용할 것
    - 일괄 처리를 우선하는 시스템을 설계할 것
    - 생산자는 메시지를 일괄 전송하고, 메시지 큐는 그 메시지들을 더 큰 단위로 묶어 보관함. 소비자도 가능하면 메시지를 일괄 수신하도록 함
  - 데이터 저장소
    - 메시지 큐의 트래픽 패턴
      - 읽기와 쓰기가 빈번하게 일어남
      - 갱신/삭제 연산은 발생하지 않음
      - 순차적인 읽기/쓰기가 대부분
    - 데이터베이스
      - 관계형 데이터베이스 : 토픽별로 테이블을 만듬. 토픽에 보내는 메시지는 해당 테이블에 새로운 레코드로 추가함
      - NoSQL 데이터베이스 : 토픽별로 컬렉션을 만듬. 토픽에 보내는 메시지는 하나의 문서가 됨 
    - 쓰기 우선 로그(Write-Ahead Log, WAL)
      - WAL은 새로운 항목이 추가되기만 하는(append-only) 일반 파일
      - WAL은 다양한 시스템에서 사용되는 기술인데, MySQL의 복구 로그(redo log)가 WAL로 구현되어 있고 아파치 주키퍼도 해당 기술을 활용함  
  - 메시지 자료 구조
    - 메시지 키
      - 메시지의 키는 파티션을 정할 때 사용됨
      - 키가 주어진 경우 파티션은 hash(key) % numPartitions의 공식에 따라 결정됨
    - 메시지 값
      - 메시지 값은 메시지의 내용, 즉 페이로드를 말함
    - 메시지의 기타 필드
      - 토픽 : 메시지가 속한 토픽의 이름
      - 파티션 : 메시지가 속한 파티션의 ID
      - 오프셋 : 파티션 내 메시지의 위치. 메시지는 토픽, 파티션, 오프셋 세 가지 정보를 알면 찾을 수 있음 
      - 타임스탬프 : 메시지가 저장된 시각
      - 크기 : 메시지의 크기
      - CRC: 순환 중복  검사의 약자로 주어진 데이터의 무결성을 보장하는 데 이용됨 
  - 일괄 처리
    - 일괄 처리가 성능 개선에 중요한 이유
      - 운영체제로 하여금 여러 메시지를 한 번의 네트워크 요청으로 전송할 수 있도록 하기 때문에 값비싼 네트워크 왕복 비용을 제거할 수 있음
      - 브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산이 발생하고 운영체제가 관리하는 디스크 캐시에서 더 큰 규모의 연속된 공간을 점유하게 됨. 그 결과로 더 높은 디스크 접근 대역폭을 달성할 수 있음
    - 높은 대역폭과 낮은 응답 지연은 동시에 달성하기 어려운 목표. 시스템이 낮은 응답 지연이 중요한 전통적 메시지 큐로 이용된다면 일괄 처리 메시지 양은 낮춤
    - 디스크 성능은 다소 낮아짐. 처리량을 높여야 한다면 토픽당 파티션의 수는 늘림. 그래야 낮아진 순차 쓰기 연산 대역폭을 벌충할 수 있음
  - 생산자 측 작업 흐름
    - 라우팅 계층은 적절한 브로커에 메시지를 보내는 역할을 담당함 
  - 소비자 측 작업 흐름
    - 푸시 모델
